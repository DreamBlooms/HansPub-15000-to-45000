"在2 × 2像素块中，参考像素值由索引函数随机确定，然后计算参考像素与其周围的其它三个像素值的差，根据像素差所处的划分范围决定嵌入像素的秘密信息比特数。利用余函数嵌入秘密信息有效地减少载密图像的失真度，在提取信息的过程中，量化后的像素值能准确的提取秘密信息。改进了Jung和Yoo提出的基于索引函数信息隐藏算法，使算法更具有安全性。 关键词 :像素差，索引函数，信息隐藏 Copyright © 2017 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"由于图像的细微改变不会引起人类视觉系统的感知，因此利用图像的视觉冗余，把秘密信息嵌入到图像中，而不影响图像的视觉效果。例如，水印 [ 1 ] 、认证 [ 2 ] 、隐写 [ 3 ] [ 4 ] [ 5 ] ，水印是为了保护载体的所有权，认证是为了数据的完整性，而隐写是为了秘密信息的传输。 近年来，由于网络的迅速发展，给信息的传输带来了方便，而网络上的图像无处不在，在图像上隐藏秘密信息成了新的热门研究领域。最经典的图像信息隐藏方法之一是基于像素差的信息隐藏算法，基于像素差的信息隐藏算法 [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 10 ] 主要是考虑两个相邻像素的像素差，由于视觉系统对纹理丰富区域的像素的改变不太敏感，因此基于像素差的信息隐藏算法在纹理丰富区域嵌入的信息比平滑区域要多。 最初的基于像素差的信息隐藏算法是由Wu和Tsai [ 6 ] 于2003年提出。然而此算法使得图像的像素值的修改幅度较大，嵌入失真度较大，相对应的载密图像像素差的直方图偏离原始图像的直方图较大。为了改进基于像素差的信息隐藏算法，2008年，Wang等人 [ 7 ] 应用模函数在图像的边缘区域嵌入更多的秘密信息(MF-PVD)，不过此算法却使得像素差值直方图在零附近急剧变化，比较容易被基于直方图分析检测到。Yang等人 [ 10 ] 也于2008年提出了一种改进的边缘区域的像素差的信息隐藏算法(AE-PVD)，这种算法优于最初的PVD算法。AE-PVD选择两个像素作为一个嵌入单元，算出两个像素差的绝对值，嵌入的秘密信息比特数由像素差的绝对值决定，像素差的绝对值在嵌入前后属于相同的划分区，才能保证秘密信息的正确提取。与PVD隐藏算法相比，MF-PVD和AE-PVD嵌入相同的秘密信息时，能保持更好的图像质量。然而，AE-PVD算法采用最优像素调整算法(OPAP)嵌入秘密信息，比较容易被卡方分析检测到；另外，AE-PVD算法引起像素差直方图的异常变化，因此也难以抵抗基于像素差的直方图分析。2010年，Joo等人 [ 8 ] 改进了MF-PVD算法，能抵抗直方图的分析，不过图像的质量比AE-PVD差，不适合于特殊的应用，如军事，医用图像等。同年，Yoo等人 [ 11 ] 改进了MF-PVD算法，考虑图像的局部特征及人类视觉系统，他们首先把图像分成大小为4 × 4的像素块，然后获得每个像素块像素的高频部分，由于人类视觉对高频系数的变化不太敏感，所以在高频部分能嵌入更多的秘密信息。可是，他们也是应用OPAP算法嵌入信息，卡方分析能检测出图像中是否嵌入秘密信息。 2008年，Chang等人 [ 12 ] 提出了基于三个不同方向像素差的信息隐藏算法(TPVD)，此算法不仅提高了嵌入秘密信息的容量而且也能使嵌入信息后的图像具有很好的视觉掩蔽性。此外，Jung等人 [ 13 ] 提出用多重像素差来估计每个像素的平滑程度。Balasubramanian等人 [ 14 ] 提出了一种新的像素差信息隐藏算法，此算法考虑八个方向的像素差。Jung和Yoo [ 15 ] 提出了一种基于索引函数，利用像素差嵌入信息的算法，此算法中的索引函数提高了嵌入秘密信息的安全性，嵌入每个图像的容量也较大。然而，此算法中的索引函数要么所选择的像素块中的参考像素的位置在整个图像中是一样的，要么就得选择一定的存储空间来保存索引函数值。 虽然已经有很多关于像素差信息隐藏算法，但仍有一定的研究空间，考虑如果去提高嵌入容量，减少图像的失真。本文提出了一种基于像素差和索引函数的信息隐藏算法，改进了Jung和Yoo [ 15 ] 提出的索引函数，使得选择像素块中的参考像素更具有一定的随机性，从而嵌入信息后的图像更具有安全性。"
"把图像分成互不重叠的大小为 n × n 像素块 A t ( t = 1 , 2 , ⋯ , N ) ，其中N表示像素块的总块数。每个像素块中含有 n × n 像素 F t ( i , j ) ，其中 i , j ( 0 ≤ i , j ≤ n − 1 ) 分别表示像素 F t ( i , j ) 在像素块中所在的行与列。则索引函数定义如下： F t ( i , j ) = [ n × ( i mod n ) + ( n − 1 ) × ( j mod n ) ] mod n 2 (1) 由于本文信息隐藏算法中参考像素是由索引函数决定的，攻击者如果没有索引函数，很难知道哪个像素是参考像素，信息隐藏算法更具有安全性。确定了参考像素，然后计算其与周围像素的像素差。 例如， F t ( 0,0 ) , F t ( 0,1 ) , F t ( 1,0 ) , F t ( 1,1 ) 是 2 × 2 像素块中的四个像素，有 F t ( 0 , 0 ) = [ 2 × ( 0 mod 2 ) + ( 2 − 1 ) × ( 0 mod 2 ) ] mod 2 2 = 0 F t ( 0 , 1 ) = [ 2 × ( 0 mod 2 ) + ( 2 − 1 ) × ( 1 mod 2 ) ] mod 2 2 = 1 F t ( 1 , 0 ) = [ 2 × ( 1 mod 2 ) + ( 2 − 1 ) × ( 0 mod 2 ) ] mod 2 2 = 2 F t ( 1 , 1 ) = [ 2 × ( 1 mod 2 ) + ( 2 − 1 ) × ( 1 mod 2 ) ] mod 2 2 = 3 通过公式(1)，就能确定每个像素块中哪个像素作为参考像素。将像素值的范围[0，255]划分成7个连续子区间 W i , j ，即 W = { W i , j = [ l i , j , u i , j ] } = { [ 0 , 3 ] , [ 4 , 7 ] , [ 8 , 15 ] , [ 16 , 31 ] , [ 32 , 63 ] , [ 64 , 127 ] , [ 128 , 255 ] } (2) 每个子区间 W i , j 的上、下界、宽度分别为 l i , j , u i , j 和 w i , j 其中宽度 w i , j = u i , j − l i , j + 1 。找到像素差的绝对值 | D t ( i , j ) | 所属的子区间 W i , j ，如果 | D t ( i , j ) | ∈ [ l i , j , u i , j ] 。从二进制信息比特流截取 k t ( i , j ) = ⌊ log 2 w i , j ⌋ 位秘密信息，把 k t ( i , j ) 的二进制秘密信息比特流转换成十进制下的数 m t ( i , j ) 。  首先由索引函数选择每个子像素块中哪个像素作为参考像素，然后计算参考像素与其周围的其它像素的差，根据像素差所处的范围值确定嵌入秘密信息的长度。详细的嵌入过程如下： 1) 把图像分成互不重叠的大小为 n × n 的像素块 A t ( t = 1 , 2 , ⋯ , N ) ，其中t是表示像素块所在的位置。 2) 如果 F t ( i , j ) = t mod n 2 ，则选择 A t ( i , j ) 作为参考像素，然后根据下面的公式将参考像素值量化 B ¯ t = ⌊ B t n 2 ⌋ × n 2 (3) 3) 计算每像素块中量化后的参考像素跟其周围像素值的差 D t ( i , j ) = A t ( i , j ) − B ¯ t (4) A t ( i , j ) 表示第 t 块像素块中的像素值。 4) 若 | D t ( i , j ) | 属于 [ l i , j , u i , j ] ，则嵌入的秘密信息的比特数为 k t ( i , j ) = log 2 ( u i , j − l i , j + 1 ) 。 5) 应用余函数减少像素差的变化，降低图像的失真率。对每个像素差除以 2 k t ( i , j ) ，得到相应的余数，这样所得到的余数比原来的像素差的值要小，从而降低因嵌入秘密信息引起的图像失真率。具体计算公式如下： R t ( i , j ) = F ( D t ( i , j ) ) = D t ( i , j ) mod 2 k t ( i , j ) (5) 6) 从二进制比特流中读取 k t ( i , j ) 位秘密信息，把其转换成十进制的数 m t ( i , j ) 。例如，如果截取的二进制比特流是101，转换成十进制数为5。 7) 用秘密信息的值减去余数得新差值 H t ( i , j ) = m t ( i , j ) − R t ( i , j ) (6) 令 G t ( i , j ) = 2 k t ( i , j ) − | H t ( i , j ) | (7) 其中 m t ( i , j ) 是十进制的秘密信息值。 8) 为了嵌入信息后减少对图像的失真，应用下列的改变像素值的最佳嵌入算法： 情况1： R t ( i , j ) > m t ( i , j ) 和 | H t ( i , j ) | ≤ 2 k t ( i , j ) − 1 和 A t ( i , j ) < B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) + H t ( i , j ) ,     如 果   | D t ( i , j ) + H t ( i , j ) | ≤ 2 k t ( i , j ) + 1 − 1 A t ( i , j ) + G t ( i , j ) ,       如 果 | D t ( i , j ) + H t ( i , j ) | > 2 k t ( i , j ) + 1 − 1 (8) 情况2： R t ( i , j ) > m t ( i , j ) 和 | H t ( i , j ) | ≤ 2 k t ( i , j ) − 1 和 A t ( i , j ) ≥ B ¯ t ; A ′ t ( i , j ) = A t ( i , j ) + H t ( i , j ) (9) 情况3： R t ( i , j ) > m t ( i , j ) 和 | H t ( i , j ) | > 2 k t ( i , j ) − 1 和 A t ( i , j ) < B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) + H t ( i , j ) ,     如 果   | D t ( i , j ) + G t ( i , j ) | < 2 k t ( i , j ) A t ( i , j ) + G t ( i , j ) ,         如 果 | D t ( i , j ) + G t ( i , j ) | ≥ 2 k t ( i , j ) (10) 情况4： R t ( i , j ) > m t ( i , j ) 和 | H t ( i , j ) | > 2 k t ( i , j ) − 1 和 A t ( i , j ) ≥ B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) + G t ( i , j ) ,           如 果 | D t ( i , j ) + G t ( i , j ) | ≤ 2 k t ( i , j ) + 1 − 1 A t ( i , j ) + H t ( i , j ) ,         如 果 | D t ( i , j ) + G t ( i , j ) | > 2 k t ( i , j ) + 1 − 1 (11) 情况5： R t ( i , j ) ≤ m t ( i , j ) 和 H t ( i , j ) ≤ 2 k t ( i , j ) − 1 和 A t ( i , j ) ≤ B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) − G t ( i , j ) ,       如 果 | D t ( i , j ) + H t ( i , j ) | < 2 k t ( i , j ) A t ( i , j ) + H t ( i , j ) ,       如 果 | D t ( i , j ) + H t ( i , j ) | ≥ 2 k t ( i , j ) (12) 情况6： R t ( i , j ) ≤ m t ( i , j ) 和 H t ( i , j ) ≤ 2 k t ( i , j ) − 1 和 A t ( i , j ) > B ¯ t ; A ′ t ( i , j ) = A t ( i , j ) + H t ( i , j ) (13) 情况7： R t ( i , j ) ≤ m t ( i , j ) 和 H t ( i , j ) > 2 k t ( i , j ) − 1 和 A t ( i , j ) ≤ B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) − G t ( i , j ) ,       如 果 | D t ( i , j ) − G t ( i , j ) | ≤ 2 k t ( i , j ) + 1 − 1 A t ( i , j ) + H t ( i , j ) ,       如 果 | D t ( i , j ) − G t ( i , j ) | > 2 k t ( i , j ) + 1 − 1 (14) 情况8： R t ( i , j ) ≤ m t ( i , j ) 和 H t ( i , j ) > 2 k t ( i , j ) − 1 和 A t ( i , j ) > B ¯ t ; A ′ t ( i , j ) = { A t ( i , j ) + H t ( i , j ) ,       如 果 | D t ( i , j ) − G t ( i , j ) | < 2 k t ( i , j ) A t ( i , j ) − G t ( i , j ) ,           如 果 | D t ( i , j ) − G t ( i , j ) | ≥ 2 k t ( i , j ) (15) 9) 像素调整。少数情况下，通过上述的秘密信息嵌入，像素值 A ′ t ( i , j ) 超出像素值的范围[0，255]，即 A ′ t ( i , j ) < 0 或 A ′ t ( i , j ) > 255 。如果出现这种情况， A ′ t ( i , j ) 通过下列最优方式进行调整，寻找符合下列四个条件的像素值 A t * ( i , j ) 替换 A ′ t ( i , j ) ： a) D t * ( i , j ) 和 D t ( i , j ) 属于同一个范围，其中 | D t ( i , j ) | 和 | D t * ( i , j ) | 分别表示嵌入信息前后两像素的差， b) 0 ≤ A t * ( i , j ) ≤ 255 ； c) ( A t * ( i , j ) − A t ( i , j ) ) 2 最小； d) ( A t * ( i , j ) − B ¯ t ) mod 2 k t ( i , j ) = m t ( i , j ) 。自此，实现了在该像素上嵌入秘密信息。 10) 重步骤(2)-(9)，直到所有的秘密信息都被嵌入到图像中，得到嵌入后的载密图像。  这一小节描述提取秘密信息的详细过程。先把载密图像分成互不重叠的大小为n × n的像素块，每像素块的处理跟嵌入过程一样：按索引函数确定像素块中的参考像素，然后计算参考像素与其周围像素的差，由差值所处的范围值确实嵌入的秘密信息的比特位。详细的提取信息过程如下： 1) 把载密图像分成互不重叠大小为 n × n 的像素块 A t * ( t = 1 , 2 , ⋯ , N ) ； 2) 如果 F t * ( i , j ) = t mod n ，则选择 A t * ( i , j ) 作为参考素 B t * ，对参考像素值进行量化 B ¯ t * = ⌊ B t * n 2 ⌋ × n 2 (16) 3) 计算每像素块中参考像素量化后的值与其周围像素值的差 D t * ( i , j ) = A t * ( i , j ) − B ¯ t * (17) 其中 A t * ( i , j ) 表示第t块像素块中除参考像素外其它的像素值； 4) | D t * ( i , j ) | 属于 [ l i , j , u i , j ] ，则嵌入的秘密信息的比特数为 k t * ( i , j ) = ⌊ log 2 ( u i , j − l i , j + 1 ) ⌋ ； 5) 计算像素值差 D t * ( i , j ) 与 k t * ( i , j ) 所得的余数就是嵌入的秘密信息 m t * ( i , j ) m t * ( i , j ) = D t * ( i , j ) mod 2 k t * ( i , j ) (18) 最后，把 m t * ( i , j ) 转换成 k t * ( i , j ) 比特位的二进制信息流，于是，嵌入到载体中的秘密信息被提取了。"
"这一节我们以图1作为例子，把原始图像分成 2 × 2 的像素块。  不妨假设 t = 37 ，则由 F 37 ( 0 , 1 ) = F t ( 0 , 1 ) = t mod 2 n = 37 mod 2 2 = 1 可知，选择的参考像素是 B 37 = 97 。接着由等式(3)量化参考像素值 图1. 嵌入过程。(a) 索引函数；(b) 原始图像；(c)载密图像 B ¯ 37 = B ¯ t = ⌊ B t n 2 ⌋ × n 2 = ⌊ 97 2 2 ⌋ × 2 2 = 96 根据等式(4)，算出量化后的参考像素值与其周围像素值的差： D 37 ( 0 , 0 ) = A 37 ( 0 , 0 ) − B ¯ 37 = 60 − 96 = − 36 D 37 ( 1 , 0 ) = A 37 ( 1 , 0 ) − B ¯ 37 = 145 − 96 = 49 D 37 ( 1 , 1 ) = A 37 ( 1 , 1 ) − B ¯ 37 = 34 − 96 = − 62 所以，我们有 k 37 ( 0 , 0 ) = log 2 ( 63 − 32 + 1 ) = 5 k 37 ( 1 , 0 ) = log 2 ( 63 − 32 + 1 ) = 5 k 37 ( 1 , 1 ) = log 2 ( 63 − 32 + 1 ) = 5 然后，由式(5)可得： R 37 ( 0 , 0 ) = F ( D 37 ( 0 , 0 ) ) = D 37 ( 0 , 0 ) mod 2 5 = − 36 mod 2 5 = 28 R 37 ( 1 , 0 ) = F ( D 37 ( 1 , 0 ) ) = D 37 ( 1 , 0 ) mod 2 5 = 49 mod 2 5 = 17 R 37 ( 1 , 1 ) = F ( D 37 ( 1 , 1 ) ) = D 37 ( 1 , 1 ) mod 2 5 = − 62 mod 2 5 = 2 若秘密信息二进制比特流为 ( 11010,10011,10110 ) 2 ，把它们转换成十进制的数 m 37 ( 0 , 0 ) = ( 11010 ) 2 = 26 ,   m 37 ( 1 , 0 ) = ( 10011 ) 2 = 19 ,   m 37 ( 1 , 1 ) = ( 10110 ) 2 = 22 因此，利用等式(6)，获得像素块新的差值： H 37 ( 0 , 0 ) = m 37 ( 0 , 0 ) − R 37 ( 0 , 0 ) = 26 − 28 = − 2 H 37 ( 1 , 0 ) = m 37 ( 1 , 0 ) − R 37 ( 1 , 0 ) = 19 − 17 = 2 H 37 ( 1 , 1 ) = m 37 ( 1 , 1 ) − R 37 ( 1 , 1 ) = 22 − 2 = 20 同时由等式(7)，有 G 37 ( 0 , 0 ) = 2 k 37 ( 0 , 0 ) − | H 37 ( 0 , 0 ) | = 2 5 − | − 2 | = 30 G 37 ( 1 , 0 ) = 2 k 37 ( 1 , 0 ) − | H 37 ( 1 , 0 ) | = 2 5 − 2 = 30 G 37 ( 1 , 1 ) = 2 k 37 ( 1 , 1 ) − | H 37 ( 1 , 1 ) | = 2 5 − 20 = 12 由秘密信息嵌入过程中的第八步骤，得到像素块中新的像素值： A ′ 37 ( 0 , 0 ) = A 37 ( 0 , 0 ) + H 37 ( 0 , 0 ) = 60 − 2 = 58 A ′ 37 ( 1 , 0 ) = A 37 ( 1 , 0 ) + H 37 ( 1 , 0 ) = 145 + 2 = 147 A ′ 37 ( 1 , 1 ) = A 37 ( 1 , 1 ) + H 37 ( 1 , 1 ) = 34 + 20 = 54 因为 A ′ 37 ( 0 , 0 ) , A ′ 37 ( 1 , 0 ) 和 A ′ 37 ( 1 , 1 ) 都属于 [ 0,255 ] ，因此，我们有 A 37 * ( 0 , 0 ) = 58 , A 37 * ( 1 , 0 ) = 147 , A 37 * ( 1 , 1 ) = 54 自此，秘密信息已成功的嵌入到原始图像中。  若 t = 37 ，则我们由 F 37 * ( 0 , 1 ) = F t * ( 0 , 1 ) = t mod 2 n = 37 mod 2 2 = 1 选择参考像素值 B 37 * = 97 。首先，我们应用等式(16)量化参考像素值，得 B ¯ 37 * = B ¯ t * = ⌊ B t * n 2 ⌋ × n 2 = ⌊ 97 2 2 ⌋ × 2 2 = 96 进一步由等式(17)获得像素差： D 37 * ( 0 , 0 ) = A 37 * ( 0 , 0 ) − B ¯ 37 * = 58 − 96 = − 38 D 37 * ( 1 , 0 ) = A 37 * ( 1 , 0 ) − B ¯ 37 * = 147 − 96 = 51 D 37 * ( 1 , 1 ) = A 37 * ( 1 , 1 ) − B ¯ 37 * = 54 − 96 = − 42 因此，可得 k 37 * ( 0 , 0 ) = log 2 ( 63 − 32 + 1 ) = 5 k 37 * ( 1 , 0 ) = log 2 ( 63 − 32 + 1 ) = 5 k 37 * ( 1 , 1 ) = log 2 ( 63 − 32 + 1 ) = 5 同时，根据等式(18)，很容易可得到 m 37 * ( 0 , 0 ) = D 37 * ( 0 , 0 ) mod 2 5 = − 38 mod 2 5 = 26 m 37 * ( 1 , 0 ) = D 37 * ( 1 , 0 ) mod 2 5 = 51 mod 2 5 = 19 m 37 * ( 1 , 1 ) = D 37 * ( 1 , 1 ) mod 2 5 = − 42 mod 2 5 = 22 最后，把这些十进制的数转换成二进制的比特流， 26 = ( 11010 ) 2 , 19 = ( 10011 ) 2 , 22 = ( 10110 ) 2 。所以嵌入的秘密信息为 ( 11010 , 10011 , 10110 ) 2 。由此可知，嵌入的秘密信息能完全正确的提取出来。"
"本节将给出实验对比结果来验证改进算法的有效性。实验中用8幅大小为 512 × 512 经典灰度图像(“Lena”, “Peppers”, “Baboon”, “House”, “Boat”, “F16”, “Man”, “Elaine”)作为载体图像。图2给出了这8幅灰度图像，用伪随机数发生器生成的一串伪随机数字当作秘密信息嵌入到载体图像中。 图2给出了实验的八幅原始图像与载密图像，其中图2(a)，图2(c)，图2(e)，图2(g)，图2(i)，图2(k)，图2(m)，图2(o)是原始图像，图2(b)，图2(d)，图2(f)，图2(h)，图2(j)，图2(l)，图2(n)，图2(p)是载密图像。实验结果表明，本文所提出的算法当嵌入秘密信息后，不会影响图像的视觉效果，人的肉眼很难分辨出哪是原始图像，哪是载密图像。 图3给出了本文算法嵌入秘密信息比特数与提取的错误率之间的关系，从图中可以进一步得出，本文所提出的算法能把嵌入的秘密信息完全提取出来，即提取的错误率为零。 图2. 八幅实验图像。(a) 原始图像；(b) 载密图像；(c) 原始图像；(d) 载密图像；(e) 原始图像；(f) 载密图像；(g) 原始图像；(h) 载密图像；(i) 原始图像；(j) 载密图像；(k) 原始图像；(l) 载密图像 用峰值信噪比(Peak Signalto Noise Ratio，简称PSNR)来评估载密图像的图像质量。本文算法的实验结果由表1给出，表1中，“容量”表示的嵌入的秘密信息的比特数，“PSNR”为峰值信噪比值，“错误”为错误提取秘密信息比特数，“嵌入(秒)，提取(秒)”分别为本文所提出的算法嵌入和提取信息所需要的时间。表1概述了本文所提出的算法的实验结果。实验结果也表明，本文所提出的算法能把嵌入后的秘密信息完全提取出来，而且嵌入和提取所需要的时间很少。 图3. 提取错误率与嵌入容量。(a) Peppers; (b) Lena Table 1 原始图像 PSNR 容量 错误 嵌入(秒) 提取(秒) Baboon 30.16084 628,892 0 4.634324 2.298003 Lena 37.96220 454,247 0 4.186936 2.210031 Barbara 32.01326 544,368 0 4.448432 2.187897 Boat 35.70142 486,985 0 4.307051 2.176670 Elaine 39.75235 445,913 0 4.102364 2.242244 Goldhill 37.15423 488,198 0 4.152837 2.223915 House 34.23972 504,068 0 5.311871 2.992603 Sailboat 34.11055 525,454 0 4.562337 2.499687 Toys 37.62412 450,020 0 4.423158 2.255411 Zelda 41.06577 425,563 0 3.995963 2.020980 表1. 本文算法的实验结果 从表2可以看出，虽然本文的算法与其它两种算法相比较，载密图像的PSNR值有所下降，可嵌入容量比Wu和Tsai算法 [ 6 ] 和Wang等的算法 [ 7 ] 分别高出44,168~191,086 bits，38,507~171,787 bits。较高的嵌入容量说明本文的算法能更好的区分图像的平滑区域与边缘区域，例如纹理比较丰富的Baboon图像，嵌入容量比Wu和Tsai算法 [ 6 ] 和Wang等的算法 [ 7 ] 分别高出191,086 bits和171,787 bits。而且从嵌入的容量来看，不同的图像嵌入容量相差比较大，边缘越丰富的图像嵌入的容量就越多。说明了本算法充分考虑了图像不同的区域承受的像素差的变化不一样，充分考虑了图像的视觉效应。 从表3可以看出，Jung和Yoo的算法虽然嵌入容量比本文的算法要高，可选择了六幅不同的图像，由于没有充分考虑图像的平滑区域与边缘区域对像素变化的承受力的不同，它们的嵌入容量非常的接近。同时，Jung和Yoo的算法嵌入信息后，对图像造成了一定程度的失真，其PSNR值大部分都低于30 dB，其中最低的PSNR值只有25.96 dB。 表4是比较本文算法和Lee等的算法，Zeng等的算法的PSNR值和有效嵌入量，从表4可看出，本文的算法不仅有效嵌入量比他们的高，同时也能很好的保证载密图像的质量，即嵌入信息后造成的图像的失真程度较低。 Table 2 原始图像 容量 1 PSNR 1 容量 2 PSNR 2 容量 3 PSNR 3 Lena 406,632 41.71 409,807 46.96 454,247 37.96 Baboon 437,806 38.90 457,105 43.11 628,892 30.16 Peppers 401,982 41.07 407,643 46.10 446,150 36.14 Boat 421,965 39.56 422,194 45.34 486,985 35.70 House 420,386 39.51 420,786 44.61 504,068 34.24 Man 424,585 39.09 424,723 44.98 499,200 32.44 表2. 本文算法与其它算法的实验结果比较 *注：上标 1 ：表示Wu和Tsai的算法 [ 6 ] 实验结果，上标 2 ：表示Wang的算法 [ 7 ] 实验结果，上标 3 ：表示本文的实验结果 Table 3 原始图像 容量 1 PSNR 1 容量 2 PSNR 2 Lena 614,799 31.94 454,247 37.96 Baboon 686,220 25.96 628,892 30.16 Peppers 611,394 30.42 446,150 36.14 Boat 4,633,078 28.99 486,985 35.70 House 631,341 28.71 504,068 34.24 Man 637,266 28.63 499,200 32.44 表3. 本文算法与其它算法的实验结果比较 *注：上标 1 ：表示Yang和Yoo的算法实验结果，上标 2 ：表示本文的实验结果 Table 4 原始图像 嵌入率 1 PSNR 1 嵌入率 2 PSNR 2 嵌入率 3 PSNR 3 Lena 0.91 34.38 1.04 32.74 1.73 37.93 Baboon 0.62 30.03 0.51 30.97 2.40 30.16 Sailboat 0.86 33.12 1.04 32.96 2.00 34.11 F16 0.91 34.76 1.16 33.94 1.77 35.87 Goldhill 0.84 32.08 0.80 31.82 1.86 37.15 Barbara 0.73 31.31 0.78 31.96 2.08 32.01 表4. 本文算法与其它算法的实验结果比较 *注：上标 1 ：表示Lee和Chen的算法 [ 16 ] 实验结果, 上标 2 ：表示Wang的算法 [ 17 ] 实验结果，上标 3 ：表示本文的实验结果 表5是本文的算法与Hong [ 18 ] 提出的几种不同的划分区域的算法相比较。从表4可以看出，本文算法的平均嵌入容量分别比Hong提出的AE-PVD (D 12 = 15)，PRT-PVD (T 0 = 15)，AE-PVD (D 12 = 15，D 23 = 31)，PRT-PVD (T 0 = 15，T 1 = 15)多出196,955 bits，190,980 bits，181,891 bits，172,650 bits。如边缘比较丰富的Baboon图像，本文的算法分别比Hong提出的AE-PVD(D 12 =15)，PRT-PVD (T 0 =15)，AE-PVD (D 12 = 15，D 23 = 31)，PRT-PVD (T 0 = 15，T 1 = 15)多出261,314 bits，261,684 bits，207,509 bits，209,314 bits。即使是平滑的图像Lena，本文的算法也分别比Hong提出的AE-PVD (D 12 = 15)，PRT-PVD (T 0 = 15)，AE-PVD (D 12 = 15，D 23 = 31)，PRT-PVD (T 0 = 15，T 1 = 15)多出177,045 bits，168,797 bits，173,616 bits，161,525 bits。虽然，Hong的算法也考虑了根据像素差来决定嵌入的秘密信息的比特数，可其划分的区域 Table 5 原始图像 容量 1 PSNR 1 容量 2 PSNR 2 容量 3 PSNR 3 容量 4 PSNR 4 容量 5 PSNR 5 Lena 277,202 50.62 285,450 51.36 280,631 50.16 292,722 50.33 454,247 37.96 Boat 290,502 50.22 302,888 50.72 297,345 49.42 316,736 49.15 486,985 35.70 Baboon 367,578 48.48 367,208 49.08 421,383 45.52 419,578 45.88 628,892 30.16 House 301,418 49.93 309,790 50.52 313,329 48.73 327,412 48.68 504,068 34.24 Peppesrs 279,684 50.54 283,078 51.43 284,783 49.93 290,044 50.43 446,150 36.14 F16 285,586 50.38 289,404 51.26 294,885 49.34 301,308 49.74 463,353 35.87 平均 300,328 306,303 315,392 324,633 497,283 表5. 本文算法与其它算法的实验结果比较 *注：上标 1 ：表示AE-PVD (D 12 = 15)算法实验结果, 上标 2 ：表示PRT-PVD (T 0 = 15)实验结果，上标 3 ：表示AE-PVD (D 12 = 15；D 23 = 31)实验结果，上标 4 ：表示PRT-PVD (T 0 = 15；T 1 = 15)实验结果，上标 5 ：表示本文的实验结果 相对而言比较粗糙，不能完全真实的反应图像的区域特征。虽然本算法的PSNR值比Hong提出的几种算法低，可也能使图像的PSNR保持在30 dB上。 PSNR值是最常用来检测嵌入信息后的载体图像质量，通过PSNR值的大小，我们可很清楚的知道嵌入信息后的图像是否会被人的肉眼观测出来。然而，PSNR值不能指出嵌入信息前后两幅图像之间差别有多大。因此，应用由Wang和Bovik [ 19 ] 提出的通用质量因子Q值来检测图像在嵌入信息前后的相似度有多高，并指出Q值的范围是从−1到1。Q值越接近于1，说明嵌入信息前后的两幅图像越相似。由表6所给出的数据，可知通过本文算法进行信息隐藏，所得的Q值非常的接近1，也就是说嵌入信息前后原始图像与载密图像非常的相似。 所有的实验结果都表明，本文所提出的信息隐藏算法不仅有着很高的嵌入容量，而且也能保持很小的图像失真。由于嵌入信息后，图像失真很小，因此，即使非法者拥有了载密图像，他们也区分不了载密图像与原始图像，不知道载密图像中已经隐藏了秘密信息，也就是说本文所提出的算法能很好的隐藏信息已经嵌入到图像中去这样的事实。"
"Fridrich等人 [ 20 ] 提出的RS分析算法来分析本文所提出的信息隐藏算法的安全性。RS分析本文所提出的信息隐藏算法的结果在图4中给出，其中是以图2中的一幅图做实验。图4中的x-轴表示嵌入秘密信息容量的百分比，y-轴表示掩膜为 m = [ 0 , 1 , 1 , 0 ] 和 − m = [ 0 , − 1 , − 1 , 0 ] ，正则组与奇异组的百分比。从图4(a)和图4(c)我们可以看出RS分析能检测出图像经过了LSB信息隐藏，这是因为随着LSB嵌入率到达100%时， R m 和 S m 的差距会随着密写率的上升而下降，而 R − m 和 S − m 与原始值之间就会偏离得更远。但图4(b)和图4(d)载体图像看似不包含任何嵌入秘密信息的嵌入，这是因为在图4(b)和图4(d)中 R m 和 R − m 始终近似相等，而 S m 和 S − m 值亦如此，也就是说 R m ≅ R − m 和 S m ≅ S − m 。因此，可以肯定的说，本文所提出的信息隐藏算法抗RS分析。  Zhang和Wang [ 21 ] 指出文献 [ 22 ] 所提出的一种基于相邻像素对差异的PVD信息隐藏算法导致了像素灰度差值直方图的异常，存在安全漏洞。通过基于PVD的直方图的分析，可以检测和分析出图像中是否隐藏了秘密信息。 图4. 应用RS分析LSB嵌入信息算法与本文所提出的嵌入信息算法。(a) LSB (Baboon); (b) 本文算法(Baboon); (c) LSB (Peppers); (d) 本文算法(Peppers) Table 6 图像 Baboon Lena Barbara Boat Bridge Couple Elaine Q 0.9827 0.9978 0.9932 0.9968 0.9930 0.9926 0.9984Z 图像 Goldhill House Man Pepper Sailboat Toys elda Q 0.9974 0.9947 0.9939 0.9975 0.9971 0.9966 0.9985 表6. 本文算法的实验结果 图5给出了PVD直方图分析本文所提出的信息隐藏算法在嵌入容量最大时的原始图像与载密图像的直方图，图5(a)和图5(b)给出的是灰度图像“Baboon”和“Peppers”像素差的直方图。从图5可以看出本文所提出的基于像素差和索引函数的信息隐藏算法抗PVD直方图分析，也就是说可以完好隐藏嵌入的秘密信息。 图5. 由原始图像和载密图像得到的灰度差值直方图。(a) F16; (b) House"
"本文提出了一种基于像素差和索引函数的信息隐藏算法，首先把原始图像分成互不重叠的像素块，然后根据索引函数确定每个像素块中的参考像素。由参考像素跟它周围的其它像素的差来决定嵌入的信息的比特数。本文所提出的索引函数改进了Jung等人提出的索引函数，Jung等人提出的索引函数，要么就是所有的像素块中做为参考像素的位置是一样的，要么就得有一定的存储空间来保存索引值，而本文所提出的索引函数具有更好的随机性，即使非法截者获得了载密图像，如果他们没有索引函数也不能正确的提出秘密信息，因此索引函数起到了一种密钥的作用。实验表明，本文提出的算法有较高的嵌入容量和保持好的图像质量。"
