"本文研究具有与任务和位置有关的可控处理时间的凸资源单机排序问题。任务的实际加工时间是所获得的资源量、与任务所在位置有关负荷的函数。考虑两个问题。第一个问题是在资源总量有上界限制条件下，确定任务排序、资源分配方案，使得时间表长最小。第二个问题中资源总量没有限制，目标是求出最小资源总量、任务排序和资源分配方案，使得由时间表长和资源总量加权和取最小值。分别证明了上述问题可以在多项式时间内求出最优解，并给出了求解相应问题的多项式时间最优算法。 关键词 :排序，位置负荷，时间表长，资源分配 Copyright © 2019 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"排序问题是一类重要的组合最优化问题，在运筹学、计算机科学、管理科学与工业生产等领域中有广泛的应用。在经典排序模型中，工件(任务)的加工时间是固定的，是与加工位置和资源分配无关的常数。不过在实际生产过程中，工件的加工时间可能会在分配给工件一定的资源(如人力，电力，催化剂等)后相应缩短，或者由于操作人员经过多次重复加工而提高了技术后，工作效率提高，加工时间缩短。这一现象称为学习效应。相反的，由于机器在加工大量任务后速度变低，一个任务排在后边加工时间变长。这是所谓的退货效应。总之，这时任务加工时间除了与任务本身有关，还与所处位置有关。这类排序问题在工业生产加工等实际环境中有广泛应用，近年来受到了广泛研究。文 [ 1 ] 研究具有学习效应和资源分配的工期指派单机排序问题；文 [ 2 ] [ 3 ] 分别在公共流和公共窗口假设下研究具有学习效应和资源分配的单机工期窗口指派排序问题；文 [ 4 ] 在可控加工时间条件下研究具有退化效应的单机排序问题。分别给出了多项式时间的最优算法。 具有资源分配的排序问题近年来得到了高度的重视。一般资源消费函数有两种：线性资源消费函数和凸资源消费函数。后者能够很好地反映边际效益递减这一广泛存在的经济现象，因而受到学者的重视，有关的研究论文十分丰富。其中文 [ 5 ] 比较全面地介绍了关于可控处理时间的研究论文，包括近期的绝大多数研究成果。 本文研究具有与任务和位置有关的可控处理时间的凸资源单机排序问题。假定任务的实际加工时间是所获得的资源量、与任务位置有关的负荷的函数。主要考虑两个问题。第一个问题是在资源总量有上界的条件下，确定任务排序、资源分配方案，使得时间表长最小。第二个问题中资源总量没有限制，目标是求出最小资源总量、任务排序和资源分配方案，使得由时间表长和资源总量加权和取最小值。证明了上述问题都可以在多项式时间内求出最优解，并分别给出了求解相应问题的多项式时间最优算法。"
"设有n个独立的任务(工件) J = { J 1 , J 2 , ⋯ , J n } 需要在一台机器上加工，所有任务在零时刻都已到达。机器在同一时刻最多只能加工一个工件，工件加工不允许中断。用 p j r ( u j ) 表示任务 J j 排在位置r时的实际加工时间，它是资源消耗量 u j 的凸函数 p j r ( u j ) = ( w j r / u j ) k   ,   u j > 0 ,   j ,   r = 1 , 2 , ⋯ , n 其中 w j r 为工件 J j 的负荷， u j 是分配给工件 J j 的资源量，k是正常数。定义 π = ( J 1 , J 2 , ⋯ , J n ) 为在一个资源分配 u = ( u 1 , u 2 , ⋯ , u n ) 下所确定的工件排序， C j = C j ( π ) 表示 J j 的完工时间， C max = max { C j | j = 1 , ⋯ , n } 表示时间表长。 本文研究的第一个问题是在资源总量有上界限制，即 ∑ j = 1 n u j ≤ U 的前提下，决定最优资源分配方案 u = ( u 1 , u 2 , ⋯ , u n ) 及最优排序 π ，使得时间表长 Z 1 = Z 1 ( π , u ) = C max ( π , u ) 最小，其中 U > 0 是可使用资源总量的上限。用三参数表示法 [ 6 ] 表示如下 1 | p j r ( u j ) = ( w j r / u j ) k , ∑ j = 1 n u j ≤ U | Z 1 (1) 在研究的第二个问题中资源总量U没有限制，目标是求出最小资源总量U、任务排序和资源分配方案，使得由时间表长和资源总量确定的目标函数 Z 2 = Z 2 ( π , u ) = α C max ( π , u ) + β U 取最小，其中 α ,   β 是已知正常数。用三参数表示法表示如下 1 | p j r ( u j ) = ( w j r u j ) k | Z 2 (2)"
"下述几个重要结论给出了最优解所具有的性质，它们对于得到最优算法是必不可少的。首先，由于 C max ( π , u ) 是完工时间 C j 的非减函数，从而引理1的结论是显然的。 引理1 存在最优排序，其中首个任务开始加工时间为0，且两个相邻任务之间无空余时间。 引入 0 − 1 变量 { x j r : j , r = 1 , 2 , ⋯ , n } ， x j r = 1 ，如果工件 J j 排在位置r上； x j r = 0 ，如果工件 J j 没有排在位置r上。给定 { x j r : j , r = 1 , 2 , ⋯ , n } 后，任务的排序 π 就随之确定了。于是有 Z 1 ( π , u ) = C max ( π , u ) = ∑ r = 1 n ∑ j = 1 n p j r ( u j ) x j r = ∑ r = 1 n ∑ j = 1 n ( w j r / u j ) k x j r (3) 引理2 对于固定的 { x j r : j , r = 1 , 2 , ⋯ , n } ，最优资源分配方案 u * = ( u 1 * , u 2 * , ⋯ , u n * ) 由下式给出 u j ∗ = ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) ∑ j = 1 n ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) U ,     j = 1 , 2 , ⋯ , n (4) 证明 由于(3)式给出的目标函数是关于 u j 的凸函数，并且约束函数 g ( u ) = ∑ j = 1 n u j − U 也是关于 u j 的凸函数，利用凸规划理论，可知最优资源 u 必使 ∑ j = 1 n u j = U ，从而可使用拉格朗日乘子法求解。对于任意给定排序 π ，拉格朗日函数为 L ( u , λ ) = ∑ r = 1 n ∑ j = 1 n ( w j r / u j ) k x j r + λ { ∑ j = 1 n u j − U } (5) 其中 λ 为拉格朗日乘子。对(5)式中的所有变量分别求偏导，并令其为零，得到最优资源 u 满足的充分必要条件 ∂ L ( u , λ ) / ∂ λ = ∑ j = 1 n u j − U = 0 (6) ∂ L ( u , λ ) / ∂ u j = ∂ C max ( u , λ ) / ∂ u j + λ = 0 ,   j = 1 , 2 , ⋯ , n (7) 由(7)可得 ∂ C max ( u , λ ) / ∂ u j = ∂ C max ( u , λ ) / ∂ u 1 ,   j = 2 , 3 , ⋯ , n 由此得到 u j = u 1 ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) ( ∑ r = 1 n w 1 r k x 1 r ) 1 / ( k + 1 ) ,   j = 2 , ⋯ , n (8) 将(8)带入(6)，得 u 1 = ( ∑ r = 1 n w 1 r k x 1 r ) 1 / ( k + 1 ) ∑ j = 1 n ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) U ,   j = 2 , ⋯ , n (9) 将(9)带入(8)可得(4)。定理证毕。 现在将(4)带入(3)中 Z 1 的表达式，得 Z 1 = U − k ( ∑ j = 1 n ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) ) k + 1 (10) 注意到 U > 0 ,   k > 0 都是已知常数，于是上述问题等价于最小化下述函数 f = ∑ j = 1 n ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) = ∑ j = 1 n ( ∑ r = 1 n w j r k / ( k + 1 ) x j r ) 其中最后一个等号是利用 { x j r : j , r = 1 , 2 , ⋯ , n } 的性质得到的。于是问题(1)可以转化为下述的指派问题： { Min     ∑ j = 1 n ∑ r = 1 n w j r k / ( k + 1 ) x j r                                           ( 11 ) s .t .   { ∑ r = 1 n x j r = 1 ,   j = 1 , ⋯ , n ∑ j = 1 n x j r = 1 ,     r = 1 , 2 , ⋯ , n ;                                   ( 12 ) x j r ∈ { 1 , 0 } ,   j ,   r = 1 , 2 , ⋯ , n 因此，对于问题(1)，可以给出如下最优算法。 算法1 第1步 解指派问题(11)~(12)求出最优排序 π * ； 第2步 根据(4)，求出排序 π * 下的最优资源分配 u * = ( u 1 * , u 2 * , ⋯ , u n * ) ； 第3步 由(10)式，确定最优目标函数值 Z 1 = U − k ( ∑ j = 1 n ( ∑ r = 1 n w j r k x j r ) 1 / ( k + 1 ) ) k + 1 。 定理1 对于问题(1)，利用算法1可以通过求解指派问题在 O ( n 3 ) 时间内求得最优解。 证明 上面的分析保证了定理1结论的正确性。第一步可在 O ( n 3 ) 时间内完成，第二步可在 O ( n ) 时间内完成，第三步需要 O ( 1 ) 时间，因此算法总的时间复杂性为 O ( n 3 ) 。定理证毕。"
"本节中目标是在资源总量不受限制的前提下，确定最优资源总量U及其分配方案 u = ( u 1 , u 2 , ⋯ , u n ) 、最优排序 π ，使得时间表长和总资源消耗量组成的目标函数 Z 2 ( π , u ) 取最小值。 类似于上一节的推导，我们有 Z 2 ( π , u ) = α C max ( π , u ) + β U = α U − k B k + 1 + β U (13) 其中 B = ∑ j = 1 n ( ∑ r = 1 n w j r k / ( k + 1 ) x j r ) 与U无关。因此有 引理3 对于固定的 { x j r : j , r = 1 , 2 , ⋯ , n } ，最优资源总量U由下式给出 U * = B ( k α / β ) 1 / ( k + 1 ) (14) 证明 由于对 U > 0 无约束，故U满足 ∂ Z 2 ( π , u ) / ∂ U = β − k α B k + 1 / U k + 1 = 0 ,   ∂ 2 Z 2 ( π , u ) / ∂ U 2 = α k ( k + 1 ) B ( k + 1 ) U − ( k + 2 ) > 0 由此可得(14)。引理证毕。 将(14)带入(13)中目标的函数 Z 2 ，可得 Z 2 ∗ = [ ( β α 1 / k / k ) k / ( k + 1 ) + ( k α β k ) 1 / ( k + 1 ) ] B = L B 其中 L = ( β α 1 / k / k ) k / ( k + 1 ) + ( k α β k ) 1 / ( k + 1 ) > 0 。注意到L是已知常数，因此，对于问题(2)，可以给出如下最优算法。 算法2 第1步 解指派问题(11)~(12)求出最优排序 π * ； 第2步 根据(14)，求出排序 π * 下的最优资源总量 U * ； 第3步 根据(4)，求出排序 π * 下的最优资源分配 u * = ( u 1 * , u 2 * , ⋯ , u n * ) 。 定理2 利用算法2可以通过求解指派问题在 O ( n 3 ) 时间内求得问题(2)的最优解。 证明 上面的分析保证了定理2结论的正确性。因为求解指派问题(11)~(12)需要 O ( n 3 ) 时间，第2步可在 O ( 1 ) 时间内完成，第3步需要 O ( n ) 时间，于是求解问题(2)的时间复杂度为 O ( n 3 ) 。定理证毕。"
