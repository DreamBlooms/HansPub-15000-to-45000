"点覆盖问题为组合优化中一个经典的NP完全问题。目前，该问题在有效的多项式时间内无法找到最优解。文章针对蚁群算法可能出现的早期停滞问题进行改进，通过对信息素浓度进行限定，信息素浓度不会在好的顶点继续加强，也不会忽略掉潜在的一些搜索区域。该算法有效地避免了局部最优，提高了算法的准确度，得到时间复杂性为 0 [ ( n − 1 ) 2 ⋅ n ] 的解决方案。 关键词 :点覆盖，蚁群算法，信息素更新，时间复杂性 Copyright © 2019 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"点覆盖是指给定一个无向图 ，其中V为顶点集，若存在 V ( G ) 的一个子集S，使得G中任意一条边的两个端点至少有一个在S中，则S为G的点覆盖集。若图G中不存在点覆盖 S ′ ，使 | S ′ | < | S | ，则称S为G的一个最小点覆盖集，其中 | S | 和 | S ′ | 即集合S和 S ′ 的顶点个数 [ 1 ] 。 在运筹学和管理科学领域，点覆盖问题也是NP-hard最常用的问题之一 [ 2 ] 。在现实生活中有许多的问题都可以利用最小点覆盖问题原理进行解决。对该问题研究虽然已经有很长时间，但是人们至今没有找到一个多项式算法可以求得其精确解 [ 3 ] 。Niedermeier等 [ 4 ] 提出当每个点的权值最小为1，n个点总权值最多为k时，可以找到时间复杂度为 O ( 1.3788 k + k n ) 的解决方案。Chvatal等 [ 5 ] 运用贪婪启发式算法，选取顶点权值与度之比最小的点解决集合覆盖问题。1993年参数化算法第一次用来解决该问题 [ 6 ] 。寇磊等 [ 7 ] 运用改进的Dijkstra算法解决该问题，并且得出该近似算法的时间复杂度为 O ( n 3 ) 。王丽丽等通过线性规划松弛来实现对每个实例中参数k范围的预测，介绍了一种求解该问题实例计算成本的方法 [ 8 ] 。骆伟忠等将启发式操作和核心化操作相融合，给出了基于核心化技术的点覆盖问题的改进算法 [ 9 ] 。郝斌斌等人研究了一种基于该问题的共享单车投放点选取问题 [ 10 ] 。目前对于蚁群算法的研究已经不再仅仅局限于单一的范围中，近年来往往利用遗传算法结合贪婪启发式算法和基于重力的转启发式算法研究最小点覆盖问题并得到近似解。 1992年意大利学者Dorigo等人提出了蚁群算法 [ 11 ] 。2000年在国际顶级期刊《Nature》上发表了关于蚁群算法系统的研究综述，首次将蚁群算法推向国际领域，人们开始对蚁群算法进行广泛地研究和应用 [ 12 ] 。吴佩雯等人对蚁群算法解决点覆盖问题给出了简单的近似算法 [ 13 ] 。葛洪伟等人将SCHF启发函数与蚁群算法相结合得到了一个新的算法对集合问题进行求解 [ 14 ] 。 目前蚁群算法研究点覆盖问题还不完善，蚁群算法虽然具有系统性、分布式计算、自组织、正反馈等优势，但是当处理数据量巨大时其会出现求解时间长或者得不到最优解，而且蚂蚁在循环中可能会出现早期停滞问题导致算法陷入局部最优。因此为了避免上述问题的出现，引入信息素浓度限定这一概念，对信息素浓度进行限定，提出了一种改进的蚁群算法。当每个点的权值最小为1时，得到时间复杂性为 0 [ ( n − 1 ) 2 ⋅ n ] 的解决方案，其中n为图G的顶点数。"
"蚁群算法的灵感来源于现实生活中真正蚂蚁的自然优化机制，它是一种启发式算法。蚂蚁依靠相互协作可以在洞穴和食物源之间找到一条最短路径 [ 15 ] 。探究发现这是由于蚂蚁在通过一条路时会留下一种信息素，当其它蚂蚁选择路径时，会依靠信息素浓度判断并找出一条最短路径 [ 16 ] 。 设m为蚂蚁的数目， b i ( t ) 表示t时刻在节点i的蚂蚁数目， m = ∑ i = 1 n b i ( t ) τ i j ( t ) 为某时刻t在路段 ( i , j ) 上的信息素，信息素轨迹和参数初始化， τ i j ( t 0 ) = C ，(C为常数)，为使算法初期各个蚂蚁更好获得较好的解，将信息素大小设置为 τ max 。 η i j 表示路段 ( i , j ) 上的能见度。 计算状态转移规则，将初始节点i置于蚂蚁 k ( k = 1 , 2 , ⋯ , m ) 的解集 C k 中，蚂蚁k按状态转移规则选择下一节点j，并将j放入当前解集 C k 中。 p i j k ( t ) = { [ τ i j ( t ) ] α [ η i k ( t ) ] β ∑ s ∈ a l l o w e d k [ τ i s ( t ) ] α [ η i s ( t ) ] β ,       若   j ∈ a l l o w e d k 0 ,                                                                                       否 则 (1) 在公式(1)中 a l l o w e d k = { 0 , 1 , 2 , ⋯ , n − 1 } 为允许访问下一节点的集合。 α , β 为参数因子，由ant-cycle模型得出的最好的经验结果为 0 ≪ α ≪ 5 ， 0 ≪ β ≪ 5 。 在每只蚂蚁走完一步或者完成一次环游，记录最好解 ，并进行信息素更新。 τ i j ( t + 1 ) = ρ τ i j ( t ) + Δ τ i j b e s t (2) Δ τ i j b e s t = { 1 / L b e s t ,       若 i , j 为 最 优 路 径 0 ,                             否 则 (3) 式(3)中 ρ 为信息素的挥发系数，一般 0 < ρ < 1 。当达到最大迭代次数或者找寻到最优路径，则算法停止，输出全局最优解。"
"根据最小点覆盖的特点，蚂蚁在搜索过程中是可以从一个点转移到其他任一顶点的，故作图G的完全图 G C = ( V , E C ) ，如果一个边是G中的边那么它的权值是1，如果它未出现在原来的图G中，那么它的权值为0。 定义 G c k = ( V , E C ) 为k个顶点加入解集后的图，定义 Ψ k ( i , j ) = V a l u e ( E c k ( i , j ) ) 。 定义动态启发函数 η j k = ∑ ( i , j ) ∈ E c Ψ k ( i , j ) ω ( j ) (4) 在式(4)中， ω ( j ) 指顶点j的权值，用启发函数 η j k 定义状态转移概率方程 p j k = { 1 , q < q 0 , j = max i ∈ A k τ i η i k β 0 , q < q 0 , j ≠ max i ∈ A k τ i η i k β τ j η j k β ∑ γ ∈ A k τ i η i k β , q ≥ q 0 (5) 在式(5)中， q 0 是标准参数且q是一个随机变量，它决定每一步选择的类型。 A k 是可用的顶点的列表。不同于TSP的状态转移规则，它并不取决于最后一个被选择的点，这就是为什么用 τ i 来代替 τ i j 。对一个完全指定的蚂蚁群系统全球(当蚂蚁完成它们的所有路径时)，信息素更新为 τ i ( t + 1 ) = ρ τ i ( t ) + Δ τ i b e s t (6) Δ τ i j b e s t = 1 / L b e s t (7) 在式(7)中的 L b e s t 为当前迭代最优解。每条路径上的信息素 τ i ( t ) 都限于 [ τ min , τ max ] 范围中。每次迭代之后都应将信息素限定在该范围内。若 τ i ( t ) ≥ τ max ，则 τ i ( t ) = τ max ；若 τ i ( t ) ≤ τ min ，则 τ i ( t ) = τ min ，与此同时要保证 τ min > 0 。 局部信息素更新的主要目的是为了减少算法陷入局部最优的状态，同时增加短路径上的信息素浓度。在每一步结束时执行局部信息素的更新，更新规则为 τ i = ( 1 − φ ) τ i + φ τ 0 (8) 式(8)中， 的值是指被选择的点的度数与权值之间的最佳比。参数 φ 是被指定的特殊的局部更新规则的值。"
"对点赋权图 G = ( V , E ) ，做出图G的完全图 G C = ( V , E C ) 。 首先，定义连接函数 Ψ k ( i , j ) = { 1 ,         i , j ∈ E 0 ,         i , j ∈ E C − E (9) 由此函数即可确定各边的连接值。对于蚂蚁k，当蚂蚁k访问到i点，则 Ψ k ( i , j ) = 0 ，其中j表示所有与i相邻的顶点。 然后计算动态启发因子 η j k = ∑ ( i , j ) ∈ E c Ψ k ( i , j ) ω ( j ) (10) 其中 ω ( j ) 为j点的权值， ∑ ( i , j ) ∈ E c Ψ k ( i , j ) 表示顶点j所关联的所有的边的连接值之和。因此可求出 max { η j k β } 。 由此给出蚂蚁k接下来访问新的顶点的状态转移概率 P j k = { 1 ,       j = max { η j k β } 0 ,     j ≠ max { η j k β } (11) 对于图G，当所有的连接值均为0时，算法停止。当蚂蚁完成环游，对于所有点i，有 ∑ ( i , j ) ∈ E c Ψ k ( i , j ) = 0 ，此时可得到一个点覆盖集 S k 。更新初始点，得到n个新的点覆盖集，计算 min j ∈ S k ω ( j ) ，则得到图的最小点覆盖集。 算法实现步骤 Step1. 初始化：做出图G的完全图 G C = ( V , E C ) ，由连接函数 Ψ k ( i , j ) = { 1 ,         i , j ∈ E 0 ,         i , j ∈ E C − E 给定的各边连接值，令 S k = { v i } ， k = 1 ； Step2. 用连接函数 Ψ k ( i , j ) = 0 更新与i点相关联的所有边的连接值，计算 η j k = ∑ ( i , j ) ∈ E c Ψ k ( i , j ) ω (j) 若有 η j k = 0 则输出点覆盖，算法停止。否则，转Step3； Step3. 计算 max { η j k β } ，由 P j k = { 1 ,           j = max { η j k β } 0 ,       j ≠ max { η j k β } 确定下一个选择的顶点，并将其并入集合 S k ，转Step2； Step4. 计算 | S k | = min j ∈ S 1 ω ( j ) ，更新初始点，转Step2； Step5. 计算 S = min { S 1 , S 2 , ⋯ , S k , ⋯ , S n } ，输出最小点覆盖集S，算法停止。由此得出算法的时间复杂度为 0 [ ( n − 1 ) 2 ⋅ m ] ，其中n为图G的顶点数，m为蚂蚁数目，若 m ≈ n ，则蚁群算法的时间复杂度为 0 [ ( n − 1 ) 2 ⋅ n ] 。"
"求图1的点覆盖来阐释算法的具体执行过程，其中图G是8个顶点，12条边的点赋权图且图2中的图 G C 是图G的完全图。 图1. 图G 图2. 图G C Step1. 由连接函数 Ψ k ( i , j ) = { 1 ,           i , j ∈ E 0 ,       i , j ∈ E C − E 给定的各边连接值，蚂蚁1以 v 1 为出发点，有 S 1 = { v 1 } ，期望启发因子 β 赋值为2； Step2. 用连接函数 Ψ k ( i , j ) = 0 更新与点 v 1 关联边的连接值，计算 η j k β 有 η j k β ≠ 0 ，转Step3； Step3. 计算 max { η j k β } = 12.25 , j = 7 ，将其并入集合 S 1 = { v 1 , v 7 } ，转Step2； Step2. 用 Ψ k ( i , j ) = 0 更新 v 7 关联边的连接值，计算 η j k β ，有 η j k β ≠ 0 ，转Step3； Step3. 计算 max { η j k β } = 16 / 9 , j = 3 ，将其并入集合 S 1 = { v 1 , v 7 , v 3 } ，转Step2； Step2. 用连接函数 Ψ k ( i , j ) = 0 更新与点 v 3 关联的边的连接值，计算 η j k β ，有 η j k β ≠ 0 ，转Step3；Step3.计算 max { η j k β } = 4 / 9 , j = 5 ，将其并入集合 S 1 = { v 1 , v 7 , v 3 , v 5 } ，转Step2； Step2. 用连接函数 Ψ k ( i , j ) = 0 更新与点 v 5 关联的边的连接值，计算 η j k β ，有 η j k β = 0 ，输出 S 1 = { v 1 , v 2 , v 3 } ； Step4. 计算 | S k | = min j ∈ S 1 ω ( j ) = 10 ，算法停止； Step5. 计算 S = min { S 1 , S 2 , ⋯ , S k , ⋯ , S n } 得 S = min { v 1 , v 3 , v 5 , v 7 } ，输出最小点覆盖集 S = { v 1 , v 3 , v 5 , v 7 } ，算法停止。 比较表1中点覆盖的点覆盖数和权值，集合 { v 1 , v 3 , v 5 , v 7 } 的点覆盖数和权值最小，点覆盖数为4，点覆盖权值为10。该算法点覆盖数和权值没有出现局部最优。 Table 1蚂蚁 初始点 点覆盖 点覆盖数 点覆盖权值 1 v 1 S 1 = { v 1 , v 3 , v 5 , v 7 } 4 10 2 v 2 S 2 = { v 1 , v 2 , v 3 , v 5 , v 7 } 5 14 3 v 3 S 3 = { v 1 , v 3 , v 5 , v 7 } 4 10 4 v 4 S 4 = { v 1 , v 3 , v 4 , v 5 , v 7 } 5 15 5 v 5 S 5 = { v 1 , v 3 , v 5 , v 7 } 4 10 6 v 6 S 6 = { v 1 , v 3 , v 5 , v 6 , v 7 } 5 16 7 v 7 S 7 = { v 1 , v 3 , v 5 , v 7 } 4 10 8 v 8 S 8 = { v 1 , v 3 , v 5 , v 7 , v 8 } 5 14 表1. 图G各顶点的点覆盖数及点覆盖值 为使该算例更具代表性，选取 n = | V | = 3 r + 4 ，图3中最优覆盖有r + 2个点，为 { B 1 , B 2 , ⋯ , B r + 2 } ，用20只蚂蚁对该实例求解，计算结果见表2。 从表2中可知当图规模较小时，蚁群算法的早期停滞问题并没有出现。然而，随着图的复杂程度增加、点数的增多和r的增大，蚁群算法在计算过程中出现了停滞现象，所得结果是存在局部最优现象的。对信息素浓度的限定，有效的避免了该现象的出现，所得结果更加接近最优结果，计算精度方面得到了一定的提升。 图3. 算例 Table 2 r n 最优点覆盖数 近似算法点覆盖数 15 49 17 18 20 64 22 23 25 79 27 30 30 99 32 35 35 109 37 41 表2. 计算结果"
"蚁群算法相较各种成熟的智能计算方法，仍在实验探索阶段，但从当前的应用效果来看这种新型系统寻优思想对解决一些实际问题表现突出，解决赋权图点覆盖问题是可行的。 本文主要对蚂蚁选择下一顶点的状态转移概率进行改进，同时对信息素浓度进行限定，设置了最大值与最小值，这样可以使信息素浓度不会在好的顶点上继续加强也不会忽略掉一些潜在的搜索区域，使得解决点覆盖问题的精确度更高，运行效率更快。通过实例计算表明该近似算法提高了准确性，所得解更加趋近于最优解。"
