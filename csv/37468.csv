"本文首先将多标签分类问题分解为一系列单标签二分类子问题，每一个子问题对应一个标签。子问题的正类定义为具有该标签的样本，负类定义为不具有该标签的样本。在给定的属性子集下，计算出正负类样本之间的最小距离，即分类边界的最小距离。将子问题分类边界最小距离求和定义为依赖度函数，并将此依赖度函数作为属性子集重要度评价指标。然后建立了所提出依赖度函数关于属性子集的单调性，并通过最大化依赖度函数给出了属性约简的定义。最后，设计了一种基于正负类边界距离的属性约简算法，并在实际的多标签数据集上进行了实验，实验结果表明，所提约简算法能够建立合理的属性重要度排序，有效地去除冗余属性。"
"近年来，在数据挖掘和机器学习领域中，多标签分类问题引起了广泛的关注。多标签分类和单标签分类的区别就是单标签分类中的样本只能与一个标签相关联，而多标签分类中的样本可能同时与多个类别标签相关联 [ 1 ] [ 2 ] [ 3 ]。 在多标签数据中，有些属性可能是冗余的或与分类任务不相关的，冗余或不相关的属性会导致多标签分类器的分类性能较差。因此，在设计分类器前，需要减少冗余或不相关的属性 [ 4 ]。属性约简就是在分类能力不变的前提下，删除其中冗余或不相关的属性，选择一个最优属性子集来提高分类器的分类性能，保留了数据集最有用的信息，使分类模型简洁，具有更好的泛化能力 [ 5 ] [ 6 ] [ 7 ]。 属性约简是多标签分类重要的数据预处理过程，其目的是减少数据的维数，来提高数据处理速度 [ 8 ]。2018年，Lin等人提出了一种新的模糊粗糙集模型，采用局部采样技术构造样本间的鲁棒距离，并建立了一种适用于多标签学习的属性约简算法 [ 9 ]。2019年，Wang等人提出了一种基于信息论的多标签学习特征选择算法，他先定义了多标签信息熵和多标签互信息的新概念，然后，建立了一种缺失标签的多标签特征选择方法 [ 10 ]。2020年，Liu等人通过设计类间判别和类内邻域识别来选择每个新到达的标签特征，提出了一种在流标签环境下的多标签特征选择方法 [ 11 ]。 现有的属性约简算法，计算复杂度较高，而样本间距离运算简单，直观，所以我们在这篇论文中利用样本间距离，定义依赖度函数，使模型更加简洁，运算速度更快。我们首先将多标签分类问题转化为二分类问题，并介绍了正负类样本集，然后，求出正负类样本间距离，从而定义了依赖度函数。通过正负类样本间距离函数，证明了依赖度函数相对于属性子集是单调递增的。接着给出了属性约简定义，最后，设计了一种基于正负类边界距离的属性约简算法，来选择最优的多标签属性子集。为了验证该方法的性能，我们将其与现有的四种多标签特征选择算法进行了比较。实验结果表明，该方法能够有效地去除冗余属性。 论文的其余部分结构如下。在第一节中，回顾了多标签分类的基础知识、点到点的距离、集到集的距离和点到集的距离的定义。在第二节中，我们给出了属性约简的定义，设计了一种基于正负类边界距离的属性约简算法。在第三节中，汇报了我们的算法在9个多标签数据集上实验的结果。在第四节中，对本文所得结论和实验结果进行总结，并提出了今后要研究的问题。"
"多标签数据表示为 S = ( U , A , L ) ，其中样本集 U = { x 1 , x 2 , ⋯ , x n } 是一个非空有限集，表示有n个样本实例。属性集 A = { a 1 , a 2 , ⋯ , a p } 是一个非空有限集，每个属性 a ∈ A 是从样本集U到实数集的函数，其中 a ( x ) 表示为样本 x ∈ U 在属性a上的值。标签集 L = { l 1 , l 2 , ⋯ , l q } 是一个非空有限集，表示有q个标签。每个标签 l ∈ L 被定义为从样本集U到集合 { 0,1 } 的函数。假设样本x与标签l相关联，则 l ( x ) = 1 ；否则， l ( x ) = 0 。 对于任意非空属性子集 B ⊆ A ，假设样本点x和点y都是样本集U中的点，则点x和点y之间的距离定义为 d B ( x , y ) = ∑ a ∈ B | a ( x ) − a ( y ) | . 对于每个非空属性子集 B ⊆ A ，设集合X和集合Y是样本集U的子集，则集合X和集合Y之间的距离定义为 d B ( X , Y ) = min x ∈ X , y ∈ Y d B ( x , y ) . 当集合X是单点集 { x } 时，点x和点集Y之间的距离为 d B ( x , Y ) = min y ∈ Y d B ( x , y ) . 任意两个非空集X和Y都有 d B ( X , Y ) ≥ 0 。"
"在给定标签 l i ∈ L 的情况下，关于 l i 的一对样本集被定义为 E i = { x ∈ U : l i ( x ) = 1 } , i = 1 , ⋯ , q . F i = { x ∈ U : l i ( x ) = 0 } , i = 1 , ⋯ , q . 样本集 E i 是有该标签的样本集合，样本集 F i 是没有该标签的样本集合， E i 是正类样本集， F i 是负类样本集。每个标签具有一对样本集 E i 和 F i 。对于给定的属性子集 B ⊂ A ，下面的函数 d B ( E i , F i ) 可以测量正类样本集 E i 和负类样本集 F i 之间的距离，函数定义为 这个距离函数 d B ( E i , F i ) 测量了正类样本集 E i 和负类样本集 F i 的边界距离，函数值越大，分类器的分类能力越好。也就是说，标签相同的样本距离越近越好，标签不同的样本距离越远越好。 定义1：对于任意非空属性子集 B ⊆ A ，我们将每个标签的正负类样本间距离求和定义为依赖度函数，依赖函数为 γ ( B ) = ∑ i = 1 q d B ( E i , F i ) 依赖度函数 γ ( B ) 用于评估属性子集的重要性，依赖度函数值的大小取决于正负类样本间距离函数 d B ( E i , F i ) 值的大小。 引理1：对于多标签数据 S = ( U , A , L ) ，距离函数 d B ( E i , F i ) 和依赖度函数 γ ( B ) 相对于属性集B是单调递增的。任意选择两个属性子集 B 1 和 B 2 ，有 B 1 ⊂ B 2 ⊂ A ，则存在 d B 1 ( E i , F i ) < d B 2 ( E i , F i ) ， γ ( B 1 ) ≤ γ ( B 2 ) 。 证明：由距离的定义，对于任意 B 1 ⊂ B 2 ，有 d B 1 ( x , y ) = ∑ a ∈ B 1 | a ( x ) − a ( y ) | ≤ ∑ a ∈ B 2 | a ( x ) − a ( y ) | = d B 2 ( x , y ) 根据集合到集合间距离的定义有 d B 1 ( E i , F i ) = min x ∈ E i , y ∈ F i d B 1 ( x , y ) ≤ d B 1 ( x , y ) d B 2 ( E i , F i ) = min x ∈ E i , y ∈ F i d B 2 ( x , y ) ≤ d B 2 ( x , y ) 因此 d B 2 ( E i , F i ) − d B 1 ( E i − F i ) > 0 d B 1 ( E i , F i ) < d B 2 ( E i , F i ) 另外，根据定义1有 γ ( B 1 ) = ∑ i = 1 q d B 1 ( E i , F i ) γ ( B 2 ) = ∑ i = 1 q d B 2 ( E i , F i ) 得到 ∑ i = 1 q d B 2 ( E i , F i ) − ∑ i = 1 q d B 1 ( E i , F i ) ≥ 0 因此 γ ( B 1 ) ≤ γ ( B 2 ) 引理得证。 从引理1看出，随着属性数目的增加，样本间距离函数值越大，依赖度函数值也越大。这意味着在属性子集中添加新属性从而提高了分类器的分类能力。现在，我们通过最大化依赖度函数给出属性约简的定义。 定义2：对于多标签数据 S = ( U , A , L ) ，如果属性子集 B ⊆ A 满足以下条件，则称集合B是A的依赖约简： 1) γ ( B ) = γ ( A ) ； 2) 对于任意的 B ′ ⊂ B ， 。 我们可以看到约简的是A的一个极小子集，它保持了分类器的分类能力。然而，在现实应用中，上述定义过于严格，因此我们引入一个参数 ε ，并给出基于正负类边界距离的属性约简定义。 定义3：对于多标签数据 S = ( U , A , L ) ，如果属性子集 B ⊆ A 满足以下条件，则称集合B是A基于正负类边界距离的属性约简： 1) | γ ( B ) − γ ( A ) | < ε ； 2) 对于任意的 B ′ ⊂ B ， | γ ( B ′ ) − γ ( A ) | ≥ ε 。 在这里，我们通过引入参数 ε 来扩大属性约简的范围，并尽可能减少冗余属性，同时将正负类样本间距离的变化保持在较小的范围内。例1更详细地描述了约简过程。 例1：给出多标签数据集 S = ( U , A , L ) ，如表1所示，样本集为 U = { x 1 , x 2 , x 3 , x 4 , x 5 , x 6 } ，属性集为 A = { a , b , c } ，标签集为 L = { l 1 , l 2 , l 3 } 。 Table 1 U a b c l 1 l 2 l 3 x 1 8 4 6 1 0 0 x 2 6 3 6 0 1 0 2 6 7 1 0 1 x 4 9 3 8 1 0 1 x 5 3 3 8 0 0 1 x 6 4 8 4 0 1 0 表1. 多标签数据 正负类样本集如表2所示。 Table 2 L E F l 1 E 1 = { x 1 , x 3 , x 4 } F 1 = { x 2 , x 5 , x 6 } l 2 E 2 = { x 2 , x 6 } F 2 = { x 1 , x 3 , x 4 , x 5 } l 3 E 3 = { x 3 , x 4 , x 5 } F 3 = { x 1 , x 2 , x 6 } 表2. 样本集 根据距离定义计算出正负类样本间距离，然后得到依赖度函数值，结果如表3所示。 Table 3 B {a} {b} {c} {a,b} {a,c} {b,c} A d B 2 1 0 2.236 2 1 2.236 d B 2 1 0 2.236 2 1 2.236 d B 2 2 1 2.828 3.605 2.236 4.123 γ ( B ) 6 4 1 7.3 7.605 4.236 8.595 表3. 距离 根据定义3计算得到表4。 Table 4 {a} {b} {c} {a,b} {a,c} {b,c} A | γ ( B ) − γ ( A ) | 2.595 4.595 7.595 1.295 0.99 4.359 0 表4. 依赖度 根据定义3中的参数 ε = 1 ，则从表4中可看出属性集 { a , c } 是正负类边界距离的属性约简。 现在，我们设计了一种基于正负类边界距离的属性约简算法。把定义3中的参数 ε 看作算法的停止条件，当依赖度的增加小于参数 ε 时，算法终止，完成属性约简。 变量 A k 是剩余的属性集，变量 B k 是选择的属性集。最初的剩余属性集就是全部的属性集A，从 A k 中任意选择一个 a j ，把它并到 B k 里，计算依赖度 γ ( B k ∪ { a j } ) ，有多少个属性就算多少个依赖度。然后选择依赖度最大的属性，在剩余属性 A k 里去掉，选择的属性 B k 中加上。选择最大的依赖度作为新的依赖度，当依赖增量小于参数 ε 时，算法终止，属性约简完成。当依赖增量大于参数 ε 时，回到第2步，选择了一个属性后还剩多少，然后循环上述过程，循环到满足不等式时，属性约简完成。在算法中， | U | 是样本数， | A | 是属性数，步骤2到步骤5是一个循环过程，循环 | A | 次。因此，时间复杂度为 O ( | A | | U | 2 ) 。"
"为了评估PNBR算法的性能，本文在九个多标签数据集上实现了PNBR算法，并将实验结果与四种多标签属性约简算法进行了性能比较。这些算法包括PR、MDMR、FSSL和NLD，其中PR代表经典的正域约简算法 [ 12 ]、MDMR代表标签最大依赖和最小冗余算法 [ 13 ]、FSSL代表基于流标签的多标签学习的特征选择算法 [ 11 ]、NLD代表邻域标签依赖度约简算法 [ 14 ] 和PNBR代表我们提出的正负类边界距离的多标签数据属性约简算法。九个多标签数据集如表5所示。 Table 5 Data set Type Samples Attributes Label Flags Hybrid 194 19 7 Yeast Numerical 2417 103 14 Emotion Numerical 593 72 6 CAL500 Numerical 500 62 174 Scene Numerical 2407 294 6 Enron Nominal 1702 1001 53 Medical Nominal 978 1449 45 Core15k Nominal 5000 499 374 Genbase Nominal 662 1185 27 表5. 多标签数据集 在我们的实验中，采用十折交叉验证来评估不同方法的有效性。十折交叉验证是将原始数据集随机分成10个大小相同的样本子集，轮流将其中9个子集当作多标签训练集，一个子集当作多标签测试集，进行实验。每次实验都会得出相应的正确率或差错率，10次实验结果的正确率或差错率的平均值作为对算法精度的估计。表6给出了实验后所选属性的平均数量，并用下划线突显了两个最佳结果。通过比较所选属性的平均数量可知，MDMR算法和PNBR算法更好，可以去除更多的冗余属性。而PR算法和FSSL算法相对差一点。 Table 6 Data set Raw data PR MDMR FSSL NLD PNBR Flags 19 8.3 5.0 11.9 9.4 4.0 Yeast 103 7.7 7.3 9.6 9.4 8.6 Emotion 72 5.9 5.8 5.7 6.1 5.6 CAL500 62 8.7 8.5 8.2 3.7 3.3 Scene 294 8.9 8.6 11.9 8.8 11.8 Enron 1001 100.9 39.7 63.8 36.4 37.3 Medical 1449 63.9 34.4 63.3 31.9 31.2 Core15k 499 168.5 34.9 31.8 159.9 155.1 Genbase 1185 18.9 15.7 17.9 15.9 15.1 表6. 所选属性的平均数量 实验结果分析，对于数值型数据而言，PNBR算法和MDMR算法选择的属性最少。在Flags数据集中，它只保留了19个属性中的4或5个，这两种算法相对其他算法较差。然而在数据集Enron、Medical和Genbase中，随着数据属性数量的增加，属性减少的就不多了，这种影响就可以忽略不计了。 十折交叉验证的平均运行时间如表7所示，可以看出，MDMR算法、NLD算法和PNBR算法的运行时间比其他算法长，PR算法和FSSL算法的运行时间比其他算法短。 Table 7 Data set PR MDMR FSSL NLD PNBR Flags 0.10 0.18 0.12 0.25 0.37 Yeast 107.34 255.62 329.41 757.11 967.71 Emotion 0.49 0.64 0.43 0.56 0.53 CAL500 0.37 3.96 1.52 5.31 9.38 Scene 320.68 318.62 848.60 841.88 821.58 Enron 337.68 373.22 208.66 337.81 324.85 Medical 193.33 129.91 150.05 92.38 88.69 Core15k 349.89 3768.82 264.80 2925.93 2815.86 Genbase 67.81 67.92 57.69 60.78 67.89 表7. 平均运行时间 实验结果分析，对于数值型数据而言，FSSL算法和NLD算法的计算时间大约是PR算法和MDMR算法的2倍，NLD算法和PNBR算法的计算时间大约是PR算法和MDMR算法的3倍。在Flags数据集中，由于数据集较小，所以算法的计算速度的差异不明显。 本文用分类器ML-9NN评估了五种属性约简算法的分类性能，同时，采用Hamming Loss、F 1 score和Coverage三种多标签分类的评价指标，来衡量约简数据的分类精度 [ 15 ]，其中下划线突显了两个最佳结果。 Table 8 Data set Raw data PR MDMR FSSL NLD PNBR Flags 0.284 ± 0.051 0.285 ± 0.049 0.276 ± 0.057 0.269 ± 0.029 0.293 ± 0.031 0.289 ± 0.035 Yeast 0.198 ± 0.011 0.213 ± 0.010 0.202 ± 0.011 0.209 ± 0.012 0.199 ± 0.011 0.198 ± 0.010 Emotion 0.189 ± 0.019 0.238 ± 0.029 0.235 ± 0.029 0.198 ± 0.019 0.217 ± 0.019 0.179 ± 0.019 CAL500 0.167 ± 0.013 0.169 ± 0.011 0.165 ± 0.011 0.168 ± 0.013 0.159 ± 0.012 0.157 ± 0.013 Scene 0.118 ± 0.011 0.115 ± 0.010 0.123 ± 0.012 0.115 ± 0.011 0.131 ± 0.010 0.112 ± 0.011 Enron 0.065 ± 0.010 0.066 ± 0.011 0.057 ± 0.015 0.069 ± 0.011 0.059 ± 0.010 0.068 ± 0.012 Medical 0.029 ± 0.011 0.027 ± 0.010 0.025 ± 0.011 0.026 ± 0.013 0.019 ± 0.010 0.020 ± 0.011 Core15k 0.013 ± 0.000 0.014 ± 0.000 0.017 ± 0.000 0.015 ± 0.000 0.012 ± 0.000 0.011 ± 0.000 Genbase 0.019 ± 0.000 0.010 ± 0.000 0.019 ± 0.000 0.017 ± 0.000 0.021 ± 0.000 0.022 ± 0.000 表8. 汉明损失 汉明损失反应的是错误分类的样本标签占总样本标签的比率，该指标取值越小，算法的性能越好，当值为0时达到最优。从表8可以看出，NLD算法和PNBR算法优于其他算法，MDMR算法和FSSL算法的性能略优于PR算法，结合表6和表7中的属性约简数量和运行时间，NLD算法和PNBR算法保留的属性更多，即使耗时长，但它的分类效果更好，特别是对于符号型数据。 Table 9 Data set Raw data PR MDMR FSSL NLD PNBR Flags 0.686 ± 0.059 0.695 ± 0.059 0.703 ± 0.079 0.687 ± 0.038 0.683 ± 0.049 0.679 ± 0.039 Yeast 0.627 ± 0.018 0.589 ± 0.011 0.597 ± 0.013 0.589 ± 0.018 0.625 ± 0.018 0.633 ± 0.011 Emotion 0.636 ± 0.047 0.627 ± 0.029 0.613 ± 0.026 0.631 ± 0.038 0.623 ± 0.057 0.615 ± 0.057 CAL500 0.448 ± 0.013 0.453 ± 0.013 0.446 ± 0.011 0.443 ± 0.011 0.435 ± 0.015 0.439 ± 0.016 Scene 0.669 ± 0.028 0.657 ± 0.039 0.661 ± 0.047 0.659 ± 0.028 0.657 ± 0.018 0.673 ± 0.015 Enron 0.447 ± 0.049 0.453 ± 0.058 0.451 ± 0.059 0.436 ± 0.088 0.439 ± 0.059 0.443 ± 0.059 Medical 0.367 ± 0.089 0.355 ± 0.117 0.359 ± 0.108 0.353 ± 0.117 0.373 ± 0.169 0.371 ± 0.168 Core15k 0.087 ± 0.018 0.083 ± 0.048 0.090 ± 0.017 0.082 ± 0.029 0.088 ± 0.017 0.081 ± 0.017 Genbase 0.873 ± 0.018 0.868 ± 0.018 0.869 ± 0.018 0.879 ± 0.018 0.878 ± 0.018 0.883 ± 0.018 表9. F 1 分数 F 1 score相对于汉明损失是一个综合版本，F 1 score衡量分类的准确性，并忽略错误分类的样本。它是精确率和召回率的调和平均值，该指标取值越大，算法的性能越好，通常最大值为1，最小值为0，当值为1时达到最优。从表9可知，除数据集Core15k外，五种算法在F 1 score方面没有显著差异。对于Core15k数据集，NLD算法和MDMR算法的分类精度与原始数据差不多。 Table 1 0 Data set Raw data PR MDMR FSSL NLD PNBR Flags 0.919 ± 0.019 0.927 ± 0.019 0.936 ± 0.028 0.923 ± 0.019 0.900 ± 0.010 0.899 ± 0.019 Yeast 0.869 ± 0.010 0.839 ± 0.010 0.840 ± 0.010 0.827 ± 0.010 0.836 ± 0.010 0.843 ± 0.010 Emotion 0.678 ± 0.027 0.543 ± 0.019 0.517 ± 0.019 0.658 ± 0.029 0.647 ± 0.03 0.639 ± 0.019 CAL500 0.987 ± 0.010 0.987 ± 0.010 0.989 ± 0.010 0.986 ± 0.010 0.975 ± 0.010 0.973 ± 0.010 Scene 0.634 ± 0.019 0.228 ± 0.010 0.243 ± 0.010 0.298 ± 0.010 0.339 ± 0.078 0.223 ± 0.010 Enron 0.717 ± 0.067 0.778 ± 0.100 0.789 ± 0.069 0.637 ± 0.078 0.725 ± 0.083 0.710 ± 0.063 Medical 0.418 ± 0.087 0.379 ± 0.087 0.419 ± 0.087 0.369 ± 0.119 0.423 ± 0.119 0.421 ± 0.119 Core15k 0.349 ± 0.039 0.336 ± 0.068 0.362 ± 0.059 0.351 ± 0.048 0.213 ± 0.029 0.227 ± 0.029 Genbase 0.953 ± 0.010 0.947 ± 0.019 0.964 ± 0.010 0.957 ± 0.028 0.953 ± 0.010 0.947 ± 0.010 表10. 覆盖率 覆盖率表示算法生成的排序底部的真实标签的排序平均值。排序越大越不相关，所以这个覆盖率越小，算法性能越好。从表10看出，PR算法和PNBR算法优于其他算法。从数值上看，约简前后数据的分类精度并没有明显差异。实验结果表明所提约简算法能够建立合理的属性重要度排序，有效地去除冗余属性。"
"本文受基于集合到集合距离的启发，设计了一种基于正负类边界距离的属性约简算法，通过实验对所提的约简方法进行了评估，结果表明，所提约简算法能够建立合理的属性重要度排序，有效地去除冗余属性，并保持较高的分类精度。 实验研究表明，我们这个方法在处理大规模数据时，计算复杂度还是有点高，如何降低时间复杂度是我们今后要做的工作。另外在本文，我们将多标签数据分解中的标签看作为独立的，不相关的，但是在现实生活中，标签之间应该是有相关性的，所以，今后的研究工作中要将标签的相关性考虑进去，再做研究。"
