"本文在Newton法和最速下降法的组合方法的基础上提出求解无约束优化问题的Newton法与谱梯度法的组合方法，该方法有效地应用于目标函数的Hessian矩阵不正定或初始点不接近极小点的问题，并利用非单调线搜索求解步长。在较温和的条件下建立了该方法的全局收敛性和超线性收敛性，并且数值实验证明了该算法具有很好的数值实验效果。 关键词 :牛顿方向，谱梯度方向，非单调，凸组合 Copyright © 2020 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY 4.0). http://creativecommons.org/licenses/by/4.0/"
"本文主要用于研究如下非线性无约束最优化问题 (1.1) 其中 f : R n → R 是连续可微函数。本文的方法是通过更新迭代式 x k + 1 = x k + α k d k (1.2) 来解决问题(1.1)， d k 是搜索方向， α k > 0 是步长。 牛顿法是解无约束优化最经典也是最早的算法之一，作为最基本的求解无约束优化问题的方法，牛顿法及其各种改进方法一直受到广泛关注(见文献 [ 1 ] [ 2 ] [ 3 ] [ 4 ])。下面是牛顿法的原理： 假设 x k 是当前迭代点，计算 x k 处目标函数的梯度 和Hessian矩阵 G k = ∇ 2 f ( x k ) 。若 ，则根据目标函数的二次可微性知，目标函数在 附近是严格凸函数。基于目标函数的二次泰勒展式，在当前迭代点 x k 附近： f ( x k + d ) ≈ f ( x k ) + d T ∇ f ( x k ) + 1 2 d T ∇ 2 f ( x k ) d (1.3) 所以，考虑 min d ∈ ℜ n φ k ( d ) = d T ∇ f ( x k ) + 1 2 d T ∇ 2 f ( x k ) d (1.4) 假定 是正定的，则知该式的解是 (1.5) 上式就是牛顿搜索方向。牛顿方向 被附加到(1.2)的搜索方向而不是直接替代主要基于以下几个考虑：首先(1.1)对于 [ 5 ] 中的问题，函数 f : R n → R 的Hess矩阵可能不正定，即使我们假设f在 R n 上连续可微，也可能初始点的选取没有足够靠近“极小点”，牛顿法的一些理想性质不在初始点附近，其次通过结合谱梯度法，能够避免求得的(1.1)式的解被困在局部最小值中。 BB步是由Barzilai和Barwein在1988年提出的两点步长梯度法 [ 6 ]，其基本思想是利用迭代当前点以及前一点的信息来确定步长因子。1993年和2002年Raydan和Dai & Liao证明了广义n维严格凸二次型BB方法的全局收敛性和R-线性收敛性。随后，BB方法也扩展以解决一般的非线性优化问题。通过将Grippo等提出的非单调线搜索 [ 7 ] [ 8 ] [ 9 ] 结合起来，1997年Marcos Raydan在文献 [ 10 ] 中提出了一种加入全局策略的GBB算法，2018年Yu-Hong Dai在文章 [ 11 ] 中，提出了一族谱梯度法，并证明了此类算法在任意维情况下都具有R阶超线性收敛性。下面是该方法的原理： 他们是把迭代公式 x k + 1 = x k + λ k d k 看成是 x k + 1 = x k − D k g k (1.6) 其中 g k = g ( x k ) = ∇ f ( x k ) ， D k = λ k I .为了使矩阵 D k 具有“拟牛顿”性质，计算 λ k 使得 (1.7) 或者 min ‖ D k − 1 s k − 1 − y k − 1 ‖ 2 (1.8) 其中 s k − 1 = x k − x k − 1 ， y k − 1 = g k − g k − 1 ，由上两式分别求得 λ 1 = s k − 1 T y k − 1 / ‖ y k − 1 ‖ 2 2 (1.9) 和 λ 2 = ‖ s k − 1 ‖ 2 2 / s k − 1 T y k − 1 (1.10) 上面两式就是谱梯度步长。在一般的非二次情况下， ， λ 2 可以是令人无法接受的大或小(甚至对于非凸函数是负的)，因此我们必须假设逐步计算出的 λ 是通过对(1.10)或(1.11)进行修改，以满足形式的一个条件 0 < min ( η , 1 τ ) ≤ λ k ≤ max ( 1 η , 1 τ ) (1.11) 若不然，则令 λ = τ 。 现在我们给出一个简短的分析，形成了一个针对问题(1.1)的牛顿谱梯度法。对任意的 当 g k = ∇ f ( x k ) ≠ 0 时，设 是目标函数的Hessian矩阵。由于目标函数f是连续可微的，所以如果下列方程 (1.12) 有解 ，则 d N 在 处的方向为下降方向，并称为f在 x k 的牛顿方向。且由论文 [ 12 ] 得，序列 { x k } 的任何极限点 x * 都是f的稳定点，既 g ( x * ) = 0 。 谱梯度法因其几乎对所有初始值都是成立的而得到广泛的应用。从而弥补了牛顿法对初始点的苛刻要求，并且该方法不需要求解目标函数f的Hessian矩阵。因此有如下谱梯度方向 d B = − λ g k (1.13) 在本文中，我们结合(1.6)和(1.12)引入牛顿方向和谱梯度方向的凸组合来最大化利用这两种方法的优势。对于任给的 x ∈ ℜ n 设 d k = t d N + ( 1 − t ) d B (1.14) 其中谱梯度方向 d B 有一个缺点是该方向不总是下降的。为了克服这一缺点，本文结合Grippo等提出的非单调线搜索，从而避免了谱梯度法不是单调下降的问题。 f ( x k + β m k d k ) ≤ max 0 ≤ j ≤ M f ( x k − j ) + σ β m k g k T d k (1.15) 其中步长 α k = β m k 。 文章剩下的部分组织如下：第二节给出了搜索方向的性质并描述了具体的牛顿谱梯度方法；第三节证明了算法的收敛性；第四节给出了数值实验，第五节进行了总结。"
"算法2.1 (牛顿谱梯度算法) 步0 给定初始点 x 0 ∈ R n ，终止误差 。令 k:=0 步1 计算 。若 ‖ g k ‖ ≤ ε ，停算，输出 x k 作为近似极小点。 步2 由(1.10)或(1.11)给出满足条件(1.12)的 d B = − λ g k . 步3 计算 G k = ∇ 2 f ( x k ) ，解方程组 G k d + g k = 0 (2.1) 若(2.1)有解 d N ，且满足 g k T d N < 0 ，转步3；否则，令 d k = d B 转步5。 步4 d k = t d N + ( 1 − t ) d B . 步5 由非单调线搜索技术确定步长因子 。( m k 是满足条件的最小非负整数) (2.2) 步6 令 ， k : = k + 1 ，转步1。 首先，我们将研究 d k 的一些性质，且我们假定目标函数f在 R n 上总是二次连续可微的，且满足下列假设1： 假设1 目标函数 f : R n → R 二次连续可微，对任意给定 x 0 ∈ R n ，f在水平集 (2.3) 上有界的。 假设2 存在 x * 的一个领域 N ( x * , δ 1 ) ，使得 g ( x ) 在该邻域内Lipschitz连续，既存在一个常数 0 < K < 1 3 λ 使得 假设3 存在 的一个领域 N ( x * , δ ) ，使得 在该邻域内Lipschitz连续，既存在一个常数 ，使得 为了证明收敛性定理，首先给出如下性质：下列性质证明该算法的方向是下降方向。 定理2.1 假设 x ∈ R n 不是(1.1)的稳定点，由式(2.1)计算得到的 存在且 σ ∈ ( 0,1 ) 。则存在 使得， 是f在x处的下降方向且满足(2.2)式。 证明：因为f是连续可微的，对于给定的 t ∈ [ 0 , 1 ] d k = t d N + ( 1 − t ) d B 通过(1.12)和(1.6)有 ∇ f ( x ) T d k = ∇ f ( x ) T ( t d N + ( 1 − t ) d B ) = t ∇ f ( x ) T ⋅ ( − G k − 1 g k ) − ( 1 − t ) ∇ f ( x ) T λ g k = − t g k T G k − 1 g k − λ ( 1 − t ) g k T g k 根据正定矩阵的逆矩阵仍然是正定矩阵的性质，显然有 . (2.4) 对任给的 ，有 (2.5) 且对任给的k都有 f ( x k + α k d k ) ≤ max 0 ≤ j ≤ M f ( x k − j ) 故有 f ( x k + α k d k ) ≤ max 0 ≤ j ≤ M f ( x k − j ) + ∇ f ( x ) T d k + ο (αk) 结合(2.4)，对任给的 ，(2.2)成立。 目前为止，我们已经考虑了非稳定点 x k 处的搜索方向 的一些全局性质，为了证明我们算法的超线性收敛性，我们接下来考虑解点周围的方向的性质。 定理2.2 假设 x * 是 g ( x ) = 0 的解，存在 ( 0 , 1 ) 一个常数 κ ，对任给的 ， 0 < min ( η , 1 τ ) ≤ λ k ≤ max ( 1 η , 1 τ ) 且对于 x k ∈ ℜ n ， x k → x * ，有 ∇ f ( x k ) T d k = − 2 α k f ( x k ) + α k ο ( f ( x k ) ) 证明：详见参考文献 [ 13 ] 定理3.2。"
"针对我们的牛顿谱梯度法， 是通过求解线性系统(2.1)得到，如果(2.1)是不可解的或者矩阵 G k 是高度病态的，则 d N = − λ g k ，这意味着 。其次，通过定理2.1，如果 不是(1.1)的稳定点，且算法2.1的步骤5有很好的定义，则我们的算法要么停止在一个稳定点，要么生成一个无穷序列 { x k } 。 定理3.1 设 { x k } 是由算法2.1生成的序列，且满足假设1，则下列性质成立： (a) 序列 { x k } 的任何极限点 都是f的稳定点，既满足 ； (b) { x k } 的任何极限点 x * 都不是f的极大值点； (c) 如果 { x k } 只有有限个稳定点，则序列 { x k } 本身收敛。 证明：为了证明性质(a)，我们结合定理2.1使用了( [ 7 ], p709)中的收敛性证明部分。 我们定义 ，显然 m ( 0 ) = 0 ， 对所有的 k ≥ 1 ，另外，对任给的k有 α k ∈ ( 0 , 1 ] ，最后存在正数 和 c 2 使得搜索方向 满足 g k T d k ≤ − c 1 ‖ g k ‖ 2 , 实际上，在牛顿谱梯度法中 d k = t d N + ( 1 − t ) d B ，对于所有的 k ≥ 1 ∇ f ( x ) T d k = ∇ f ( x ) T ( t d N + ( 1 − t ) d B ) = t ∇ f ( x ) T ⋅ ( − G k − 1 g k ) − ( 1 − t ) ∇ f ( x ) T λ g k = − t g k T G k − 1 g k − λ ( 1 − t ) g k T g k 因为 G k 正定，故 G k − 1 正定，即对一切 有 h T G k − 1 h > 0 ，而 g ( x k ) ≠ 0 ，所以存在一个正数p，使得 ，从而有 g k T d k ≤ ( t p − λ ( 1 − t ) ) ‖ g k ‖ 2 ，另外， ‖ d k ‖ = ‖ t d N + ( 1 − t ) d B ‖ = ‖ − t G k − 1 g k − ( 1 − t ) λ g k ‖ ≤ ‖ − t G k − 1 g k ‖ + ‖ ( 1 − t ) λ g k ‖ 由 G k 的正定性及f二次连续可微可知，存在 x * 的一个领域 U ( x * ) ，使得对任意的 ，都有 G ( x ) 是一致正定的。特别的， ‖ G ( x ) − 1 ‖ 在上有界，既存在常数 C > 0 ，使得 ‖ G ( x ) − 1 ‖ ≤ C ，故而 ‖ d k ‖ ≤ ( t C + ( 1 − t ) λ ) ‖ g k ‖ 。 对任给的 t ∈ [ 0 , 1 ] ， λ ∈ ( 0 , 1 ] ，令 c 1 = t p − λ ( 1 − t ) ， 。 因此，根据( [ 9 ], p711)中的等式(14)，我们得到 因为 α k = β m k > 0 ，(a)式得证。 (b)和(c)的证明直接由 [ 9 ] 中的收敛性定理给出。 定理3.2设函数 f ( x ) 二次连续可微， { x k } 由算法2.1产生的迭代序列，且满足假设2，设 { x k } 聚点 是f的解。 正定，则 { x k } 超线性收敛于f的全局极小点 x * 。 证明：由 G ( x * ) 的正定性及f二次连续可微可知，存在 x * 的一个领域 U ( x * ) ，使得对任意的 x ∈ U ( x * ) ，都有 G ( x ) 是一致正定的。特别的， ‖ G ( x ) − 1 ‖ 在上有界，既存在常数 C > 0 ，使得 ‖ G ( x ) − 1 ‖ ≤ C 。又由 G ( x ) 的连续性知，存在邻域 U ( x * ) ，使得 ‖ G ( x ) − G ( x * ) ‖ ≤ 1 4 C , ∀ x ∈ U ( x * ) ⊆ U 1 (x*) 因此，当 x k ∈ U ( x * ) 时，有 ‖ x k + 1 − x * ‖ = ‖ x k + α k ( − t G k − 1 g k − ( 1 − t ) λ g k ) − x * ‖ = ‖ G k − 1 ‖ ⋅ ‖ α k t ( g k − g * ) − G k ( x k − x * ) + α k ( 1 − t ) λ G k ( g k − g * ) ‖ ≤ ‖ G k − 1 ‖ ⋅ ‖ α k t ( g k − g * ) − G k ( x k − x * ) ‖ + ‖ α k ( 1 − t ) λ ( g k − g * ) ‖ ≤ C ‖ ∫ 0 1 G ( x * + μ ( x k − x * ) ) ( x k − x * ) d μ − G k ( x k − x * ) ‖ + K λ ‖ x k − x * ‖ ≤ C ∫ 0 1 ‖ G ( x * + μ ( x k − x * ) ) − G k ‖ ⋅ ‖ x k − x * ‖ d μ + K λ ‖ x k − x * ‖ 从而有 ‖ x k + 1 − x * ‖ = ο ‖ x k − x * ‖ ，既 { x k } 超线性收敛于 。"
"本文从文献 [ 5 ] 中取出38个标准测试问题进行数值实验，目的是比较本文算法与几种经典无约束优化算法的数值效果以及对本文不同M值的算法的试验效果。所有数值实验都是在WINDOWS10操作系统，CPU频率为2.0 GHz，内存为2 GB的个人计算机上进行。各参数选取如下： ， σ = 0 .4 ， ρ = 0 .55 ， η = 10 − 10 。其中如果步2中 λ k 不满足(1.12)，则参数 由下列式子给出： τ = { 1 ,                             ‖ g k ‖ 2 > 1 ‖ g k ‖ 2 − 1 ,         10 − 5 ≤ ‖ g k ‖ 2 ≤ 1 10 5 ,                       ‖ g k ‖ < 10 − 5 (4.1) 表1中列出了各计算结果，其中各列的代表含义如下：k：迭代次数；flag：函数值的计算次数； f * ：算法求得的最优值。文中的初始点 x 0 采用文献 [ 5 ] 中给定的用来试验函数正确性的点作为初始点；终止条件采用 ‖ g k ‖ ≤ 10 − 8 。 表1选取M = 1，M = 2，M = 5，M = 10对本文算法进行比较，计算出不同的M值函数的迭代次数k，函数值的计算次数flag和函数值 f * ，并进行了比较。凸组合参数t的选取是通过比较t = 0.4, 0.5, 0.55，0.6，0.618这几个参数选取的，通过比较发现当 t = 0.618 时，表现效果较佳，因此选择 。其次从表中可以看出当M = 10时，该算法在最优函数值，函数值的计算次数以及迭代次数上对更多函数都是好的，因此选用M = 10时的函数计算效果与其他方法进行比较。表2中主要把共轭梯度法，BFGS拟牛顿法同本文中的算法进行比较。 Table 1 问题 nmsg方法M1 nmsg方法M2 nmsg方法M5 nmsg方法M10 flag f * k flag f * k flag f * k flag f * k fun 170 9.30E−22 52 64 7.68E−20 52 15 3.64E−18 54 14 1.74E−26 56 fun202 64 4.90E+01 22 29 1.04E−20 21 12 3.98E−21 28 16 2.24E−25 32 fun204 1 1.84E−01 9 0 1.84E−01 8 0 1.84E−01 8 0 1.84E−01 8 fun208 170 9.30E−22 52 64 7.71E−20 52 15 3.64E−18 54 14 1.74E−26 56 fun243 8 7.97E−01 13 4 7.97E−01 12 4 7.97E−01 12 4 7.97E−01 12 fun256 902 1.71E−14 221 302 1.13E−18 83 44 2.57E−19 59 18 2.18E−20 67 fun266 6 1.00E+00 14 4 1 13 3 1 13 3 1.00E+00 13 fun271 0 9.97E−21 10 0 9.97E−21 10 0 9.97E−21 10 0 9.97E−21 10 fun273 0 8.17E−20 15 0 8.17E−20 15 0 8.17E−20 15 0 8.17E−20 15 fun275 7 2.94E−15 10 5 3.54E−16 11 0 1.89E−18 11 0 1.89E−18 11 fun276 13 4.73E−16 13 3 6.78E−16 12 0 7.02E−19 12 0 7.02E−19 12 fun286 170 9.30E−21 52 64 1.02E−19 53 15 3.64E−17 54 14 1.74E−25 56 fun288 582 4.62E−15 139 399 4.06E−18 105 44 1.28E−18 59 18 1.09E−19 67 fun290 5 1.50E−12 21 5 1.50E−12 21 5 1.50E−12 21 5 1.50E−12 21 fun291 12 1.62E−12 25 12 1.62E−12 25 12 1.62E−12 25 12 1.62E−12 25 fun292 17 8.01E−13 28 17 8.01E−13 28 17 8.01E−13 28 17 8.01E−13 28 fun293 20 6.32E−13 30 20 6.32E−13 30 20 6.32E−13 30 20 6.32E−13 30 fun294 3 5.64E+00 500 60 1.67E−20 63 47 3.30E−20 59 9 3.85E−20 54 fun295 14 9.59E+00 500 20 9.52E+00 500 78 3.40E−20 91 28 2.73E−20 79 fun296 369 4.75E−18 139 12 1.55E+01 500 113 2.28E−20 137 47 6.19E−21 107 fun298 599 1.10E−17 221 355 1.11E−20 296 178 4.87E−20 211 165 8.19E−22 241 fun300 273 −20 64 18 −20 27 4 −20 24 4 −2.00E+01 24 fun301 265 −50 53 22 −50 30 9 −50 26 9 −50 26 fun302 421 −100 68 31 −100 33 18 −100 30 16 −1.00E+02 27 fun308 9 7.73E−01 15 6 7.73E−01 14 6 7.73E−01 14 6 7.73E−01 14 fun314 8 1.69E−01 8 5 1.69E−01 9 5 1.69E−01 9 5 1.69E−01 9 fun352 28 9.03E+02 27 15 9.03E+02 21 8 9.03E+02 18 8 9.03E+02 18 fun379 192 4.01E−02 125 83 4.01E−02 93 34 4.01E−02 157 29 4.01E−02 51 表1. 不同算法同本文算法的比较 Table 2 问题 bfgs cg M = 10 flag f * k flag f * k flag f * k fun 28 7.25E−23 33 2139 2.82E−17 224 14 1.74E−26 56 fun202 22 4.90E+01 14 50883 4.90E+01 5000 16 2.24E−25 32 fun204 8 1.84E−01 3 62 1.84E−01 16 0 1.84E−01 8 fun208 28 7.25E−23 33 1791 1.15E−16 191 14 1.74E−26 56 fun243 12 7.97E−01 9 657 7.97E−01 136 4 7.97E−01 12 fun256 32 1.08E−12 42 33923 4.49E−11 5000 18 2.18E−20 67 fun266 19 1 13 305 1 84 3 1.00E+00 13 fun271 57 3.08E−30 11 160 1.68E−19 17 0 9.97E−21 10 fun273 95 1.81E−19 39 207 2.30E−20 19 0 8.17E−20 15 fun275 2 5.61E−16 26 26 2.55E−13 2807 0 1.89E−18 11 fun276 2 4.15E−13 23 16 4.36E−13 399 0 7.02E−19 12 fun286 213 3.78E−18 154 828 5.07E−17 84 14 1.74E−25 56 fun288 96 6.13E−13 198 2485 1.83E−12 342 18 1.09E−19 67 fun290 8 1.70E−12 39 12 1.56E−10 5000 5 1.50E−12 21 fun291 102 8.40E−13 76 51 1.76E−11 5000 12 1.62E−12 25 fun292 430 5.70E−13 166 117 3.39E−12 4358 17 8.01E−13 28 fun293 3 NAN 5000 0 NAN 5000 20 6.32E−13 30 fun294 86 3.97E+00 45 5861 5.85E−17 561 9 3.85E−20 54 fun295 141 3.99E+00 74 2808 6.00E−17 255 28 2.73E−20 79 fun296 222 3.99E+00 103 1489 NAN 5000 47 6.19E−21 107 fun298 597 4.45E−21 249 14285 4.68E−18 1010 165 8.19E−22 241 fun300 20 −20 25 3264 −20 894 4 −2.00E+01 24 fun301 52 −50 57 11513 −5.00E+01 3134 9 −50 26 fun302 100 −100 107 18129 −1.00E+02 5000 16 −1.00E+02 27 fun308 11 7.73E−01 13 54 7.73E−01 17 6 7.73E−01 14 fun314 9 1.69E−01 6 729 1.69E−01 128 5 1.69E−01 9 fun352 23 9.03E+02 9 37703 9.03E+02 5000 8 9.03E+02 18 fun379 43 4.01E−02 56 9501 4.01E−02 1902 29 4.01E−02 51 表2. 不同M取值的算法比较 从表2中能明显地看出，本文的算法在很大一部分函数中都有很好的计算效果，在27个函数中，其中对最优函数值表现好的有20个，对迭代次数表现好的有14个，而从函数值的计算次数来看，几乎处处表现良好。因此我们得到了一个相对比较好的算法。"
"本文通过介绍牛顿法与谱梯度法的凸组合搜索方向提出一种求解无约束优化问题的牛顿–谱梯度法，该算法实现了好的数值实验结果，即使在牛顿方向奇异的情况。我们在数值试验过程中还发现该方法在某些情况下依然会带有牛顿法中无法达到最优点的问题，但是当添加适当的选择条件时可能会取得更好的实验结果。"
