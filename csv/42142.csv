"基于密文策略的属性代理重加密方案可以同时实现灵活的访问控制和云端密文共享功能。但现有的属性代理重加密方案多以双线性映射构造而成，面临着加解密运算效率低的问题。为解决上述问题，本文提出一种新的加密方案：离线/在线的可验证外包属性代理重加密方案(offline/online attribute-based proxy re-encryption with verifiable outsourced decryption, VF-OO-ABPRE)。基于已有的外包解密属性加密方案，利用离线/在线加密技术，对加密算法进行改进，提高加密效率，结合代理重加密的思想，实现密文共享。同时将解密工作外包给云服务商，并且能够快速地验证外包解密计算结果的正确性。理论分析表明本方案在随机预言机模型中满足选择明文攻击的不可区分安全性，并且提供了外包的可验证性证明，同时能抵抗共谋攻击。"
"基于属性的加密(attribute-based encryption, ABE) [ 1 ] 可以实现加密数据的细粒度访问控制，在数据的隐私保护场景中应用广泛。主要有两种形式：基于密文策略的属性加密 [ 2 ] (ciphertext-policy attribute-based encryption, CP-ABE)和基于密钥策略的属性加密 [ 3 ] (key-policy attribute-based encryption, KP-ABE)。前者私钥关联授权属性集合，密文关联属性集合满足的访问策略，后者则相反。2007年，Bethencourt等 [ 2 ] 第一次提出基于密文策略的属性加密方案(CP-ABE)，采用访问树的结构进行秘密共享。2011年，Waters等 [ 4 ] 第一次提出线性秘密共享方案(linear secret sharing scheme, LSSS)的CP-ABE，较Bethencourt等 [ 2 ] 的方案在共享效率上有所提升，但是面临着私钥生成，数据加密和解密阶段的大量运算，且计算量与属性集合或者访问策略的复杂度成线性增长，这将会给移动用户端带来严重的计算负担和电量消耗，为解决上述问题，2011年，Green等 [ 5 ] 提出一种解密外包的ABE方案，在解密阶段首先将数据密文发送给解密外包服务器，由解密外包服务器对数据密文进行一次密文转换，生成部分密文再发送给用户，用户利用自身私钥解密出数据明文，可以缓解数据用户端的解密计算压力。运用相同的思想，更多的外包ABE方案 [ 6 ] [ 7 ] [ 8 ] [ 9 ] 被相继提出。除了解密外包，一些学者也实现了加密外包。2012年，Li等 [ 10 ] 构造加密外包的CP-ABE方案中，用户只需要做一些简单的操作就可以获得部分密文，云服务器将通过使用外包加密密钥继续完成大部分的加密操作，以获取密文的其他部分。然而，该方案仍然需要用户做大量与属性相关的求幂运算。2016年，Wang等 [ 11 ] 提出了一种可验证外包的ABE方案，实现加密、解密和密钥生成外包。但在方案中，密文的大小过大造成了密文存储空间的浪费。 2014年，Hohenberger等 [ 12 ] 提出离线/在线的ABE技术，将加密分成两个阶段进行，离线阶段在不知道相关的属性集合或者访问结构时，自动完成大量的加密计算预处理工作，在线阶段可以进行较少的计算快速完成属性加密工作。通过这种技术，可以将计算量大的工作尽可能多地在离线阶段完成，减少在线阶段的加密工作量。相较于加密外包，离线/在线同样减轻了用户加密阶段的计算负担，同时保证了数据的机密性。但是该方案不支持外包解密。2017年，Liu等 [ 13 ] 提出可验证外包解密的离线/在线ABE加密方案，采用离线/在线技术结合可验证外包计算技术，在标准模型下被证明是选择性明文攻击安全的，但是方案中离线/在线技术只用于私钥的生成，用户端的加密负担仍然存在。 单纯的离线/在线加密技术不足以解决解密授权转让和密文共享的问题，代理重加密 [ 14 ] (proxy re-encryption, PRE)是一种很好的解决方式。2009年，Liang等 [ 15 ] 首次在ABE方案中引入代理重加密技术，提出第一个基于密文策略的属性代理重加密方案(ciphertext-policy attribute-based proxy encryption, CP-ABPRE)，解决了ABE方案中共享访问策略更新和数据密文共享的问题，访问策略采取“AND”门，策略的表达性不高。2013年，Liang等 [ 16 ] 结合LSSS提出一个CP-ABPRE方案，能抵抗选择明文攻击(chosen plaintext attack, CPA)和选择密文攻击(chosen ciphertext attack, CCA)，在合数阶双线性群中的CP-ABPRE方案被相继提出 [ 17 ] [ 18 ]，都能实现标准模型中的自适应CCA安全。同样地，重加密的密钥生成和重加密都需要大量的计算。为弥补一般服务器在计算和存储能力上的不足问题，2014年，Gritti等 [ 19 ] 提出在线/离线的CP-ABPRE方案，虽然引入了代理重加密，实则利用代理者进行外包加密，不具备解密授权转让的功能。2015年，Kawai等 [ 20 ] 提出将重加密密钥外包的CP-ABPRE方案，重加密密钥不再由用户端生成，而是由授权中心来生成，这无疑增加了授权中心的计算负担。2017年，Sepehri等 [ 21 ] 提出将用户属性集合与共享访问策略用向量表示的CP-ABPRE方案，只有二者内积为0时，才能重加密密文，达到实现策略隐藏的目的。Yin等 [ 22 ] 在2017年提出一种改进的具有访问策略隐藏功能的CP-ABPRE方案，采用“AND”门共享访问策略，表达性较低。Hong等 [ 23 ] 在2018年提出一种具有密钥隔离功能的CP-ABPRE方案，实现了重加密密钥和用户密钥的前向安全。但是，以上的方案都存在加解密效率较低的问题。 基于上述研究，考虑资源受限用户利用移动设备进行加解密和数据共享的现实需求。本文在Green等 [ 5 ] 提出的外包CP-ABE方案基础上，结合离线/在线加密(offline/online encryption)技术，提出一种离线/在线的可验证外包属性代理重加密方案(offline/online attribute-based proxy re-encryption with verifiable outsourced decryption, VF-OO-ABPRE)。主要贡献如下： 1) 通过结合离线/在线ABE加密技术和外包解密技术来实现属性代理重加密方案，是率先以最小的在线计算代价同时实现数据的访问控制功能和密文共享功能。 2) 本文的方案中，大量的计算操作将在离线阶段执行或者外包给云服务商来执行，用户端在线加密和解密的计算控制在常数级别的指数运算，不会随属性集合或访问策略的复杂度而增加计算开销。 3) 给出了本文方案的安全性分析，分析表明方案基于判定性q-parallel BDHE假设在随机预言机模型下具有选择明文攻击的不可区分安全性，同时提供本方案的可验证性和抗共谋攻击证明，理论分析表明本方案在功能性和效率方面有优势。"
"令 Γ 和 Γ T 是两个 p 阶乘法循环群，定义一个双线性映射 e : Γ × Γ → Γ T ，满足以下性质： 1) 双线性：对于 ∀ u , v ∈ Γ ， a , b ∈ ℤ p ， e ( u a , v b ) = e ( u b , v a ) = e ( u , v ) a b ； 2) 非退化性：存在 g 是 Γ 的生成元，使得 e ( g , g ) ≠ 1 ； 3) 可计算性： ∀ u , v ∈ Γ ，存在一个有效算法可计算出 e ( u , v ) 。  判定性q-parallel BDHE假设：给定一个安全参数 κ ∈ Ν ，整数q，设 Γ ， Γ T 是两个素数阶p的乘法循环群。群生成器 G ( κ ) 生成一个双线性群组 ( p , Γ , Γ T , e ) ， g 是 Γ 的生成元，取随机值 a , s , b 1 , ⋯ , b q ∈ ℤ p 。公开： Y = g , g s , g a , · · · , g a q , g a q + 2 , ⋅ ⋅ ⋅ , g a 2 q ， ∀ 1 ≤ j ≤ q , g s ⋅ b j , g a / b j , · · · , g a q / b j , g a q + 2 / b j , ⋅ ⋅ ⋅ , g a 2 q / b j ， ∀ 1 ≤ j , k ≤ q , k ≠ j , g a ⋅ s ⋅ b k / b j , ⋅ ⋅ ⋅ , g a q ⋅ s ⋅ b k / b j ， R ∈ Γ T 。在概率多项式时间(probabilistic polynomial time, PPT)内不存在算法 B 以不可忽视的优势区分出随机元素 R ∈ Γ T 和 T = e ( g , g ) a q + 1 s ∈ Γ T 。则称判定性q-parallel BDHE假设是成立的。 CDH假设(computational Diffie-Hellman, CDH)：给定一个安全参数 κ ∈ Ν ，设 Γ ， Γ T 是两个素数阶 p 的乘法循环群。群生成器 G ( κ ) 生成一个双线性群组 ( p , Γ , Γ T , e ) ， g 是 Γ 的生成元，取随机值 α , β ∈ ℤ p ，计算 g α , g β , g α β 。在多项式时间(PPT)内不存在算法 B 以不可忽视的优势在已知 g α 和 g β 情况下计算出 g α β ，则称CDH假设是成立的。  Green等 [ 5 ] CPA安全的解密外包的ABE方案一共包含五个算法：系统初始化算法 S e t u p 、密钥生成算法 K e y G e n 、外包密钥生成算法 K e y G e n o u t 、加密算法 E n c r y p t 、转换密文生成算法 T r a n s f o r m o u t 、转换密文解密算法 D e c r y p t o u t 。算法运行过程如下： S e t u p ( λ , U ) ：输入系统参数 λ ∈ Ν 和属性全集 U = { 0 , 1 } * ，选择两个 p 阶的循环群 Γ 和 Γ T ， Γ 的生成元为 g ， e ( g , g ) ⊂ Γ T ，定义杂凑函数 F : { 0 , 1 } * → Γ 。选择两个随机数 α , a ∈ ℤ p * ，输出系统主密钥 M S K = ( g α , P K ) 和系统公钥 P K = ( g , e ( g , g ) α , g a , F ) ，公开 P K 。 K e y G e n ( P K , M S K , S ) ：输入系统主密钥 M S K 、系统公钥 P K 属性集合 S ，随机选择 t ∈ ℤ p ，对于所有的 x ∈ S ，计算 K = g α g a t ， L = g t ， { K x = F ( ρ ( x ) t ) } x ∈ S 。输出私钥 S K S = ( S , K , L , { K x } x ∈ S ) 。 K e y G e n o u t ( M S K , S , S K S ) ：输入系统主密钥 M S K 、属性集合 S ，私钥 S K S ，随机选择 z ∈ ℤ p ，计算 K t k = K ( 1 / z ) ， L t k = L ( 1 / z ) ， { K x , t k = K x ( 1 / z ) } x ∈ S ，输出外包密钥 D T K S = ( S , K t k , L t k , { K x , t k } x ∈ S ) ，用户解密密钥 K e y = ( z , D T K S ) 。 E n c r y p t ( P K , m , ( M , ρ ) ) ：输入系统公钥 P K 和明文 m ，属性 S 满足的LSSS访问结构 ( M , ρ ) (其中 M 是一个 l × n 的矩阵， ρ ( ⋅ ) 是一个单射函数可以把矩阵 M 的每一行映射成一个属性)， s ∈ ℤ p 是共享的秘密值，取随机数 y 2 , ⋅ ⋅ ⋅ , y n ∈ ℤ p ，向量 v = ( s , y 2 , ⋅ ⋅ ⋅ , y n ) ∈ ℤ p n ， M i 表示矩阵M的第i行，计算 λ i = { M i v T } i ∈ { 1 , ⋯ , l ) 。取随机数 r 1 , ⋅ ⋅ ⋅ , r n ∈ ℤ p ，对于任意 i ∈ { 1 , ⋯ , l } ，计算得到密文组件： C = m ⋅ e ( g , g ) α s ， C 1 = g s ， { C 2 , i = g a λ i F ( ρ ( i ) ) − r i , C 3 , i = g r i } i ∈ { 1 , ⋯ , l } 。输出密文 C T = ( C , C 1 , { C 2 , i , C 3 , i } i ∈ { 1 , ⋯ l } ) 。 T r a n s f o r m o u t ( D T K S , C T ) ：输入密文 C T 和外包密钥 D T K S ，若用户属性集 S 不满足访问结构 ( M , ρ ) ，则输出 ⊥ 。若用户属性集 S 满足访问结构 ( M , ρ ) ，则定义 I ⊂ { 1 , ⋯ , l } 为 I = { i : ρ ( i ) ∈ S } ， { λ i } 是根据矩阵 M 对秘密 s 的有效共享，存在一个常数集 { ω i ∈ ℤ p } i ∈ I ，使得 ∑ i ∈ I ω i ⋅ λ i = s 。计算： C T p a r t = e ( C 1 , K t k ) / ∏ i ∈ I ( e ( C 2 , i , L t k ) ⋅ e ( C 3 , i , K ρ ( i ) , t k ) ) ω i = e ( g , g ) α s / z 。输出外包解密转换密文 T C = ( C , C T p a r t ) 。 D e c r y p t o u t ( K e y , C T ) ：输入密文 C T 和解密密钥 K e y ，若密文 C T 未进行外包解密，则首先运行转换密文生成算法 T r a n s f o r m o u t ( D T K S , C T ) ，若算法输出 ⊥ ，最终也输出 ⊥ 。否则，计算 C / C T p a r t z = m 。"
"本方案的系统中，主要包含5个实体：属性授权中心(attribute authority, AA)、数据拥有者(data owner, DO)、数据用户(data user, DU)、存储云服务商(storage-cloud service provider, S-CSP)、解密云服务商(decryption cloud service provider, D-CSP)、云服务代理商Proxy。 属性授权中心AA提供密钥生成服务，是一个完全可信的机构；数据拥有者DO可以使用移动设备加密明文信息并存储在云端；数据用户DU可以使用移动设备从云端下载密文并解密，包含两类：授权用户DU和被授权用户DU，授权用户DU可以直接解密由数据拥有者DO加密的原始密文，当数据需要重加密时，生成重加密密钥发送给云服务代理商Proxy，被授权用户DU用户只能解密被重加密的密文；云服务代理商Proxy提供数据密文重加密服务；存储云服务商S-DCP提供数据存储服务；解密云服务商D-CSP提供数据解密服务，所有的云服务商都是诚实且好奇的。  离线/在线的可验证外包属性代理重加密方案(VF-OO-ABPRE)包含八个算法：系统初始化算法 S e t u p 、密钥生成算法 K e y G e n 、外包密钥生成算法 K e y G e n o u t 、加密算法Encrypt (包含离线加密算法 O f f l i n e . E n c 和在线加密算法 O n l i n e . E n c 两种)、重加密密钥生成算法 R e K e y G e n 、重加密算法 R e E n c r y p t 、重加密验证算法 R e E n c r y p t V e r i f y 、解密算法Decrypt (包含转换密文生成算法 T r a n s f o r m o u t 、转换密文解密算法 D e c r y p t o u t 两种)。其中，解密算法包含了初始密文解密算法Dec 1 和重加密密文解密算法Dec 2 。算法运行过程如下： 1) 系统初始化算法 S e t u p ( 1 λ , U ) ：由可信方AA执行，输入系统参数 λ ∈ ℕ 和属性全集U，系统主密钥MSK和系统公钥PK，公开PK。 2) 密钥生成算法 K e y G e n ( P K , M S K , S ) ：可信方AA根据系统公钥PK，系统主密钥MSK和与用户相关的属性集S，为用户生成私钥SK S 并通过安全通道分发给用户。 3) 外包密钥生成算法 K e y G e n o u t ( S , S K S ) ：用户DU输入自己的私钥SK S ，属性集合S，生成解密密钥Key用户秘密保存，外包密钥 D T K S 通过安全通道发给解密云服务商D-CSP。 4) 加密算法Encrypt a) 离线加密算法 O f f l i n e . E n c ( P K , P ) ：数据拥有DO在闲时执行，输入系统公钥PK和假设用户最大可能的属性集合 P ⊆ U 。生成临时密钥TK保存在本地，输出中间密文ICH并将其上传至存储云服务商S-CSP。 b) 在线加密算法 O n l i n e . E n c ( P K , m , I C H , T K , ( M , ρ ) ) ：数据拥有者DO在真正加密时执行，输入系统公钥PK，明文信息m，中间密文ICH，临时密钥TK，以及属性S满足的访问结构 A = ( M , ρ ) ，生成初始密文 C ( M , ρ ) 和验证标识 V K m 发送给存储云服务商S-CSP进行存储。 5) 重加密密钥生成算法 R e K e y G e n ( P K , S K S , ( M ′ , ρ ′ ) ) ：授权用户DU根据系统公钥PK，用户自己私钥 S K S 和另一个访问结构 ( M ′ , ρ ′ ) ，生成重加密密钥 R K S → ( M ′ , ρ ′ ) 并发送给云服务器代理商Proxy。注意：其中访问结构 ( M , ρ ) 和访问结构 ( M ′ , ρ ′ ) 是不相交的。 6) 重加密算法 R e E n c ( P K , R K S → ( M ′ , ρ ′ ) , C T ( M , ρ ) ) ：云服务代理商Proxy根据系统公钥PK，重加密密文组件 R K S → ( M ′ , ρ ′ ) ，加密初始密文 C T ( M , ρ ) 得到重加密密文 C S → ( M ′ , ρ ′ ) 和验证标识 V K m 并发送给解密云服务商D-CSP。 7) 重加密验证算法 R e E n c V e r i f y ( P K , δ , C 6 , C 7 ) ：授权用户DU输入系统公钥PK，群元素 δ ，重加密密钥组件 ( C 6 , C 7 ) ，验证重加密密文是否被云服务代理商Proxy正确加密。 8) 解密算法 D e c r y p t a) 初始密文解密算法Dec 1 · 转换密文生成算法 T r a n s f o r m o u t ( P K , D T K S , C ( M , ρ ) ) ：解密云服务商D-CSP输入系统公钥 P K ，外包密钥 D T K S 和初始密文 C ( M , ρ ) ，系统首先检验外包密钥 D T K S 中的属性集合 S 是否满足 C ( M , ρ ) 中的访问结构 ( M , ρ ) ，若满足，则预解密初始密文 C ( M , ρ ) 得到外包解密转换密文 T C 并发送给授权用户DU。否则，输出 ⊥ ，终止操作。 · 转换密文解密 D e c r y p t o u t ( P K , K e y , T C , V K m ) ：授权用户DU执行，输入解密密钥 K e y 、来自解密云服务商的外包解密转换密文 T C 、验证标识 V K m ，解密并对结果进行验证，验证正确得到明文 m 。否则，输出 ⊥ 。 b) 重加密密文解密算法Dec 2 · 转换密文生成算法 T r a n s f o r m o u t ( P K , D T K S ′ , C S → ( M ′ , ρ ′ ) ) ：解密云服务商D-CSP输入系统公钥 P K ，外包密钥 D T K S ′ 和重加密密文 C S → ( M ′ , ρ ′ ) ，系统首先检验外包密钥 D T K S ′ 中的属性集合 S ′ 是否满足 C S → ( M ′ , ρ ′ ) 中的访问结构 ( M ′ , ρ ′ ) ，若满足，则预解密重加密密文 C S → ( M ′ , ρ ′ ) 得到外包解密转换密文 T C ′ 并发送给被授权用户DU。否则，输出 ⊥ ，终止操作。 · 转换密文解密 D e c r y p t o u t ( P K , K e y ′ , T C ′ , V K m ) ：被授权用户DU执行，输入解密密钥 K e y ′ 、来自解密云服务商的外包解密转换密文 T C ′ 、验证标识 V K m ，解密并对结果进行验证，验证正确得到明文m。否则，输出 ⊥ 。  选择性选择明文攻击(selective chosen plaintext attack, s-CPA)安全博弈游戏：一个VF-OO-ABPRE方案是s-CPA安全的，则没有一个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势赢得下面的博弈。定义 C 为挑战者， λ 为系统安全参数， U 为属性全集。博弈游戏如下： 初始化阶段 I n i t A 选择一个挑战的访问结构 ( M * , ρ * ) 。 系统建立阶段 S e t u p C 运行系统初始化算法 S e t u p ( 1 λ , U ) 得到系统主密钥 M S K 和系统公钥 P K ，输出系统公钥 P K 给 A ，自己保留主密钥 M S K 。 查询阶段1 P h a s e   1 A 可以重复向预言机进行如下查询： 1) 私钥查询 O s k ( S ) ： A 提交一个属性集合S，该属性集合S不满足挑战访问结构 ( M * , ρ * ) ， C 运行私钥生成算法 K e y G e n ( P K , M S K , S ) 和外包密钥生成算法 K e y G e n o u t ( S , S K S ) ，并返回私钥 S K S 和外包密钥 D T K S 给 A 。 2) 重加密密钥查询 O r k ( S , ( M ′ , ρ ′ ) ) ： A 提交一个属性集合S，该属性集合S不满足挑战访问结构 ( M * , ρ * ) ，满足访问结构 ( M ′ , ρ ′ ) ， C 运行重加密密钥生成算法 R e K e y G e n ( P K , S K S , ( M ′ , ρ ′ ) ) 返回 R K S → ( M ′ , ρ ′ ) 给 A 。其中 S K S 由算法 K e y G e n ( P K , M S K , S ) 生成。 挑战阶段 C h a l l e n g e A 输出两个相同长度的消息 m 0 和 m 1 给 C 。 C 随机选择 b ∈ { 0 , 1 } 并运行加密算法 O n l i n e . E n c ( P K , m b , I C H * , T K * , ( M * , ρ * ) ) 得到挑战密文 C b 给 A 。其中 O f f l i n e . E n c ( P K , P ) → ( T K * , I C H * ) 。 查询阶段2 P h a s e   2 A 继续查询阶段1中的查询。 猜测阶段 G u e s s A 输出一个猜测 b ′ ∈ { 0 , 1 } 。如果 b ′ = b ，则 A 获胜。 A 获胜的优势被定义为： ε 1 = A d v A s − C P A ( λ ) = | P r [ b ′ = b ] − 1 2 | 。 定义3.1 一个VF-OO-ABPRE方案是s-CPA安全的，则没有一个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势赢得上面的博弈，即 ε 1 ≤ n e g l ( λ ) 。 可验证博弈游戏：可验证主要是确保外包解密阶段的转换密文是否被正确执行。一个VF-OO-ABPRE方案具有可验证性，则没有一个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势赢得下面的博弈。定义 C 为挑战者， λ 为系统安全参数， U 为属性全集。博弈游戏如下： 系统建立阶段 S e t u p C 运行系统初始化算法 S e t u p ( 1 λ , U ) 得到系统主密钥 M S K 和系统公钥 P K ，输出系统公钥 P K 给 A ，自己保留主密钥 M S K 。 查询阶段1 P h a s e   1 A 可以重复向预言机进行如下查询： 1) 私钥查询 O s k ( S ) ： A 提交一个属性集合S，该属性集合S不满足挑战访问结构 ( M * , ρ * ) ， C 运行私钥生成算法 K e y G e n ( P K , M S K , S ) 和外包密钥生成算法 K e y G e n o u t ( S , S K S ) ，并返回私钥SK S 和外包密钥 D T K S 给 A 。 2) 重加密密钥查询 O r k ( S , ( M ′ , ρ ′ ) ) ： A 提交一个属性集合S，该属性集合S不满足挑战访问结构 ( M * , ρ * ) ，满足访问结构 ( M ′ , ρ ′ ) ， C 运行重加密密钥生成算法 R e K e y G e n ( P K , S , S K S , ( M ′ , ρ ′ ) ) 返回 R K S → ( M ′ , ρ ′ ) 给 A 。其中SK S 由算法 K e y G e n ( P K , M S K , S ) 生成。 挑战阶段 C h a l l e n g e A 输出两个相同长度的消息 m 0 和 m 1 以及一个挑战访问结构 ( M * , ρ * ) 给 C 。 C 随机选择 b ∈ { 0 , 1 } 并运行加密算法 O n l i n e . E n c ( P K , m b , I C H * , T K * , ( M * , ρ * ) ) 得到挑战密文 C b 给 A 。其中 O f f l i n e . E n c ( P K , P ) → ( T K ∗ , I C H ∗ ) 。 查询阶段2 P h a s e   2 C 按照查询阶段1的方式响应 A 的询问。但是 A 不能询问满足访问结构 ( M * , ρ * ) 的属性集合S。 猜测阶段 G u e s s A 输出满足挑战访问结构 ( M * , ρ * ) 的属性集合 S * 和满足属性集合 S * 的外包解密转换密文 T C * 。若能成功恢复出明文 m b ，则 A 获胜。 A 获胜的优势为 ε 2 = A d v A V e r . ( λ ) = | P r [ A Wins ] | 。 定义3.2 一个VF-OO-ABPRE方案具有可验证性，则没有一个敌手 A 能在概率多项式时间 ( P P T ) 内以不可忽略的优势赢得上面的博弈，即 ε 2 ≤ n e g l ( λ ) 。 抗共谋攻击博弈游戏：一个VF-OO-ABPRE方案是抗共谋攻击的。则没有一个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势赢得下面的博弈。定义 C 为挑战者， λ 为系统安全参数， U 为属性全集。博弈游戏如下： 系统建立阶段 S e t u p C 运行系统初始化算法 S e t u p ( 1 λ , U ) 得到系统主密钥 M S K 和系统公钥 P K ，输出系统公钥 P K 给 A ，自己保留主密钥 M S K 。 查询阶段Phase重加密密钥查询 O r k ( S * , ( M ′ , ρ ′ ) ) ： A 提交一个属性集合 S * ⊆ U ，该属性集合 S * 不满足访问结构 ( M ′ , ρ ′ ) ，如果 S * 从未被询问过， C 首先运行 K e y G e n ( P K , M K , S * ) 生成 S K S * ，运行重加密密钥生成算法 R e K e y G e n ( P K , S * , S K S * , ( M ′ , ρ ′ ) ) 并返回 R K S * → ( M ′ , ρ ′ ) 给 A 。同时运行 K e y G e n ( P K , M K , S ′ ) 得到 S K S ' 发送给 A ，其中 S K S ' 满足访问结构 ( M ′ , ρ ′ ) 。 挑战阶段 C h a l l e n g e 最后， A 提交一个密钥 S K S ' ' ，如果 S K S ″ = S K S * 则 A 赢得游戏。 A 赢得游戏的优势为 ε 3 = A d v A C R ( λ ) = | P r [ S K S ″ = S K S * ] − 1 2 | 。 定义3.3 一个VF-OO-ABPRE方案是抗共谋攻击的。则没有一个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势赢得上面的博弈，即 ε 3 ≤ n e g l ( λ ) 。"
"1) 系统初始化算法 S e t u p ( 1 λ , U ) 该算法由AA执行。AA输入安全参数 λ ∈ ℕ 和属性全集 U = { 1 , 2 , ⋯ , n } ⊂ ℤ p * ，选择一个 p 阶的乘法循环群 Γ ，生成元为 g ， g 1 , h 1 , ⋯ , h n ∈ G 为随机群元素。另一个 p 阶的乘法循环群为 Γ T ， e ( g , g ) ⊂ Γ T ，选择两个随机数 α , a ∈ ℤ p * ，定义抗碰撞杂凑函数 H 0 : { 0 , 1 } * → ℤ p ， H 1 : { 0 , 1 } * → { 0 , 1 } λ ， H 2 : { 0 , 1 } 2 λ → { 0 , 1 } * 。最后生成系统公钥 P K = ( p , g , e ( g , g ) α , g a , g 1 , h 1 , ⋯ , h n , H 0 , H 1 , H 2 ) ，主密钥 M S K = ( g α ) ，可信机构将 M S K = ( g α ) 作为主密钥保存起来。 2) 密钥生成算法 K e y G e n ( P K , M S K , S ) 该算法由AA执行。输入系统公钥 P K ，主密钥 M S K 和属性集 S ⊆ U ，AA随机选择 t ∈ ℤ p ，对于所有的 i ∈ S ，计算 K = g α g a t ， L = g t ， { K i = h i t } i ∈ S ，最后输出用户私钥 S K S = ( S , K , L , { K i } i ∈ S ) 通过安全通道发给用户。 3) 外包密钥生成算法 K e y G e n o u t ( S , S K S ) 该算法由解密用户DU执行，输入用户私钥 S K S ，随机选择 z ∈ ℤ p ，满足 g c d ( z , p ) = 1 ，计算 K t k = K ( 1 / z ) ， L t k = L ( 1 / z ) ， { K i , t k = K i ( 1 / z ) } i ∈ S 。输出解密密钥 K e y = z 用户秘密保存，外包密钥 D T K S = ( S , K t k , L t k , { K i , t k } i ∈ S ) 通过安全通道发给解密云服务商D-CSP。 4) 加密算法 E n c r y p t 加密算法分为两个阶段，由数据拥有者DO在闲时执行的离线加密算法 O f f l i n e . E n c 和真正加密阶段执行的在线加密算法 O n l i n e . E n c 。 a) 离线加密算法 O f f l i n e . E n c ( P K , P ) 。该阶段算法由数据拥有者DO执行，利用文献 [ 12 ] 的“pooling”思想，输入系统公钥 P K ，用户根据自己需求假设最大可能的属性集合 P ⊆ U 。对于每一个 i ∈ P ，随机选取 λ i , 1 , s i ∈ ℤ p ，计算 { C 2 , i = g a λ i , 1 h i − s i , C 3 , i = g s i } i ∈ P 作为密文组件，输出中间密文 I C H = ( { C 2 , i , C 3 , i } i ∈ P ) ，可将其上传至存储云服务商S-CSP以节省本地存储资源。将临时密钥 T K = { λ i , 1 } i ∈ P 保存在本地。 b) 在线加密算法 O n l i n e . E n c ( P K , m , I C H , T K , ( M , ρ ) ) ：该阶段算法由数据拥有者DO执行。输入系统公钥 P K ，明文信息 m ∈ { 0 , 1 } λ ，中间密文 I C H ，临时密钥 T K ，以及属性 S 满足的访问结构 A = ( M , ρ ) (其中 M 是一个 l × n 的矩阵， ρ ( ⋅ ) 是一个单射函数可以把矩阵 M 的每一行映射成一个属性值)。从“pooling”中随机选取 l 个 I C H ，随机选择 W ∈ G ，并计算 s = H 0 ( W , m ) ，取随机数 y 2 , ⋅ ⋅ ⋅ , y n ∈ ℤ p ，向量 v = ( s , y 2 , ⋅ ⋅ ⋅ , y n ) ∈ ℤ p n ， M j 表示矩阵 M 的第 j 行，计算 λ j = { M j v T } j ∈ { 1 , ⋯ , l ) 。对于任意 j ∈ { 1 , ⋯ , l } ，计算密文组件得： C = W ⋅ e ( g , g ) α s , C 1 = g s , C 2 , j = C 2 , ρ ( j ) , C 3 , j = C 3 , ρ ( j ) , C 4 , j = λ j − λ j , 1 , k = H 1 ( W ) , C 5 = k ⊕ m , C 6 = g H 1 ( e ( g , g ) α s ) , V K m = H 2 ( k ‖ C 5 ) 最后输出密文初始密文 C ( M , ρ ) = ( C , C 1 , { C 2 , j , C 3 , j , C 4 , j } j ∈ { 1 , ⋯ , l ) , C 5 , C 6 ) 和验证标识 V K m = H 2 ( k ‖ C 5 ) 发送给存储云服务商S-CSP进行存储。 5) 重加密密钥生成算法 R e K e y G e n ( P K , S K S , ( M ′ , ρ ′ ) ) 该算法由授权用户DU执行。假设授权用户A满足访问结构 A = ( M , ρ ) ，用户A运行重加密密钥生成算法 R e K e y G e n ，输入系统公钥 P K 、和用户A的私钥 S K S ，新的访问结构 A ′ = ( M ′ , ρ ′ ) (其中 M ′ 是一个 l ′ × n ′ 的矩阵， ρ ′ ( ⋅ ) 是一个单射函数可以把矩阵 M ′ 的每一行映射成一个属性值，且属性集合 S ′ 满足 A ′ = ( M ′ , ρ ′ ) )。随机选择 δ ∈ G ， s ′ ∈ ℤ p * ，其中 s ′ 是共享的秘密值。取随机数 y ′ 2 , ⋅ ⋅ ⋅ , y ′ n ∈ ℤ p ，向量 v ′ = ( s ′ , y ′ 2 , ⋅ ⋅ ⋅ , y ′ n ) ， M ′ j 表示矩阵 M ′ 的第 j 行， λ ′ j = { M ′ j v ′ T } j ∈ { 1 , ⋯ , l ′ } 。首先，随机选取 λ ′ j , 1 , s ′ j ∈ ℤ p ，对于 j ∈ { 1 , ⋯ , l ′ } ，计算密文组件： C ′ = δ ⋅ e ( g , g ) α s ′ , C ′ 1 = g s ′ , C ′ 2 , j = g a λ ′ j , 1 h ρ ′ ( j ) − s ′ j , C ′ 3 , j = g s ′ j , C ′ 4 , j = λ ′ j − λ ′ j , 1 记 C ( M ′ , ρ ′ ) = ( C ′ , C ′ 1 , { C ′ 2 , j , C ′ 3 , j , C ′ 4 , j } j ∈ { 1 , ⋯ , l ′ } ) 。随机选择 θ ∈ ℤ p ，并计算 r k 1 = K H 1 ( δ ) ⋅ g 1 θ ， r k 2 = g 1 θ ， r k 3 = L H 1 ( δ ) ，对于所有的 j ∈ { 1 , ⋯ , l ′ } ， r k 4 = C ( M ′ , ρ ′ ) ， r k j = K j H 1 ( δ ) ，最后输出重加密密钥 R K S → ( M ′ , ρ ′ ) = ( S , r k 1 , r k 2 , r k 3 , r k 4 , r k j ) 发送给Proxy。 6) 重加密算法 R e E n c ( P K , R K S → ( M ′ , ρ ′ ) , C T ( M , ρ ) ) 该算法由Proxy执行。Proxy收到重加密密钥 R K S → ( M ′ , ρ ′ ) 后，运行重加密算法 R e E n c r y p t ，输入系统公钥 P K ，重加密密钥 R K S → ( M ′ , ρ ′ ) 和初始密文 C ( M , ρ ) 。若 C ( M , ρ ) 与访问结构 A = ( M , ρ ) 有关，且属性集 S 满足访问结构 A ，则定义 I ⊂ { 1 , ⋯ , l } 为 I = { j : ρ ( j ) ∈ S } ， { λ j } 是根据矩阵 M 对秘密 s 的有效共享，存在一个常数集 { ω j ∈ ℤ p } j ∈ I ，使得 ∑ j ∈ I ω j ⋅ λ j = s 。计算： C 7 = e ( C 1 , r k 1 ) / e ( C 1 , r k 2 ) ∏ j ∈ I ( e ( C 2 , j ⋅ g a ⋅ C 4 , j , r k 3 ) ⋅ e ( C 3 , j , r k ρ ( j ) ) ) ω j = e ( g , g ) α s H 1 ( δ ) ， 最后输出重加密密文 C S → ( M ′ , ρ ′ ) = ( ( M ′ , ρ ′ ) , C , C 5 , C 6 , C 7 , r k 4 ) 和验证标识 V K m 发送给解密云服务商D-CSP。 7) 重加密验证算法 R e E n c V e r i f y ( P K , δ , C 6 , C 7 ) 该阶段由授权用户 D U 执行。验证重加密密文是否被云服务代理商Proxy正确加密时， δ 对授权用户DU是已知的，输入来自云服务器Proxy的 C 7 ，计算 V = ( C 7 ) H 1 ( δ ) − 1 ，若 C 6 = g H 1 ( V ) ，则说明代理商Proxy重加密计算结果正确，输出 T r u e ，否则输出终止符 ⊥ 。 8) 解密算法 D e c r y p t 解密算法包含了对初始密文的解密算法 D e c 1 和对重加密密文的解密算法 D e c 2 。二者均包含了由外包云服务器D-CSP提供的外包解密转换密文生成算法 T r a n s f o r m o u t 和用户端提供的转换密文解密 D e c r y p t o u t 。 a) 初始密文解密算法Dec 1 · 转换密文生成算法 T r a n s f o r m o u t ( P K , D T K S , C ( M , ρ ) ) ：该阶段由解密云服务商D-CSP执行。若用户属性集 S 不满足访问结构 A = ( M , ρ ) ，则输出 ⊥ 。若 C ( M , ρ ) 与访问结构 A 有关，授权人外包密钥 D T K S = ( S , K t k , L t k , { K i , t k } i ∈ S ) 与用户属性集 S 相关，且用户属性集 S 满足访问结构 A ，则定义 I ⊂ { 1 , ⋯ , l } 为 I = { j : ρ ( j ) ∈ S } ， { λ j } 是根据矩阵 M 对秘密 s 的有效共享，存在一个常数集 { ω j ∈ ℤ p } j ∈ I ，使得 ∑ j ∈ I ω j ⋅ λ j = s 。计算： C T p a r t = e ( C 1 , K t k ) ∏ j ∈ I ( e ( C 2 , j ⋅ g a ⋅ C 4 , j , L t k ) ⋅ e ( C 3 , j , K ρ ( j ) , t k ) ) ω j = e ( g , g ) α s / z 将外包解密转换密文 T C = ( C , C T p a r t , C 5 ) 发送给用户。 · 转换密文解密 D e c r y p t o u t ( P K , K e y , T C , V K m ) ：该阶段由授权用户DU执行，输入解密密钥 K e y = z 、来自解密云服务商的外包解密转换密文 T C 、验证标识 V K m ，计算 W = C / C T p a r t K e y ， k = H 1 ( W ) 。若 V K m ≠ H 2 ( k ‖ C 5 ) ，则输出终止符 ⊥ ；否则计算 m = C 5 ⊕ k ， s = H 0 ( W , m ) 。若 C = W ⋅ e ( g , g ) α s ， C T p a r t = e ( g , g ) α s / z ，输出 m ；否则输出终止符 ⊥ 。 b) 重加密密文解密算法Dec 2 · 转换密文生成算法 T r a n s f o r m o u t ( P K , D T K S ′ , C S → ( M ′ , ρ ′ ) ) ：该阶段由解密云服务商S-CSP执行。若用户属性集 S ′ 不满足访问结构 A ′ = ( M ′ , ρ ′ ) ，则输出 ⊥ 。若 C S → ( M ′ , ρ ′ ) 与访问结构 A ′ 有关，被授权人外包密钥 D T K S ′ = ( S , K ′ t k , L ′ t k , { K ′ i , t k } i ∈ S ) 与用户属性集 S ′ 相关，且用户属性集 S ′ 满足访问结构 A ′ ，则定义 I ′ ⊂ { 1 , ⋯ , l ′ } 为 I ′ = { j : ρ ′ ( j ) ∈ S ′ } ， { λ ′ j } 是根据矩阵 M ′ 对秘密 s ′ 的有效共享，存在一个常数集 { ω ′ j ∈ ℤ p } j ∈ I ′ ，使得 ∑ j ∈ I ′ ω j ⋅ λ j = s ′ 。计算： C T ′ p a r t = e ( C ′ 1 , K ′ t k ) ∏ j ∈ I ′ ( e ( C ′ 2 , j ⋅ g a ⋅ C ′ 4 , j , L ′ t k ) ⋅ e ( C ′ 3 , j , K ′ ρ ′ ( j ) , t k ) ) ω ′ j = e ( g , g ) α s ′ / z ′ 将 T C ′ = ( C , C ′ , C T ′ p a r t , C 5 , C 7 ) 发送给用户。 · 转换密文解密 D e c r y p t o u t ( P K , K e y ′ , T C ′ , V K m ) ：该阶段由被授权用户DU执行，输入解密密钥 K e y ′ = z ′ 、来自解密云服务商的外包解密转换密文 T C ′ 、验证标识 V K m ，计算 δ = C ′ / C T ′ p a r t K e y ′ ， W = C / ( C 7 ) H 1 ( δ ) ， k = H 1 ( W ) 。若 V K m ≠ H 2 ( k ‖ C 5 ) ，则输出终止符 ⊥ ；否则计算 m = C 5 ⊕ k ， s = H 0 ( W , m ) 。若 C = W ⋅ e ( g , g ) α s ， C T ′ p a r t = e ( g , g ) α s ′ / z ′ ，输出 m ；否则输出终止符 ⊥ 。  1) 原始密文的解密正确性。如果用户属性集 S 满足访问结构 A ，存在 ∑ j ∈ I ω j ⋅ λ j = s 。则计算： C T p a r t = e ( C 1 , K t k ) ∏ j ∈ I ( e ( C 2 , j ⋅ g a ⋅ C 4 , j , L t k ) ⋅ e ( C 3 , j , K ρ ( j ) , t k ) ) ω j = e ( g s , ( g α g a t ) 1 / z ) ∏ j ∈ I ( e ( g a λ j , 1 h ρ ( j ) − s j ⋅ g a ⋅ ( λ j − λ j , 1 ) , g t / z ) ⋅ e ( g s j , h ρ ( j ) t / z ) ) ω j = e ( g s , ( g α g a t ) 1 / z ) ∏ j ∈ I ( e ( g a λ j h ρ ( j ) − s j , g t / z ) ⋅ e ( g s j , h ρ ( j ) t / z ) ) ω j = e ( g , g ) α s / z ⋅ e ( g , g ) a t s / z e ( g , g ) a t / z ∑ j ∈ I λ j ω j = e ( g , g ) α s / z 接着计算 C C T p a r t K ey = W ⋅ e ( g , g ) α s ( e ( g , g ) α s / z ) z = W ， k = H 1 ( W ) ， k ⊕ C 5 = k ⊕ k ⊕ m = m 得到明文。 2) 重加密密文的解密正确性。如果用户属性集 S ′ 满足访问结构 A ′ = ( M ′ , ρ ′ ) ，存在 ∑ j ∈ I ′ ω ′ j ⋅ λ ′ j = s ′ 。先计算重加密密文组件 C 7 ，计算得： C 7 = e ( C 1 , r k 1 ) / e ( C 1 , r k 2 ) ∏ j ∈ I ( e ( C 2 , j ⋅ g a ⋅ C 4 , j , r k 3 ) ⋅ e ( C 3 , j , r k j ) ) ω j = e ( g s , ( g α g a t ) H 1 ( δ ) ⋅ g 1 θ ) / e ( g s , g 1 θ ) ∏ j ∈ I ( e ( g a λ j , 1 h ρ ( j ) − s j ⋅ g a ⋅ ( λ j − λ j , 1 ) , ( g t ) H 1 ( δ ) ) ⋅ e ( g s j , ( h ρ ' ( j ) t ) H 1 ( δ ) ) ) ω j = e ( g , g ) s α H 1 ( δ ) e ( g , g ) s a t H 1 ( δ ) ∏ j ∈ I ( e ( g a λ j h ρ ( j ) − s j , ( g t ) H 1 ( δ ) ) ⋅ e ( g s j , ( h ρ ( j ) t ) H 1 ( δ ) ) ) ω j = e ( g , g ) s α H 1 ( δ ) e ( g , g ) s a t H 1 ( δ ) e ( g , g ) a t / H 1 ( δ ) ∑ j ∈ I λ j ω j = e ( g , g ) s α H 1 ( δ ) 同样的，按照 C T p a r t 的计算方法，可以计算出 C T ′ p a r t = e ( g , g ) α s ′ / z ′ ，综合以上结果，接着计算 C ′ / C T ′ p a r t K e y ′ = δ ⋅ e ( g , g ) α s ′ / ( e ( g , g ) α s ′ / z ′ ) z ′ = δ ， C / ( C 7 ) H 1 ( δ ) − 1 = W ⋅ e ( g , g ) α s / ( e ( g , g ) s α ⋅ H 1 ( δ ) ) H 1 ( δ ) − 1 = W ， k = H 1 ( W ) ， k ⊕ C 5 = k ⊕ k ⊕ m = m 得到明文。"
"定理1. 如果判定性q-parallel BDHE假设成立，那么VF-OO-ABPRE方案是随机预言机模型下s-CPA安全的。 证明 假设存在某个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势攻破本文提出的方案，那么可以构造仿真者 B 在概率多项式时间(PPT)内以不可忽略的优势解决判定性q-parallel BDHE假设困难问题。 I n i t A 选择一个挑战的访问结构 ( M * , ρ * ) 发送给 B 。 B 输入判定性q-parallel BDHE假设挑战元组 ( p , G , G T , Z , Y ) ，其中， Z 为群 Γ T 中的随机元素 R ∈ G T 或者 e ( g , g ) a q + 1 s ∈ G T ， Y = g , g s , g a , · · · , g a q , g a q + 2 , ⋅ ⋅ ⋅ , g a 2 q ， ∀ 1 ≤ j ≤ q , g s ⋅ b j , g a / b j , · · · , g a q / b j , g a q + 2 / b j , ⋅ ⋅ ⋅ , g a 2 q / b j ， ∀ 1 ≤ j , k ≤ q , k ≠ j , g a ⋅ s ⋅ b k / b j , ⋅ ⋅ ⋅ , g a q ⋅ s ⋅ b k / b j 。 S e t u p B 运行系统初始化算法 S e t u p ( 1 λ , U ) → ( P K , M S K ) ，随机选择 α ′ ∈ ℤ p ，使得 α = α ′ + a q + 1 。在此阶段 B 不知道 α 的值，但是可计算 e ( g , g ) α = e ( g a , g a q ) e ( g , g ) α ′ 。对于任意 x ∈ U ，随机选取 z x ∈ ℤ p ，当 ρ * ( i ) = x ， B 计算 h x = g z x ⋅ g a M i , 1 ∗ / b i ⋅ g a 2 M i , 2 ∗ / b i ⋯ g a n ∗ M i , n ∗ ∗ / b i ，否则计算 h x = g z x 。输出 P K = ( p , g , e ( g , g ) α , g a , g 1 , h 1 , ⋯ , h n , H 0 , H 1 , H 2 ) 给 A 。 P h a s e   1 B 初始化空表 T 0 ， T 1 ， T 2 ， A 可重复进行以下查询： 1) H 0 ( W , m ) ：若表 T 0 中已经存在 ( W , m , s ) ，则返回 s ；否则选取一个随机值 s ∈ ℤ p ，并将 ( W , m , s ) 记录在表 T 0 中，返回 s 。 2) H 1 ( W ) ：若表 T 1 中已经存在 ( W , k ) ，则返回 k ；否则选取一个随机值 k ∈ { 0 , 1 } λ ，并将 ( W , k ) 记录在表 T 1 中，返回 k 。 3) 私钥查询 O s k ( S ) ： A 可重复发出查询请求。输入属性集 S ， B 做出如下回应： a) 属性集合 S | ≠ ( M * , ρ * ) 时， B 选择向量 w = ( w 1 , w 2 , ⋯ , w n * ) ∈ ℤ p n * ，其中 w 1 = − 1 ，对于所有的 i 满足 ρ * ( i ) ∈ S 时， M i * ⋅ w = 0 。随机选取 r ∈ ℤ p ，定义 t = r + w 1 a q + w 2 a q − 1 + ⋯ + w n * a q − n * + 1 。计算 L = g r ∏ i = 1 , ⋯ , n * ( g a q + 1 − i ) w i = g t ， K = g α ′ g a r ∏ i = 2 , ⋯ , n * ( g a q + 2 − i ) w i = g α g a t 。对于 ρ * ( i ) = x ，计算 K x = L z x ∏ j = 1 , ⋯ , n ∗ ( g ( a j / b i ) ⋅ r ∏ k = 1 , ⋯ , n ∗ k ≠ j ( g a q + 1 + j − k / b i ) w k ) M i , j ∗ ，其余情况则计算 K x = L z x = h x t 。用户私钥 S K S = ( S , K , L , { K x } x ∈ S ) 。随机选取 z ∈ ℤ p 作为解密密钥。计算外包密钥得 D T K S = ( K ( 1 / z ) , L ( 1 / z ) , K x ( 1 / z ) ) 。将元组 ( S , S K S , D T K S ) 记录在表 T 2 中，发送 D T K S 给 A 。 b) 属性集合 S | = ( M * , ρ * ) 时，无法查询 S 对应的私钥。按如下方法选择一个“伪”外包密钥： B 随机选取 d ∈ ℤ p * ，运行 K e y G e n ( P K , d , S ) 生成密钥 S K ′ S ，令 D T K S = S K ′ S ， S K S = ( d , D T K S ) ，将元组 ( S , S K S , D T K S ) 记录在表 T 2 中，发送 D T K S 给 A 。 4) 重加密密钥查询 O r k ( S , ( M ′ , ρ ′ ) ) ： A 输入属性集 S 和访问结构 ( M ′ , ρ ′ ) ，若 S | ≠ ( M * , ρ * ) 时， B 运行重加密密钥生成算法 R e K e y G e n ( P K , S , S K S , ( M ′ , ρ ′ ) ) → R K S → ( M ′ , ρ ′ ) 返回 R K S → ( M ′ , ρ ′ ) 给 A 。其中 S K S 由算法 K e y G e n ( P K , M S K , S ) → S K S 生成。 C h a l l e n g e A 向 B 输出两个相同长度的消息 m 0 和 m 1 ， B 执行如下计算： 1) 随机选择 W ∈ G T ， b ∈ { 0 , 1 } ， k * ∈ ℤ p ， C 6 * ∈ G 计算得到部分密文 C b p a r t = ( C * , C 1 * , C 5 * , C 6 * ) 得： C * = W ⋅ Z ⋅ e ( g α ′ , g s ) ， C 1 * = g s ， C 5 * = k * ⊕ m b ， C 6 * = C 6 * ； 2) 随机选择 ，计算 v = ( s , s a + c 2 , s a 2 + c 3 , ⋯ , s a n * − 1 + c n * ) ，对于 i ∈ { 1 , ⋯ , l * } ， M i * 表示矩阵 M * 的第 i 行， λ i * = { M i * v T } i ∈ I ，随机选择 s i ∗ ∈ ℤ p ，对于 i = { 1 , ⋯ , l * } ，定义 R i 表示 k ≠ i 且 ρ * ( i ) = ρ * ( k ) 时的集合。计算： C 2 , i ∗ = h ρ ∗ ( i ) s i ∗ ( ∏ j = 2 , ⋯ , n ∗ ( g a ) M i , j ∗ c j ) ( g b i ⋅ s ) − z ρ ∗ ( i ) ⋅ ( ∏ k ∈ R i ∏ j = 1 , ⋯ , n ∗ ( g a i ⋅ s ⋅ ( b i / b k ) ) M k , j ∗ ) , C 3 , i ∗ = g − s i ∗ g − s b i 3) B 将挑战密文 C b = ( C * , C 1 * , { C 2 , i * , C 3 , i * , C 4 , i * } i ∈ { 1 , ⋯ , l * } , C 5 * , C 6 * ) 发送给 A 。 P h a s e   2 A 继续查询阶段1中的查询，但是不能查询任何属性集 S 满足 ( M * , ρ * ) 。 G u e s s A 输出一个猜测 b ′ ∈ { 0 , 1 } 。若仿真者 B 认为 b ′ = b ，则猜测 Z = e ( g , g ) a q + 1 s ，否则，猜测 Z 是群 G T 的随机元素。如果 Z = e ( g , g ) a q + 1 s ，仿真者 B 赢得该游戏的概率是： P r [ B ( Y , Z = e ( g , g ) a q + 1 s ) = 1 ) = 1 2 + ε 。如果 Z 是群 G T 的随机元素，消息 m b 对敌手来说是隐藏的，仿真者 B 赢得该游戏的概率是： P r [ B ( Y , Z = R ) = 1 ) = 1 2 。因此，挑战者在解决判定性q-parallel BDHE假设问题上具有不容忽视的优势： A d v B q − B D H E = P r [ B ( Y , Z = e ( g , g ) a q + 1 s ) = 1 ] − P r [ B ( Y , Z = R ) = 1 ] = ε 。 这与判定性q-parallel BDHE假设成立矛盾，所以定理1得证。证毕 定理2. 假设 H 1 , H 2 是抗碰撞的杂凑函数，那么VF-OO-ABPRE方案具有可验证性。 证明 假设存在敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势攻破可验证性，那么可以构建一个仿真者 B 打破底层杂凑函数 H 1 , H 2 的抗碰撞能力。 A 提交2个挑战杂凑函数 H 1 * , H 2 * ， B 进行如下的仿真实验过程： S e t u p B 执行 S e t u p 算法获取系统公钥 P K 和主密钥 M S K ，并用 H 1 * , H 2 * 替换 P K 中的 H 1 , H 2 。注： B 知道主密钥 M S K 。 P h a s e   1 A 可以重复向预言机进行如下查询： 1) 私钥查询 O s k ( S ) ： A 提交一个属性集合 S ，该属性集合 S 不满足挑战访问结构 ( M * , ρ * ) ， C 运行私钥生成算法 K e y G e n ( P K , M S K , S ) 和外包密钥生成算法 K e y G e n o u t ( S , S K S ) ，并返回私钥 S K S 和外包密钥 D T K S 给 A 。 2) 重加密密钥查询 O r k ( S , ( M ′ , ρ ′ ) ) ： A 提交一个属性集合 S ，该属性集合 S 不满足挑战访问结构 ( M * , ρ * ) ，满足访问结构 ( M ′ , ρ ′ ) ， C 运行重加密密钥生成算法 R e K e y G e n ( P K , S , S K S , ( M ′ , ρ ′ ) ) 返回 R K S → ( M ′ , ρ ′ ) 给 A 。其中 S K S 由算法 K e y G e n ( P K , M S K , S ) 生成。 C h a l l e n g e A 提交两个相同长度的消息 m 0 和 m 1 以及一个挑战的访问结构 ( M * , ρ * ) 给 B 。 B 随机选择 b ∈ { 0 , 1 } ， W * ∈ G T ，并计算 C T W * = ( C , C 1 , { C 2 , i , C 3 , i , C 4 , i } 1 ≤ i ≤ l ) ， k * = H 1 * ( W * ) ， C 5 * = k * ⊕ m b ， V K m b * = H 2 * ( k * ‖ C 5 * ) 。 B 将 C ( M * , ρ * ) * = ( C T W * , C 5 * ) 和 V K m b * 发送给 A 。同时自己保留 V K m b * 和 ( W * , C 5 * ) 。 P h a s e   2 B 按照查询阶段1的方式响应 A 的询问。但是 A 不能询问满足访问结构 ( M * , ρ * ) 的属性集合 S 。 G u e s s A 输出属性集合 S * 和外包解密转换密文 T C * = ( C , C T p a r t , C 5 ) 。 若敌手 A 可攻破可验证性，那么仿真者 B 将通过转换密文解密 D e c r y p t o u t ( P K , K e y * , T C * , V K m b * ) 恢复出明文 m b 。若 V K m b * ≠ H 2 * ( k ‖ C 5 * ) ，则解密算法输出终止符 ⊥ ，其中 k = H 1 * ( W ) ， W = C / C T p a r t K e y ′ 。考虑如下情况： 情况1： ( k , C 5 ) ≠ ( k * , C 5 * ) 。因仿真者 B 知道 ( k * , C 5 * ) ，若出现此种情况，则 B 可得到杂凑函数 H 2 * 的碰撞。 情况2： ( k , C 5 ) = ( k * , C 5 * ) 。但是 W ≠ W * ，因为 H 1 * ( W ) = k = k * = H 1 * ( W * ) ，若出现此种情况，则将打破杂凑函数 H 1 * 的抗碰撞能力。 通过上述分析完成定理2的安全证明。证毕 定理3. 假定CDH假设成立，那么VF-OO-ABPRE方案是抗共谋攻击的。 证明 假设存在某个敌手 A 能在概率多项式时间(PPT)内以不可忽略的优势攻破本文提出的方案，那么可以构造仿真者 B 在概率多项式时间(PPT)内以不可忽略的优势解决CDH困难问题。 S e t u p B 运行 S e t u p ( 1 λ , U ) 算法，随机选择 h 1 , ⋯ , h | U | ∈ G ， α , a , b ∈ ℤ p ，计算 e ( g , g ) α 和 g 1 = g b ，得到系统公钥 P K = ( p , g , e ( g , g ) α , g a , g 1 , h 1 , ⋯ , h | U | , H 0 , H 1 , H 2 ) 和主密钥 M S K = g α 。 P h a s e   1 对于不满足访问结构 ( M * , ρ * ) 但是满足访问结构 ( M ′ , ρ ′ ) 的属性集合 S ′ ⊆ U ， B 运行 K e y G e n ( P K , M S K , S ′ ) → S K S ′ 生成 S K S ′ = ( S ′ , K ′ , L ′ , { K ′ i } i ∈ S ′ ) 将其发送给 A 。对于满足访问结构 ( M * , ρ * ) 的属性集合 S * ⊆ U ， B 运行 K e y G e n ( P K , M S K , S * ) → S K S * 生成 S K S * = ( S * , K * , L * , { K i * } i ∈ S * ) 由 B 自己秘密保存。对于关于 ( S * , ( M ′ , ρ ′ ) ) 的重加密密钥询问，如果 S * 从未被询问过，通过访问结构 ( M ′ , ρ ′ ) ， B 随机选择 θ * ∈ ℤ p ，计算 g θ * = δ * ∈ G ，对于 j ∈ { 1 , ⋯ , l ′ } ，计算 C ′ = δ * ⋅ e ( g , g ) α s * ， C ′ 1 = g s ′ ， C ′ 2 , j = g a λ ′ j , 1 h ρ ( j ) − s ′ j ， C ′ 3 , j = g s ′ j ， C ′ 4 , j = λ ′ j − λ ′ j , 1 ，得到 C ( M ′ , ρ ′ ) = ( C ′ , C ′ 1 , { C ′ 2 , j , C ′ 3 , j , C ′ 4 , j } j ∈ { 1 , ⋯ , l ′ } ) ， r k 1 = ( K * ) H 1 ( δ * ) ⋅ g 1 θ * ， r k 2 = g 1 θ * ， r k 3 = ( L * ) H 1 ( δ * ) ，对于所有的 j ∈ { 1 , ⋯ , l ′ } ， r k 4 = C ( M ′ , ρ ′ ) ， r k j = ( K j * ) H 1 ( δ * ) ，最后输出重加密密钥 R K S * → C ( M ′ , ρ ′ ) = ( S , r k 1 , r k 2 , r k 3 , r k 4 , r k j ) 和私钥 S K S ′ 发送给 A 。 C h a l l e n g e 最后， A 提交一个密钥 S K S ′ ，如果 S K S ″ = S K S * 则 A 赢得游戏。 注： ( M * , ρ * ) 与 ( M ′ , ρ ′ ) 是不相交的， C ( M ′ , ρ ′ ) 实际上是 δ * 在访问结构 下Waters等 [ 4 ] 方案的ABE加密， A 可以通过对应的私钥 S K S ′ 恢复得到 δ * = g θ * ，为了从重加密密钥 R K S * → ( M ′ , ρ ′ ) 中恢复 S K S * ， A 还需计算出 g 1 θ * ，已知 g θ * ， g 1 = g b ，计算 g 1 θ * = g b θ * 相当于解决CDH困难问题。证毕  本方案将与文献 [ 5 ] 中外包解密CP-ABE方案和文献 [ 13 ] 可验证外包CP-ABE方案，文献 [ 15 ] 和文献 [ 21 ] [ 22 ] [ 23 ] CP-ABPRE方案进行具体的性能分析。B表示双线性运算，E表示 G 群的指数运算， E T 表示 G T 群的指数运算，l表示访问结构 ( M , ρ ) 中矩阵M的行数，s表示用户私钥属性数量，N表示系统属性空间属性数量。 | G | 表示 G 中的元素长度， | G T | 表示 G T 中的元素长度。忽略实际运算中涉及的杂凑函数及异或运算的计算开销和存储开销。 表1展示了几种方案用户端的计算开销对比，表2展示了几种方案的私钥与密文存储空间占用对比。本文基于文献 [ 5 ] 提出VF-OO-ABPRE方案，实现了离线/在线加密且外包解密可验证的功能，减少了用户端实际加密过程中的计算开销和带宽。在原始文献 [ 5 ] 的基础上结合代理重加密，实现了密文共享功能，原始密文加密计算只消耗了4E T ，虽然原始密文解密计算多了2E T ，但是实现了可验证的功能；文献 [ 13 ] 可验证的外包解密的离线/在线ABE加密方案，虽然用户端在线加密计算只消耗了2E，但是密文解密阶段的计算量较大的双线性对的运算B消耗较多，且计算开销随属性集合的数量呈线性增长的关系。而本方案将解密计算外包，所以用户端的解密计算消耗4E T ；文献 [ 15 ] 仅支持“AND”门访问结构，表达能力有限。本方案采取离线/在线加密操作以及解密外包，将复杂的双线性运算外包给D-CSP，使得解密只需进行4个 G T 群的指数运算，重加密密钥的生成也相对应地节省了在 G 群上的指数计算开销。大大提高了计算效率，节省了带宽。对比文献 [ 21 ] [ 22 ] [ 23 ] 不同功能的属性代理重加密方案，计算开销与所占带宽的优势明显。 综合以上分析，本方案实现了离线/在线加密操作的同时，将解密外包且支持外包可验证性。离线/在线的加密操作适用于使用资源受限设备加密的用户，可以在设备插入电源时离线完成大部分加密过程，实际加密时，只需以较小的能耗就能迅速完成在线加密。理论分析表明，本方案非常适用于资源受限的移动设备。 Table 1 方案 原始密文加密 生成重加密密钥 原始密文解密 重加密密文解密 可验证性 访问结构 文献 [ 5 ] ( 1 + 2 l ) E + E T —— E T —— NO LSSS 文献 [ 13 ] 2 E —— ( 2 + 3 s ) E + ( 2 + 3 s ) B —— YES LSSS 文献 [ 15 ] ( 2 + 3 N ) E + E T ( 2 + 3 N ) E + E T ( 3 + N ) B E T + ( 3 + N ) B NO AND门 文献 [ 21 ] ( 6 + 4 N ) E + E T ( 8 + 4 N ) E + 2 E T ( 6 + 3 N ) B E T + ( 7 + 3 N ) B NO AND门 文献 [ 22 ] ( 2 + 12 N ) E + E T ( 2 + 25 N ) E + E T ( 2 + 4 N ) B ( 3 + 4 N ) B NO AND门 文献 [ 23 ] ( 2 + 2 N ) E + E T ( 3 + 4 N ) E —— E T + ( 1 + 2 N ) B NO AND门 本方案 E T ( 2 + 3 l ) E + E T 3 E T 3 E T YES LSSS 表1. 用户客户端计算开销对比 Table 2 方案 私钥 原始密文 重加密密文 文献 [ 5 ] ( 2 + s ) | G | | G T | + ( 1 + 2 l ) | G | —— 文献 [ 13 ] ( 2 + 2 s ) | G | | G T | + ( 2 + 3 l ) | G | —— 文献 [ 15 ] 2 N | G | | G T | + 2 N | G | 5 | G T | + ( 4 + N ) | G | 文献 [ 21 ] ( 2 + 4 N ) | G | 2 | G T | + ( 2 + 12 N ) | G | 3 | G T | + ( 4 + 12 N ) | G | 文献 [ 22 ] ( 7 + 3 N ) | G | 2 | G T | + ( 5 + 3 N ) | G | 4 | G T | + ( 6 + 3 N ) | G | 文献 [ 23 ] N | G T | + | G | ( 1 + N ) | G T | + ( 2 + N ) | G | ( 3 + N ) | G T | + ( 1 + N ) | G | 本方案 ( 2 + s ) | G | | G T | + ( 2 + 2 l ) | G | 3 | G T | + ( 2 + 2 l ) | G | 表2. 私钥与密文存储空间占用对比"
"本文针对CP-ABPRE加密的性能问题，提出新的离线/在线加密且可验证外包解密的VF-OO-ABPRE方案，主要将加密算法分为两个阶段，离线加密和在线加密。用户可以在插入电源时首先离线完成大部分的加密预处理计算，在线加密则可以利用离线加密的计算结果，快速高效地完成最终加密，有效地提高了CP-ABPRE案的加密性能。将解密外包，并且能验证外包计算的正确性，同时抗合谋攻击，提高了方案的安全性。有效缓解了资源受限用户的加解密负担，同时，本方案在随机预言机模型下被证明是选择明文攻击的不可区分安全的。通过对比已有方案的计算开销和存储开销，本方案在功能性和效率方面均具有明显优势，具有现实的应用价值。"
