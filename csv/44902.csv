"稀疏信号重构算法是压缩感知的关键。基于近似l 0 范数的稀疏信号重构可以通过选取一个光滑函数近似l 0 范数，从而将l 0 范数最小化问题转化为光滑函数的优化问题。为了提高压缩感知中稀疏信号重构的精度，本文提出了一种基于改进的近似l 0 范数的稀疏信号重构算法。该算法首先利用一种改进的光滑函数来近似l 0 范数；其次利用外点罚函数法和共轭梯度法求解基于该光滑函数的优化问题的稀疏解；最后进行了多项实验来验证所提出算法的有效性。实验结果表明：相比于光滑l 0 算法、基追踪算法和非凸复合稀疏基算法，本文所提算法在重构误差、信噪比和恢复成功率等方面更具优越性。"
"传统的数据采集需要满足奈奎斯特采样定理，即为了不失真的恢复信号，采样频率必须大于信号最高带宽的两倍。但在这一理论指导下所获得的信息是冗余的，极大的影响了信息领域的发展。压缩感知(Compressive Sensing, CS) [ 1 ] 是一种新型的信号采集与重构理论，它可通过远低于奈奎斯特标准的方式进行数据采样，并仍能够精确地恢复稀疏信号。该理论提出后，在阵列信号处理 [ 2 ]、医学影像 [ 3 ] 和雷达探测 [ 4 ] 等领域受到高度关注，展现出了巨大的应用价值。压缩感知理论主要包括三部分：信号的稀疏表示、测量矩阵的设计和稀疏信号重构。其中，稀疏信号重构是指从较少的测量值中精确地恢复原始信号，是CS理论中最重要的一部分。信号的重构精度主要取决于重构算法的性能，设计高效的重构算法是提高稀疏信号重构精度的关键。因此，稀疏信号重构算法具有重要的研究意义。 从数学的角度来看，通常使用以下最小化方法对稀疏信号重构问题进行建模 [ 5 ]： min x ∈ R n ‖ x ‖ 0         s .t .     A x = b (1) 其中 A ∈ R m × n ( m < n ) 是感知矩阵， b ∈ R m 是测量向量， x ∈ R n 是未知的稀疏向量， ‖ x ‖ 0 是实向量x的零范数。 然而，由于l 0 范数的不连续性，使得基于l 0 范数的重构模型的直接求解是NP (Non-deterministic Polynomial)难的 [ 6 ]，其计算量会随稀疏向量维数的增加而增大，且模型的抗噪能力较差。为此学者们提出了很多方法对最小化l 0 范数进行近似求解，如贪婪方法、凸松弛方法和非凸松弛方法等。贪婪算法通过选择与信号重构残差最匹配的原子进行信号重构，传统的贪婪算法有正交匹配追踪算法 [ 7 ]、广义正交匹配追踪算法 [ 8 ] 和子空间追踪算法 [ 9 ] 等，这类算法重构理论简单、计算速度较快，但重构精度较低，需要更多观测值。凸松弛方法将最小化l 0 范数转化为最小化l 1 范数，其中典型的算法有基追踪算法 [ 10 ]、迭代阈值算法 [ 11 ] 和梯度投影法 [ 12 ] 等，这类算法重构精度较高、所需测量值较少，但计算复杂度较高，不适合求解大规模问题。因此这两类算法应用范围有限。 近年来，利用非凸松弛方法近似求解l 0 范数受到了广泛关注。常见的非凸松弛方法使用l p 范数、高斯类函数或分式类函数近似l 0 范数，其中高斯类函数是一种最常见的近似函数。最早Mohimani等人提出了光滑l 0 (Smoothed l 0 norm, SL0)算法 [ 13 ]，该算法利用标准高斯函数近似l 0 范数，并结合最速下降法寻求最优解；随后林婉娟等人提出了利用双曲正切函数和修正牛顿法的牛顿光滑l 0 (Newton Smoothed l 0 norm, NSL0)算法 [ 14 ]；张巍等人通过引入近似双曲正切函数和混合优化方法提出了近似阻尼牛顿光滑l 0 (Almost- Hybird Newton Smoothed l 0 norm, A-HNSL0)算法 [ 15 ]；2020年，周洁容等人提出的非凸复合稀疏基(Non-convex Composite Sparse bases, NCCS)算法 [ 16 ] 中采用复合指数函数近似l 0 范数，并结合外点罚函数法和共轭梯度法求得最优解。这类方法对稀疏信号的恢复性能由所使用的函数对l 0 范数的逼近程度以及对该函数的求解方法所决定。 SL0算法具有重构速度快，算法简单等优点，但该算法采用的高斯函数的陡峭性不大，不能更好地逼近l 0 范数，且利用最速下降法进行求解会产生“锯齿现象”，不能求得全局最优解，从而导致算法重构精度不高。针对以上不足，本文利用一种陡峭性更强的非凸光滑函数逼近l 0 范数，并通过外点罚函数法和共轭梯度法求得稀疏解，提出了一种改进的近似l 0 范数的稀疏信号重构算法，即INCS (Improved non-convex sparse bases)算法。最后通过仿真实验验证了本文算法在重构误差、信噪比和恢复成功率等方面较于SL0算法、基追踪算法和NCCS算法的优越性。"
"压缩感知中稀疏信号重构算法是求解最优化问题(1)，对任意的 x ∈ R n ， ‖ x ‖ 0 可表示为 ‖ x ‖ 0 = ∑ i = 1 n δ ( x i ) ，其中 δ ( x i ) = { 0 x i = 0 1 x i ≠ 0 。 由于l 0 范数是不连续的，SL0算法中Mohimani等人首次提出利用连续函数 f σ ( x i ) = 1 − e − x i 2 2 σ 2 来逼近 δ ( x i ) ，其中 σ ( 0 < σ < 1 ) 为控制参数，显然有： lim σ → 0 f σ ( x i ) = { 0 x i = 0 1 x i ≠ 0 (2) 令 F σ ( x ) = ∑ i = 1 n f σ ( x i ) ，对任意的 x ∈ R n ，可得到 lim σ → 0 F σ ( x ) = ‖ x ‖ 0 。故最小化l 0 范数问题(1)可转化为 以下优化问题： min x F σ ( x )         s .t .       A x = b (3) SL0算法利用最速下降法和梯度投影原理求解该优化问题。该算法具有重构速度快，算法简单等优点，但采用的连续函数的陡峭性不大，使得近似l 0 范数的估计不准确；且最速下降法会出现“锯齿现象”，不能求得全局最优解，从而导致算法的重构精度不高。"
"3. 基于改进的近似l 0 范数的稀疏信号重构算法 3.1. 改进的近似l 0 范数 为了提高近似函数对l 0 范数的逼近程度，本文采用一种改进的非凸光滑函数近似l 0 范数： f σ ( x ) = 1 − e − c | x | σ 2 (4) 其中c为大于等于1的常数， σ ( 0 < σ < 1 ) 为控制参数。 文献 [ 13 ] 和 [ 16 ] 中分别采用了以下两种函数来近似l 0 范数： p σ ( x ) = 1 − e − x 2 2 σ 2 、 h σ ( x ) = 1 − e − | x | σ ( | x | + σ ) 下面从几何图像和理论分析上说明本文提出的函数 f σ ( x ) 比函数 p σ ( x ) 和 h σ ( x ) 更逼近l 0 范数。 1) 几何图像分析 函数 f σ ( x ) 、 p σ ( x ) 和 h σ ( x ) 的几何图像如图1所示，可以看出，函数 f σ ( x ) 的图像曲线相比于其他两种函数更陡峭，即函数 f σ ( x ) 对l 0 范数的逼近效果更好。 图1. σ = 0.1 , c = 1 时三种函数的对比图 2) 理论分析 假定 x ≥ 0 ，则对区间内任意 σ ( σ ≠ 0 ) 有 p σ ( x ) = 1 − e − x 2 2 σ 2 、 h σ ( x ) = 1 − e − x σ ( x + σ ) 、 f σ ( x ) = 1 − e − c x σ 2 ， 因为 h σ ( x ) − p σ ( x ) = e − x 2 2 σ 2 − e − x σ ( x + σ ) (5) 所以比较函数 p σ ( x ) 和 h σ ( x ) 的大小只需要比较他们的指数大小，易得： − x 2 2 σ 2 − ( − x σ ( x + σ ) ) = x σ ( 1 x + σ − x 2 σ ) ≥ 0 (6) 因此 h σ ( x ) ≥ p σ ( x ) ； 同理 f σ ( x ) − h σ ( x ) = e − x σ ( x + σ ) − e − c x σ 2 (7) 因为 − x σ ( x + σ ) − ( − c x σ 2 ) = x σ ( c σ − 1 x + σ ) ≥ 0 (8) 所以 f σ ( x ) ≥ h σ ( x ) 。 利用函数对称性， x < 0 时也可类似讨论。因此可以得到 p σ ( x ) ≤ h σ ( x ) ≤ f σ ( x ) ，即当 x ≠ 0 时，函数 f σ ( x ) 对应的函数值比其他两种函数对应的函数值更加接近于1，这意味着函数 f σ ( x ) 比其他两种函数更逼近l 0 范数。  下面基于所改进的函数 f σ ( x ) 对(3)式进行求解。令 x = u − v ，其中 u , v ∈ R n ，u为x中所有的正元，其余元素为零；v为x中所有负元的绝对值，其余元素也为零，利用 z = [ u T , v T ] T ∈ R 2 n 表示拼接向量。 经过替换，可得： F σ ( z ) = F σ ( x ) = ∑ i = 1 2 n ( 1 − e − c z i σ 2 ) (9) 此时约束条件 A x = b 转化为 [ A , − A ] z = b ，所以(3)式转化为： min z F σ ( z )         s .t .     [ A , − A ] z = b , z ≥ 0 (10) 为了方便求解(10)式，利用非凸函数 F σ ( z ) 的一阶判别条件及优化最小化(Majorize-Minorize, MM)方法 [ 17 ] 对目标函数 F σ ( z ) 进行放缩，可得： F σ ( z ) ≤ F σ ( z ˜ ) + 〈 z − z ˜ , ∇ F σ ( z ˜ ) 〉 ≤ F σ ( z ˜ ) + 〈 z − z ˜ , ∇ F σ ( z ˜ ) 〉 + λ ( ‖ z − z ˜ ‖ 2 2 + ‖ z − z ˜ ‖ 1 ) (11) 记 H σ ( z , z ˜ ) = F σ ( z ˜ ) + 〈 z − z ˜ , ∇ F σ ( z ˜ ) 〉 + λ ( ‖ z − z ˜ ‖ 2 2 + ‖ z − z ˜ ‖ 1 ) (12) 其中 z , z ˜ 为可行域中的点， λ ( λ > 1 / σ 2 ) 为常值，则 H σ ( z , z ˜ ) 为 F σ ( z ) 的一个上界函数。 忽略常值后，则(10)式的解由下式迭代求得： z k + 1 σ = arg min z { 〈 ∇ F σ ( z k σ ) , z 〉 + λ ( ‖ z − z k σ ‖ 2 2 + ‖ z − z k σ ‖ 1 ) | [ A , − A ] z = b , z ≥ 0 } (13) 其中 z k σ ( k = 1 , 2 , 3 , ⋯ ) 为可行域中的点，取值与 σ 有关。 令 { 〈 ∇ F σ ( z ˜ σ ) , z 〉 + λ ( ‖ z − z ˜ ‖ 2 2 + ‖ z − z ˜ ‖ 1 ) = G ( z ) [ A , − A ] z − b = H ( z ) = ( h 1 ( z ) , ⋯ , h m ( z ) ) T z = W ( z ) = ( w 1 ( z ) , ⋯ , w 2 n ( z ) ) T 则(13)可简记为： min z G ( z )         s .t .     H ( z ) = 0 , W ( z ) ≥ 0 (14) 因此，(3)式的优化问题转化为(14)式的优化问题。 本文利用外点罚函数法 [ 18 ] 和共轭梯度法迭代求解(14)式，具体步骤如下： 利用外点罚函数法引入正数M，本文取 M = 1 ，放大倍数为5，将(14)式转化为以下无约束问题： z k + 1 σ = arg min z L z k σ ( z , M ) (15) 其中 L z k σ ( z , M ) = 〈 ∇ F σ ( z k σ ) , z 〉 + λ ( ‖ z − z k σ ‖ 2 2 + ‖ z − z k σ ‖ 1 ) + M ( I T ⋅ U ( z ) + I T ⋅ H ( z ) ) (16) 式中I为 2 n × 1 的单位向量， U ( z ) = ( min ( 0 , z 1 2 ) , ⋯ , min ( 0 , z 2 n 2 ) ) T ， H ( z ) = d i a g ( [ A , − A ] z − b ) ⋅ ( [ A , − A ] z − b ) ，则函数 L z k σ ( z , M ) 有关z的一阶、二阶次梯度 [ 19 ] 分别为： ∇ L z k σ ( z , M ) = ∇ F σ ( z k σ ) + λ ( 2 ( z − z k σ ) + sgn ( z − z k σ ) ) + 2 M { V ( z ) + [ A , − A ] T ⋅ ( [ A , − A ] z − b ) } (17) ∇ 2 L z k σ ( z , M ) = 2 λ I + 2 M ⋅ [ A , − A ] T [ A , − A ] I (18) 其中 V ( z ) = ( min ( 0 , z 1 ) , ⋯ , min ( 0 , z 2 n ) ) T 。 再利用共轭梯度法迭代求解(15)式的 z k + 1 σ ，其迭代更新格式为： z t + 1 = z t + α t ⋅ p t (19) 其中步长因子为： α t = ‖ ∇ L z k σ ( z t , M ) ‖ 2 2 p t T ⋅ ∇ 2 L z k σ ( z t , M ) ⋅ p t (20) 下降方向为： p t = − ∇ L z k σ ( z t , M ) + p t − 1 ⋅ ρ t − 1 (21) 其中令 z k σ = z 0 ， p 0 = − ∇ L z k σ ( z 0 , M ) ， ρ t − 1 = ‖ ∇ L z k σ ( z t , M ) ‖ 2 2 ‖ ∇ L z k σ ( z t − 1 , M ) ‖ 2 2 。 综上所述，本文所提出的INCS算法的流程如下： Step 1输入：矩阵A、测量向量b， ε 1 , ε 2 , ε 3 > 0 ； Step 2初始化： 1) 设置递减序列 σ ， σ k + 1 = β σ k ，其中 0 < β < 1 ， β 为 σ 的递减因子，本文设置 β = 0.5 ， σ 0 = 2 max ( | x 0 | ) ； 2) 设置初始值： x 0 = arg min x { ‖ x ‖ 1 | A x = b } ， z 0 = [ ( x 0 + ) T , ( x 0 − ) T ] T ； Step 3算法迭代： 1) k = 0 ， σ = σ 0 ； 2) while d 1 > ε 1 do 1：{ z ^ 0 = z k , l = 0 , k = k + 1 ， 2：while d 2 > ε 2 do 3：{ l = l + 1 ， 4： z ^ l = arg min z { G l − 1 ( z ) | [ A , − A ] z = b , z ≥ 0 } ， 5： d 2 = ‖ z ^ l − z ^ l − 1 ‖ 2 ‖ z ^ l − 1 ‖ 2 } 6： z k = z ^ l ， 7： d 1 = ‖ z ^ k − z ^ k − 1 ‖ 2 ‖ z ^ k − 1 ‖ 2 ， 8： σ = β σ }， 9： x k = z k ( 1 : n ) − z k ( n + 1 : e n d ) ， 10： W = 1 | x k − 1 | + ε 3 ， 11： x k = arg min x { ‖ W x ‖ 1 | A x = b } ； Step 4输出稀疏向量： x = x k 。 其中Step 3由内、外两部分循环构成。外循环由步骤1~2及6~8组成，通过参数 σ 实现函数 f σ ( x ) 对 l 0 范数的逐次逼近；内循环为步骤3~5，利用外点罚函数法和共轭梯度法迭代求解步骤4；并将求得的解利用加权 l 1 范数最小化 [ 20 ] 进行稀疏化处理。 d 1 和 d 2 分别表示外、内循环连续迭代的解之间的相对误差，并用于判断循环是否停止。"
"为验证本文所提出的INCS算法在重构性能上的优越性，本节设计了几组有关SL0算法、基追踪(Basis Pursuit, BP)算法、NCCS算法和INCS算法的对比实验。对于每个实验，我们重复进行100次测试，给出平均结果，并取 c = 10 。仿真实验结果是在MatlabR2014a的条件下获得的。 在仿真实验中，矩阵A的大小为 128 × 256 ，其中矩阵元素服从零均值、单位方差的高斯分布，矩阵的列具有单位l 2 范数；稀疏原信号x的维数为256，非零项服从正态分布；信号稀疏度k取值区间为 [ 10 , 80 ] 。 实验中所涉及到的性能指标包括： 1) 重构误差(mean squared error)： M S E = ‖ x ˜ − x ^ ‖ 2 2 2) 信噪比(signal noise ratio)： S N R = 10 ⋅ log 10 ( ‖ x ˜ ‖ 2 2 ‖ x ˜ − x ^ ‖ 2 2 ) 3) 算法运行时间 4) 恢复成功率(recovery success rate)：当 x ˜ i ≠ 0 时， | x ˜ − x ^ | ≤ 10 − 4 说明算法在该点处重构成功， R S S = x ^ 重 构 成 功 的 点 个 数 x ˜ 中 非 零 点 个 数 其中 x ˜ 表示稀疏原信号， x ^ 表示算法的恢复信号； 图2为各算法的重构误差MSE和稀疏度的变化关系，实验结果如图2及表1所示。由图2和表1可见，BP算法、NCCS算法和INCS算法都存在随着稀疏度的增加重构误差增大的趋势。在同一稀疏度下，相比于其他三种算法，INCS算法的重构误差略小。 图2. SL0算法、BP算法、NCCS算法、INCS算法的重构误差和稀疏度的变化关系 Table 1算法 k = 10 k = 20 k = 30 k = 40 k = 50 k = 60 k = 70 k = 80 BP 1.12E−18 5.48E−18 5.81E−17 3.06E−16 0.45357 3.57556 10.01417 18.29708 SL0 2.47E−08 2.29E−08 2.09E−08 1.94E−08 1.70E−08 1.24461 14.78881 23.99578 NCCS 5.54E−20 5.79E−19 1.93E−18 7.17E−18 9.38E−18 0.79264 7.34229 17.68958 INCS 2.83E−20 1.31E−19 2.45E−19 9.53E−19 2.45E−18 7.60E−17 3.04638 14.10025 表1. 各算法的重构误差随着稀疏度k变化的数值记录 图3为各算法的重构信噪比SNR和稀疏度的变化关系，实验结果如图3及表2所示。可以看出，在稀疏度区间 [ 10 , 50 ] 上，INCS算法和NCCS算法的信噪比变化不大且相差很小，但明显高于SL0算法和BP算法的信噪比；在稀疏度区间 [ 50 , 80 ] 上，各算法的信噪比随着稀疏度的增加而减小，但INCS算法的信噪比仍高于其他三种算法。 图3. SL0算法、BP算法、NCCS算法、INCS算法的重构信噪比和稀疏度的变化关系 Table 2算法 k = 10 k = 20 k = 30 k = 40 k = 50 k = 60 k = 70 k = 80 BP 2.11E+02 2.05E+02 2.05E+02 1.94E+02 1.12E+02 19.71136 6.68644 4.47774 SL0 70.98122 77.35896 81.58295 84.80094 87.50702 83.92584 26.56156 6.28709 NCCS 2.32E+02 2.26E+02 2.23E+02 2.21E+02 2.16E+02 1.94E+02 1.16E+02 18.32044 INCS 2.32E+02 2.23E+02 2.22E+02 2.18E+02 2.12E+02 2.11E+02 1.57E+02 35.03469 表2. 各算法的重构信噪比随着稀疏度k变化的数值记录 图4为各算法的运行时间和稀疏度的变化关系，实验结果如图4及表3所示。可以看出，SL0算法和BP算法的运行时间较短并能够保持在0.5秒以内。在稀疏度区间 [ 10 , 50 ] 上，INCS算法和NCCS算法的运行时间能保持在1秒以内，在稀疏度区间 [ 50 , 80 ] 上这两种算法的运行时间都有所增加，但对比NCCS算法，INCS算法的运行时间始终略短。 图4. SL0算法、BP算法、NCCS算法、INCS算法的运行时间和稀疏度的变化关系 Table 3算法 k = 10 k = 20 k = 30 k = 40 k = 50 k = 60 k = 70 k = 80 BP 0.11539 0.12327 0.13205 0.15259 0.16604 0.16831 0.18520 0.18352 SL0 0.00010 0.00009 0.00011 0.00009 0.00012 0.00012 0.00010 0.00009 NCCS 0.58932 0.58826 0.60202 0.57496 0.66814 1.07208 2.03705 2.41634 INCS 0.46711 0.48871 0.48493 0.50970 0.60926 0.71415 1.40504 2.34221 表3. 各算法的运行时间随着稀疏度k变化的数值记录 图5为各算法的恢复成功率RSS和稀疏度的变化关系，实验结果如图5及表4所示。可以看出，当稀疏度增加到一定程度时这四种算法的恢复成功率均开始降低。INCS算法的恢复成功率在稀疏度区间 [ 10 , 60 ] 上都能保持为1，也就是说在这个区间内该算法都能够实现信号的完全恢复。在稀疏度区间 [ 60 , 80 ] 上，INCS算法的恢复成功率始终略高于其他三种算法，所以利用INCS算法恢复信号时精确度有一定的提高。 图5. SL0算法、BP算法、NCCS算法、INCS算法的恢复成功率和稀疏度的变化关系 Table 4算法 k = 10 k = 20 k = 30 k = 40 k = 50 k = 60 k = 70 k = 80 BP 1 1 1 1 0.79640 0.54050 0.50729 0.50075 SL0 1 1 1 1 1 0.96700 0.62271 0.52200 NCCS 1 1 1 1 1 0.97750 0.77829 0.53650 INCS 1 1 1 1 1 1 0.87512 0.57163 表4. 各算法的恢复成功率随着稀疏度k变化的数值记录 综上所述，本文提出的INCS算法的综合重构性能优于实验中的对比算法，说明利用该算法能够更好的恢复稀疏信号。"
"本文提出了一种基于改进的近似l 0 范数的稀疏信号重构算法，即INCS算法。该算法利用一种逼近性能更优的非凸光滑函数实现对l 0 范数的逼近，并通过外点罚函数法和共轭梯度法求解基于该函数的稀疏解。实验结果表明：对比SL0算法、BP算法和NCCS算法，INCS算法在重构误差、信噪比和恢复成功率等方面表现出更优越的重构性能。"
