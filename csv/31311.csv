"本文研究了工件具有相似加工时长时2台同类型平行机上LPT算法的最坏性能比。目标函数是使所有机器的最大完工时间达到最小。若工件序列 L = { J 1 , J 2 , ⋯ , J n } 中的工件满足 p j ∈ [ 1 , r ] ( r ≥ 1 ) ，证明了LPT算法的最坏性能比为r的分段线性函数，此结论改进了已有的最好结论，并且是不能再改进的最好结论。 关键词 :排序问题，平行机，LPT算法，最坏性能比 Copyright © 2019 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"排序问题是组合优化的重要分支之一，在生产管理、计算机信息技术处理等方面具有广泛的应用背景。自从Graham [ 1 ] 在1969年首次提出排序问题以来，这个问题一直是最活跃的研究领域之一。经典排序问题是将n个独立工件 J 1 , J 2 , ⋯ , J n 分配到m台具有同样性能的机器 M 1 , M 2 , ⋯ , M m 上加工，每一个工件只需在其中一台机器上加工一次就能完工，每台机器每次只能加工一个工件。工件 J 1 , J 2 , ⋯ , J n 之间没有先后的依存关系，且 J i 的加工时间为 p i ，目标是使所有工件在最早时间内完成全部加工，也就是使得所有机器中最大完工时间达到最小。由于排序问题是NP-困难问题，我们目前只能研究多项式时间近似算法。LPT (Largest Processing time)算法是Graham [ 2 ] 提出的著名近似算法。该算法首先将工件排序使其满足 p 1 ≥ p 2 ≥ ⋯ ≥ p n ，然后依次安排每个工件，每次总是把尚未投入加工的工件中编号最小者(即加工时 长最大的)送到最早空闲的机器上进行加工。LPT算法的最坏性能比是 4 3 − 1 3 m 。 在经典排序问题的算法性能比分析中是假设工件的加工时长是任意的，但实际情况中，工件的加工时长不会太小，也不会太大。为了更符合实际，也为了改进算法的性能比，促使研究工作者对工件加工时长做出适当假设。工件加工时长具有相似加工长度(即假设工件加工时长在区间[1, r]内，其中 r ≥ 1 )是常用假设之一 [ 3 ] - [ 8 ] ，也有假设工件最大时长已知的 [ 9 ] 及假设所有工件加工时长总和是已知的 [ 6 ] 。 H. Kellerer [ 10 ] 给出了在m台同类型平行机上当工件具有相似的加工时长时LPT算法的性能比的上界为 R ( m , L P T , μ ) ≤ { m ( 2 k − 2 ) − μ ( k − 2 ) k m                       for   μ ∈ [ 1 + m ( k − 3 ) k − 2 , m ( k 2 − 2 k − 2 ) + k ( k − 2 ) ( k + 1 ) ] ( k + 2 ) m − 1 ( k + 1 ) m                                                                                             for   μ ∈ [ m ( k 2 − 2 k − 2 ) + k ( k − 2 ) ( k + 1 ) , 1 + m ( k − 2 ) k − 1 ] 其中 k ≥ 3 ，k为整数， p 1 p n = 2 − μ m , ( 1 ≤ μ < m , μ ∈ R ) ，m表示机器数。当 μ ≤ m + 3 4 ( k = 3 ) 时， 4 m − μ 3 m 是紧的，其它区间不是紧界。 本文考虑两台机情形，即 m = 2 ，证明了LPT算法的最坏性能比为 R ( 2 , L P T , r ) = { 7 6 ,                                                                   r ≥ 3 2 , k r + k + 1 2 k + 1 ,                                           1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r < 1 + 1 2 k , 4 k + 7 4 k + 6 ,                                                               1 + 1 2 k + 2 ≤ r < 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                                                       r = 1. 其中 k ≥ 1 ，k为整数。 当 11 8 ≤ r ≤ 3 2 时(相当于 [ 10 ] 里的 μ ∈ [ 1 , 5 4 ] ，我们得到的性能比和 [ 10 ] 一样。当 r < 11 8 时，我们得到的 最坏性能比比 [ 10 ] 的更小。"
"在本文中我们引入下面记号： 1) L = { J 1 , J 2 , ⋯ , J n } 为一个工件序列，其中每个工件J j 的加工长度为 p j , j = 1 , 2 , ⋯ , n ； 2) p i ( j ) 表示第i台机器上的第j个工件的加工时长； 3) L i ( i = 1 , 2 , ⋯ , m ) 表示在LPT算法下最后一个工件J n 被安排之前机器M i 上所安排的所有工件加工时长的总和。并且我们将机器重新编号，使之满足 L 1 ≤ L 2 ≤ ⋯ ≤ L m ； 4) 设A是任一算法， C max A ( L ) 表示工件集L在算法A下所有机器的最大完工时间； 5) OPT表示最优算法。 定义1：算法A是一个近似算法， C max A ( L ) 和 C max O P T ( L ) 分别表示在A算法和最优算法下该工件序列的 最大完工时间。定义 R ( m , A ) = sup L C max A ( L ) C max O P T (L) 并称其为算法A的最坏性能比，其中 L = { J 1 , J 2 , ⋯ , J n } 为任一符合条件的工件序列。 下面我们分析LPT算法在两台机上的最坏性能比。"
"对于任意工件序列 L = { J 1 , J 2 , ⋯ , J n } ，易知 C max O P T ( L ) ≥ ∑ j = 1 n p j m (1) 其中m为机器台数。 在没有特别说明的情形下，下面我们总是假设工件序列 L = { J 1 , J 2 , ⋯ , J n } 满足， p i ∈ [ 1 , r ] , p 1 ≥ p 2 ≥ ⋯ ≥ p n ，并且总是假设 m = 2 。 定理1. 当 m = 2 时，LPT算法的最坏性能比为： R ( 2 , L P T , r ) = { 7 6 ,                                   r ≥ 3 2 , k r + k + 1 2 k + 1 ,       1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r < 1 + 1 2 k , 4 k + 7 4 k + 6 , 1 + 1 2 k + 2 ≤ r ≤ 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                   r = 1. 其中 k ≥ 1 ，k为整数。 证明： r ≥ 3 2 时的结论即是Graham [ 2 ] 给出的 R ( 2 , L P T ) = 4 3 − 1 3 m 当 m = 2 时的情形。当 r = 1 时，所有工件的加工时长都一样，显然LPT算法也是最优算法，所以结论显然成立。下面讨论 2 k + 3 2 k + 2 ≤ r < 2 k + 1 2 k 的情形。我们首先证明对任意满足条件的工件序列L，下面不等式成立： C max L P T ( L ) C max O P T ( L ) ≤ { k r + k + 1 2 k + 1 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r < 2 k + 1 2 k , 4 k + 7 4 k + 6 2 k + 3 2 k + 2 ≤ r < 1 + 2 k + 1 2 k ( 2 k + 3 ) . (2) 如果(2)不成立，设 L = { J 1 , J 2 , ⋯ , J n } 是使(2)不成立且工件个数n最小的工件序列，这样的工件序列我们称之为最小反例。对于最小反例，易知最后一个工件J n 是最后完工的工件，即 C max L P T ( L ) = L 1 + p n 。 所以当 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r < 2 k + 1 2 k 时，我们有 k r + k + 1 2 k + 1 < C max L P T ( L ) C max O P T ( L ) = 2 ( L 1 + p n ) 2 C max O P T ( L )   ≤ L 1 + L 2 + 2 p n 2 C max O P T ( L ) = ∑ j = 1 n p j + p n 2 C max O P T ( L ) ≤ 1 + p n 2 C max O P T (L) 最后不等式由(1)得。即 C max O P T ( L ) < ( 2 k + 1 ) p n 2 k ( r − 1 ) < ( 2 k + 3 ) p n (3) 当 2 k + 3 2 k + 2 ≤ r < 1 + 2 k + 1 2 k ( 2 k + 3 ) 时，我们同样可得(3)。因此，对于最小反例L，其总工件个数 n ≤ 4 k + 4 。 下面我们令 S i = { j | J j   在 L P T 算 法 下 安 排 在   M i   上 并 且   j ≠ n } , i = 1 , 2 ； S i * = { j | J j   在 O P T 算 法 下 安 排 在   M i   上 } , i = 1 , 2 。 易知 | S 1 ∪ S 2 | = n − 1 , | S 1 * ∪ S 2 * | = n 。 为了完成定理1的证明，我们首先给出下面的几个引理。 引理2. 对最小反例L，在LPT算法下， J 2 i − 1 和 J 2 i 安排在不同机器上 ( i = 1 , 2 , ⋯ , 2 k , 2 k + 1 ) 。 证明：假设不然，设 i 0 是使 J 2 i − 1 和 J 2 i 为第一对被LPT算法安排在同一台机器上的两个工件，不失一般性，假设都安排在 M 2 上，那么在 J 2 i 0 − 1 和 J 2 i 0 安排之前， M 1 , M 2 上的工件集 S ′ 1 , S ′ 2 满足 | S ′ 1 | = | S ′ 2 | = i 0 − 1 ， 则由LPT算法规则下面不等式必然成立： ( i 0 − 1 ) r ≥ ∑ j ∈ S ′ 1 p j ≥ ∑ j ∈ S ′ 2 p j + p 2 i 0 − 1 ≥ i 0 所以有 r ≥ i 0 i 0 − 1 ≥ 1 + 1 2 k 。这显然与 r < 1 + 1 2 k 矛盾，即引理得证。 由引理2可以得出，在LPT算法下未安排工件 J 4 k + 4 时，两台机器上的工件个数相差不会超过1。 引理3. 对最小反例L，若 | S 1 * | ≥ | S 2 * | ，则 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 至少有一个成立。 证明：若 | S i ∩ S 1 * | < | S i ∩ S 2 * | ( i = 1 , 2 ) 成立，则 | ( S 1 ∪ S 2 ) ∩ S 1 * | ≤ | ( S 1 ∪ S 2 ) ∩ S 2 * | + 2 成立。由定义我们有 | ( S 1 ∪ S 2 ) ∩ S i * | = { | S i * | n ∉ S i * | S i * | − 1 n ∈ S i * 这样我们有 | S 1 * | − 1 ≤ | S 2 * | + 2 ( n ∈ S 1 * ) 或者 | S 1 * | ≤ | S 2 * | + 1 ( n ∈ S 2 * ) ，此时都与假设 | S 1 * | ≥ | S 2 * | 矛盾。 引理4. 设 p , q ∈ { 1 , 2 } ，令 q ¯ = q mod 2 + 1 ，即 q = 1 时 q ¯ = 2 ，而 q = 2 时 q ¯ = 1 。若 | S p | ≤ k 0 ， | S q * | ≥ k 0 + 1 ， | S p ∩ S q * | ≥ | S p ∩ S q ¯ * | 且 k 0 ≤ 2 k ，则有 C max L P T ( L ) C max O P T ( L ) ≤ k r + k + 1 2 k + 1 (4) 证明：由 C max L P T ( L ) ≤ ∑ j ∈ S p p j + p n 和 C max O P T ( L ) ≥ ∑ j ∈ S q * p j 得 C max L P T ( L ) C max O P T ( L ) ≤ ∑ j ∈ S p p j + p n ∑ j ∈ S q * p j = ∑ j ∈ S p ∩ S q ¯ * p j + ∑ j ∈ S p ∩ S q * p j + p n ∑ j ∈ S q * \ S p p j + ∑ j ∈ S p ∩ S q * p j ≤ ∑ j ∈ S p ∩ S q ¯ * p j + | S p ∩ S q * | + 1 ∑ j ∈ S q * \ S p p j + | S p ∩ S q * | ≤ | S p ∩ S q ¯ * | r + | S p ∩ S q * | + 1 | S p ∩ S q * | + | S q * \ S p | = | S p ∩ S q ¯ * | r + | S p ∩ S q * | + | S p ∩ S q ¯ * | r + | S p ∩ S q * | + 2 2 | S q * | ≤ | S p ∩ S q * | r + | S p ∩ S q ¯ * | + | S p ∩ S q ¯ * | r + | S p ∩ S q * | + 2 2 | S q * | ≤ | S p | r + | S p | + 2 2 | S q * | = k 0 r + k 0 + 2 2 k 0 + 2 ≤ k r + k + 1 2 k + 1 上面第二个不等式是因为 p n ≥ 1 和函数 f ( x ) = a + x b + x ( a ≥ b > 0 ) 在 x ≥ 0 里是x的减函数，第四个不等式由引理3得，最后一个不等式是因为 k 0 ≤ 2 k 和函数 g ( x , y ) = ( r + 1 ) x + 2 2 x + 2 是 x ≥ 0 的增函数。 引理5. 设 p , q ∈ { 1 , 2 } ，令 q ¯ = q mod 2 + 1 。若 | S P | ≤ 2 k 0 + 1 ， | S q * | ≥ 2 k 0 + 2 且 k 0 ≤ k ，则有(4)。 证明：与引理4的证明类似可得 C max L P T ( L ) C max O P T ( L ) ≤ ∑ j ∈ S p ∩ S q ¯ * p j + ∑ j ∈ S p ∩ S q * p j + p n ∑ j ∈ S q * \ S p p j + ∑ j ∈ S p ∩ S q * p j ≤ | S p ∩ S q ¯ * | r + | S p ∩ S q * | + 1 | S p ∩ S q * | + | S q * \ S p | = | S p ∩ S q ¯ * | ( r − 1 ) + | S p | + 1 | S q * | ≤ k 0 r + k 0 + 2 2 k 0 + 2 ≤ k r + k + 1 2 k + 1 上面最后一个不等式是因为函数 g ( x , y ) = ( r + 1 ) x + y 2 x + y 是 x ≥ 0 的增函数，是 y ≥ 0 的减函数。 由(3)，我们下面分 n = 2 k ′ + 1 , 2 k ′ + 2 ( k ′ ≤ 2 k ) 和 n = 4 k + 3 , 4 k + 4 这4种情况证明(4)成立。 情况1. n = 2 k ′ + 1 , k ′ ≤ 2 k 。 由 | S 1 * | + | S 2 * | = 2 k ′ + 1 不妨设 | S 1 * | ≥ k ′ + 1 。由引理2得 | S 1 | = | S 2 | = k ′ ，由引理3知， | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 至少有一个成立。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 成立。则令 p = 1 , q = 1 , k 0 = k ′ ，由引理4得(4)成立。若 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立。则令 p = 2 , q = 1 , k 0 = k ′ ，由引理4也得(4)成立。 情况2. n = 2 k ′ + 2 , k ′ ≤ 2 k 。 由引理2不妨设有 | S 1 | = k ′ , | S 2 | = k ′ + 1 , | S 1 * | ≥ k ′ + 1 。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | ，则令 p = 1 , q = 1 , k 0 = k ′ ，由引理4得(4)成立。 若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，此时若有 | S 2 * | ≥ k ′ + 1 ，令 p = 1 , q = 2 , k 0 = k ′ ，由引理4得(4)成立。否则有 | S 2 * | ≤ k ′ ，因而 | S 1 * | ≥ k ′ + 2 。则由引理3知 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立，这时令 p = 2 , q = 1 , k 0 = k ′ + 1 ，由引理4知当 k ′ < 2 k 时(4)成立。 若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，且 | S 2 * | ≤ k ′ 和 k ′ = 2 k 成立，令 p = 1 , q = 2 , k 0 = k ′ ，由引理5知(4)成立，因为由 | S 1 ∩ S 1 * | ≤ | S 1 ∩ S 2 * | 可得 | S 1 ∩ S 1 * | ≤ k 。 情况3. n = 4 k + 3 。 不妨设 | S 1 * | > | S 2 * | 。由引理2及(3)知 | S 1 * | = 2 k + 2 且 | S 1 | = | S 2 | = 2 k + 1 。由引理3知 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 中至少有一个成立。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 成立，则有 | S 1 ∩ S 1 * | ≥ k + 1 ， | S 1 ∩ S 2 * | ≤ k 。令 p = 1 , q = 1 , k 0 = k ，则由引理5即得(4)成立。 若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，则必有 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立，所以有 | S 2 ∩ S 1 * | ≥ k + 1 ， | S 2 ∩ S 2 * | ≤ k p = 2 , q = 1 , k 0 = k 则由引理5即得(4)成立。 情况4. n = 4 k + 4 。 由(3)得 | S 1 * | = | S 2 * | = 2 k + 2 。由引理2可不妨设 | S 1 | = 2 k + 1 , | S 2 | = 2 k + 2 。 若 | S 1 ∩ S 1 * | ≥ k + 1 成立，则有 | S 1 ∩ S 2 * | ≤ k 这时令 p = 1 , q = 1 , k 0 = k ，则由引理5即得(4)成立。由于 | S 1 ∩ ( S 1 * ∪ S 2 * ) | = 2 k + 1 ，若 | S 1 ∩ S 1 * | ≥ k + 1 不成立，则 | S 1 ∩ S 2 * | ≥ k + 1 成立，因而有 | S 1 ∩ S 1 * | ≤ k ，这时令 p = 1 , q = 2 , k 0 = k ，则由引理5也得(4)成立。 由上所述可知 C max L P T ( L ) C max O P T ( L ) ≤ max { k r + k + 1 2 k + 1 , 4 k + 7 4 k + 6 } = { k r + k + 1 2 k + 1 , 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r < 2 k + 1 2 k 4 k + 7 4 k + 6 , 2 k + 3 2 k + 2 ≤ r < 1 + 2 k + 1 2 k ( 2 k + 3 ) 下面我们分别给出上面不等式等号成立的实例： 当 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r ≤ 2 k + 1 2 k 时，我们令 L = { J 1 , J 2 , ⋯ , J 4 k + 1 } ，其相应的加工时长为 { r , r , ⋯ , r , 1 , 1 , ⋯ , 1 } ，其中时长为r和1的工件分别有2k和 2 k + 1 个。在LPT算法下， M 1 上安排时长为r和1的工件各 k , k + 1 个， M 2 上安排时长为r和1的工件各k个，故 C max L P T ( L ) = k r + k + 1 。 在OPT算法下， M 1 上安排时长为r的工件2k个， M 2 上安排时长为1的工件 2 k + 1 个，故 C max O P T ( L ) = 2 k + 1 ，即 C max L P T ( L ) C max O P T ( L ) ≤ k r + k + 1 2 k + 1 当 2 k + 3 2 k + 2 ≤ r < 1 + 2 k + 1 2 k ( 2 k + 3 ) 时，我们分别给出k为奇数和偶数时紧界的实例： 当k为奇数时，令 L = { J 1 , J 2 , ⋯ , J 4 k + 5 } ，其相应加工时长为 { r , r , ⋯ , r , r ′ , r ′ , ⋯ , r ′ , 1 , 1 , ⋯ , 1 } 时长为r和 r ′ 的各有 k + 1 个，时长为1的有 2 k + 3 个，并且满足 1 < r ′ < r , r + r ′ = 2 k + 3 k + 1 在LPT算法下， M 1 上安排时长为r和 r ′ 的工件各有 k + 1 2 个，安排 k + 2 个时长为1的工件。 M 2 上安排时长分别为r和 r ′ 的工件各 k + 1 2 个，时长为1的工件 k + 1 个。则 C max L P T ( L ) = ( k + 1 ) ( r + r ′ ) 2 + k + 2 在OPT算法下， M 1 上安排时长为r和 r ′ 的工件各 k + 1 个， M 2 上安排 2 k + 3 个时长为1的工件， 则 C max O P T ( L ) = 2 k + 3 ，故 C max L P T ( L ) C max O P T ( L ) = 4 k + 7 4 k + 6 当k为偶数时，令 L = { J 1 , J 2 , ⋯ , J 4 k + 5 } ，其相应加工时长为 { r , r , ⋯ , r , r ′ , r ′ , ⋯ , r ′ , r ″ , r ″ , 1 , 1 , ⋯ , 1 } 长分别为r和 r ′ 的各有k个，时长为 r ″ 的工件有2个，时长为1的有 2 k + 3 个，并且满足 1 < r ″ < r ′ < r , k ( r + r ′ ) + 2 r ″ = 2 k + 3 在LPT算法下， M 1 上安排时长为r和 r ′ 的工件各 k 2 个，安排1个时长为 r ″ 的工件和 k + 2 个时长为1的工件。 M 2 上安排时长分别为r和 r ′ 的工件各 k 2 个和1个时长为 r ' ' 的工件以及 k + 1 个时长为1的工件。则 C max L P T ( L ) = k ( r + r ′ ) 2 + r ″ + k + 2 在OPT算法下， M 1 上安排时长为r和 r ′ 的工件各k个，以及2个 r ″ ，在 M 2 上安排 2 k + 3 个时长为1的工件，则 C max O P T ( L ) = 2 k + 3 故： C max L P T ( L ) C max O P T ( L ) = 4 k + 7 4 k + 6 综上可知，定理1得证。"
"本文主要研究了工件具有相似加工时长时，LPT算法在同型平行机上的最坏性能比。证明了当 m = 2 时对于任意的工件序列L，LPT算法的最坏性能比为 R ( 2 , L P T , r ) = { 7 6 ,                                     r ≥ 3 2 , k r + k + 1 2 k + 1 ,       1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r < 1 + 1 2 k , 4 k + 7 4 k + 6 , 1 + 1 2 k + 2 ≤ r ≤ 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                     r = 1. 其中 k ≥ 1 ，k为整数。 本文成果改进了已有的最好结果，并且这是不能改进的最好结果。本文的分析比较复杂，更有趣的问题是能否改进一般性m台机时的最坏性能比。"
