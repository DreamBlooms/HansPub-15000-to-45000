"本文研究带有可变加工时间和维护的松弛交货期与凸资源分配的单机排序问题。工件的实际加工时间是所分配的不可再生资源量和与工件位置、开始时间有关的退化效应的函数。在规划时间内最多允许执行一次维护活动。确定最优工件排序、最优公共松弛时间、最优维护位置和最优资源分配方案，使得由工件的提前惩罚、延误惩罚、交货期公共松弛时间、资源分配费用、最大完工时间和总完工时间构成的总费用最小。根据优化的相关知识，将问题转化为匹配问题，证明了该问题在多项式时间内是可解的，给出了多项式时间最优算法。 关键词 :排序，维护，松弛交货期分配，资源分配，退化效应 Copyright © 2018 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"排序作为一门应用科学，有着深刻的实际背景，它主要产生于机器制造，后来被广泛应用于管理科学、运输业、计算机科学和工程技术等众多领域。 在经典的排序问题中，一般假设工件的加工时间是常值且工件必须连续加工不允许中断，但是在实际生产中，工件的实际加工时间会因为机器设备、工件本身以及资源分配等因素的影响不可能始终是恒定的，并且可能会需要在一段时间内对机器进行维护来提高它的工作效率。 在实际中，由于工人或机器的工作时间较长，其工作效率降低，即工件的加工位置越靠后，等待加工的时间越长，其实际的加工时间越长，也就产生了所谓的退化效应。Oron, D [ 1 ] 在退化环境中排列具有可控加工时间的工件。交货期的设定会对生产活动产生一定的惩罚费用，因而如何去设定交货期，使得支付的费用尽可能少成了需要去探讨的问题。Seidmann [ 2 ] 等研究了单机排序问题中的最优交货期指派；Panwalker [ 3 ] 等采用公共交货期指派来极小化单机排序问题中的总惩罚。Wang [ 4 ] 等讨论了带有退化工件和依赖于资源的加工时间的单机交货期指派问题。Lu [ 5 ] 等讨论了带有学习效应和与资源有关加工时间的最优交货期指派问题。 维护活动主要是可以提高生产加工的工作效率，避免由于加工时间过长而多支付一些费用。Yang [ 6 ] 等研究了具有退化效应和退化维护活动的单机排序问题，目标是极小化总完工时间。在此基础上，Zhao [ 7 ] 等研究了具有一般与工件有关的退化效应和维护活动的单机排序问题来极小化最大完工时间。在此基础上，Yang [ 8 ] 等讨论了具有退化效应和退化维护的单机排序问题与松弛交货期指派问题，提出实际加工时 间 p j r = p j r a j ， j = 1 , 2 , ⋯ , n ，但如果第r个位置的工件被排在了维护之后，它的实际加工时间就变为 p j r = p j ( r − i ) a j ，目的是极小化总费用函数。 在实际的制造设计和加工生产中，一批工件的加工和生产往往会受到很多诸如润滑剂等资源的约束,因而具有资源分配的排序问题更具实际意义。分配的资源越多，工件的加工时间就越短。消耗一定的资源，相应的要承担一定的费用，因此需要平衡两者之间的关系，达到效率最高，总费用最小。Wang [ 9 ] 等探究了工件加工时间依赖于位置、开始加工时间和资源分配的排序问题，提出模型为 p j r A = p j r b + c t − β j u j ，解决了目标函数包括最大完工时间、总完工时间、总完工时间偏差和、总资源费 用最小化的问题以及目标函数包括最大完工时间、总等待时间、总等待时间偏差和、总资源费用最小化的问题，给出了相应的多项式时间算法。Wang [ 10 ] 等讨论了与凸资源有关的加工时间和退化工件的单机排序问题，给出了多项式时间算法。Li [ 11 ] 等探讨了带有学习效应、退化工件和与凸资源有关加工时间的单机排序问题。Sun [ 12 ] 等研究了具有可变加工时间的交货期指派和凸资源分配排序问题，对于三种交货期指派方法，证明了可以在多项式时间内极小化包含提前、延迟、交货期指派和总资源消耗费用函数。 本文研究带有可变加工时间和维护的松弛交货期与凸资源分配的单机排序问题。模型中工件的实际加工时间是所分配的不可再生资源量和与工件位置、开始时间有关的退化效应的函数。目标是确定最优工件排序、最优公共松弛时间、最优维护位置和最优资源分配方案，使得由工件的提前惩罚、延误惩罚、交货期公共松弛时间、资源分配费用、最大完工时间和总完工时间构成的总费用最小。根据优化的相关知识，将问题转化为匹配问题，证明了该问题在多项式时间内是可解的，给出了多项式时间最优算法。"
"考虑问题如下：设有n个独立且不可中断的工件 J = { J 1 , J 2 , ⋯ , J n } 在零时刻可用，需要在一台机器上进行加工，同一时刻机器最多只能加工一个工件，每个工件有各自的交货期。如果工件 J j 排在序列的第r个位置，那么它的实际加工时间为： p j = ( ( a j / u j ) k + b t ) r m ,   j , r = 1 , 2 , ⋯ , n 其中 a j ≥ 0 表示工件 J j 的工作量，k是一个正实数， m ≥ 0 是一个退化指数， u j > 0 为分配给工件 的不可再生资源数量，r为工件 J j 被排在序列中的位置， t ≥ 0 为工件 J j 的开始加工时间， b > 0 为公共退化速率。 由于退化会降低生产效率，在机器上可以执行维护操作来消除其带来的影响。假设最多只能允许维护一次，且可以在任一个工件完工之后立即进行维护。然而预先无法得知维护在序列中的位置，为了使问题模型更接近于现实，进一步假设：1) 机器在维护后恢复到它的初始状态且退化效应也重新开始；2) 维护所用时间是它开始时间的线性函数，表达式为 f ( t ′ ) = μ + σ t ′ ，其中 μ > 0 是基本维护时间， σ > 0 是一个维护因子， t ′ 是维护的开始时间。因此，如果工件 J j 排在维护之后的第r个位置，那么它的实际加工 时间为 p j = ( ( a j / u j ) k + b t ) ( r − i ) m ，其中i表示排在维护之前的工件数量。 对于一个给定的序列π，定义 C j 、 W j 分别为工件 J j 的完工时间和等待时间， C max = max { C j | j = 1 , 2 , ⋯ , n } 、 ∑ j = 1 n C j 分别表示最大完工时间和总完工时间。 E j = max { 0 , d j − C j } 和 T j = max { 0 , C j − d j } 分别表示工件 J j 的提前量和延迟量， d j ( ≥ 0 ) 为工件 J j 的交货期， d j = p j + q ， j = 1 , 2 , ⋯ , n ，其中q为公共松弛时间。注意，q是一个决策变量。 本文研究问题的目标是求出最优工件排序 π * 、最优公共松弛时间q、最优维护位置和最优资源分配 u * = ( u 1 * , u 2 * , ⋯ , u n * ) ，最小化下述目标函数： Z ( q , u , π ) = ∑ j = 1 n ( α E j + β T j + γ q + v j u j ) + δ 1 C max + δ 2 ∑ j = 1 n C j 其中 α > 0 , β > 0 , γ > 0 , δ 1 > 0 , δ 2 > 0 为给定的常数， v j ( > 0 ) 为资源分配的单位费用。使用三参数表示法可将上述问题表示为 1 | m a , p j = ( ( a j / u j ) k + b t ) r m | Z ( q , u , π ) (1) 其中β域中的ma表示维护。"
"下面，就问题的最优排序提出一些引理。一个明显的性质：最优排序中第一个工件从零时刻开始加工且两个相邻的工件之间没有空闲。为了简便，假设在工件 J [ i ] 完工之后立即进行维护，即维护之前的工件数量为i。 引理1：对于一个给定的序列 π = [ J [ 1 ] , J [ 2 ] , ⋯ , J [ n ] ] ，如果工件 J [ j ] 被排在维护之前，它的等待时间和完工时间分别为 W [ j ] = C [ j − 1 ] = ( a [ 1 ] / u [ 1 ] ) k 1 m + [ ( a [ 2 ] / u [ 2 ] ) k + b ( a [ 1 ] / u [ 1 ] ) k 1 m ] 2 m + ⋯     + [ ( a [ j − 1 ] / u [ j − 1 ] ) k + b ( ∑ r = 1 j − 2 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 j − 2 ( 1 + b l m ) ) ] ( j − 1 ) m = ∑ r = 1 j − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 j − 1 ( 1 + b l m ) C [ j ] = C [ j − 1 ] + [ ( a [ j ] / u [ j ] ) k + b ( ∑ r = 1 j − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 j − 1 ( 1 + b l m ) ) ] j m = ∑ r = 1 j ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 j ( 1 + b l m ) 其中 C [ 0 ] = 0 ， [ j ] 表示任意给定序列的第j个位置。 证明：用归纳法进行证明。如果 j = 1 ，可得 W [ 1 ] = C [ 0 ] = 0 和 C [ 1 ] = ( a [ 1 ] / u [ 1 ] ) k 1 m = p [ 1 ] 。假设 W [ i − 1 ] = C [ i − 2 ] = ∑ r = 1 i − 2 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 2 ( 1 + b l m ) 和 C [ i − 1 ] = ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) 成立，需要证明 W [ i ] = ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) 和 C [ i ] = ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) 。 如果 j = i ，那么 W [ i ] = C [ i − 1 ] = ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) C [ i ] = C [ i − 1 ] + [ ( a [ i ] / u [ i ] ) k + b ( ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) ) ] i m = ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) + [ ( a [ i ] / u [ i ] ) k + b ( ∑ r = 1 i − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i − 1 ( 1 + b l m ) ) ] i m = ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) 证毕。 引理2：对于一个给定的序列 π = [ J [ 1 ] , J [ 2 ] , ⋯ , J [ n ] ] ，如果工件 J [ j ] 被排在维护之后，它的等待时间和完工时间分别为 W [ j ] = C [ i ] + μ + σ C [ i ] + ∑ r = i + 1 j − 1 ( a [ r ] / u [ r ] ) k ( r − i ) m ∏ l = r + 1 j − 1 ( 1 + b l m ) = μ + ( 1 + σ ) ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) + ∑ r = i + 1 j − 1 ( a [ r ] / u [ r ] ) k ( r − i ) m ∏ l = r + 1 j − 1 ( 1 + b l m ) C [ j ] = μ + ( 1 + σ ) ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) + ∑ r = i + 1 j ( a [ r ] / u [ r ] ) k ( r − i ) m ∏ l = r + 1 j ( 1 + b l m ) 其中 [ j ] 表示任意给定序列的第j个位置。 证明：与引理1证明类似。证毕。 引理3：如果 C [ j ] ≤ d [ j ] ，那么 C [ j − 1 ] ≤ d [ j − 1 ] ， j = 2 , 3 , ⋯ , n ；如果 C [ j ] ≥ d [ j ] ，那么 C [ j + 1 ] ≥ d [ j + 1 ] ， j = 1 , 2 , ⋯ , n − 1 。 证明：令 J [ j ] 表示在一个工件序列中，被排在第j个位置的工件。考虑维护位置的所有可能情形证明如下。 情形1) j ≤ i − 1 ：工件 J [ j ] 被排在工件 J [ i − 1 ] 之前或 J [ j ] 被排在第 ( i − 1 ) 个位置。对于一个给定的排序π，如果 C [ j ] ≤ d [ j ] ，那么 C [ j ] = C [ j − 1 ] + p [ j ] ≤ d [ j ] = q + p [ j ] ⇒ C [ j − 2 ] ≤ q ⇔ C [ j − 2 ] + p [ j − 1 ] ≤ q + p [ j − 1 ] ⇔ C [ j − 1 ] ≤ d [ j − 1 ] 如果 C [ j ] ≥ d [ j ] ，那么 C [ j ] = C [ j − 1 ] + p [ j ] ≥ d [ j ] = q + p [ j ] ⇒ C [ j ] ≥ q ⇔ C [ j ] + p [ j + 1 ] ≥ q + p [ j + 1 ] ⇔ C [ j + 1 ] ≥ d [ j + 1 ] 情形2) j = i ：工件 J [ j ] 加工完成之后立即进行维护。对于一个给定的排序π，如果 C [ j ] ≤ d [ j ] ，那么 C [ j ] = C [ i ] = C [ i − 1 ] + p [ i ] ≤ d [ j ] = d [ i ] = q + p [ i ] ⇒ C [ i − 2 ] ≤ q ⇔ C [ i − 2 ] + p [ i − 1 ] ≤ q + p [ i − 1 ] ⇔ C [ i − 1 ] ≤ d [ i − 1 ] 如果 C [ j ] ≥ d [ j ] ，那么 C [ j ] = C [ i ] = C [ i − 1 ] + p [ i ] ≥ d [ j ] = d [ i ] = q + p [ i ] ⇒ C [ i ] ≥ q ⇔ C [ i ] + μ + σ C [ i ] + p [ i + 1 ] ≥ q + μ + σ C [ i ] + p [ i + 1 ] ⇒ C [ i + 1 ] ≥ q + p [ i + 1 ] ⇔ C [ i + 1 ] ≥ d [ i + 1 ] 情形3) j = i + 1 ：维护之后立即排工件 J [ j ] 。对于一个给定的排序π，如果 C [ j ] ≤ d [ j ] ，那么 C [ j ] = C [ i + 1 ] = C [ i ] + μ + σ C [ i ] + p [ i + 1 ] ≤ d [ j ] = d [ i + 1 ] = q + p [ i + 1 ] ⇒ C [ i ] = C [ j − 1 ] ≤ q ⇒ C [ j − 2 ] ≤ q ⇔ C [ j − 2 ] + p [ j − 1 ] ≤ q + p [ j − 1 ] ⇔ C [ j − 1 ] ≤ d [ j − 1 ] 如果 C [ j ] ≥ d [ j ] ，那么 C [ j ] = C [ i + 1 ] = C [ i ] + μ + σ C [ i ] + p [ i + 1 ] ≥ d [ j ] = d [ i + 1 ] = q + p [ i + 1 ] ⇒ C [ j ] ≥ q ⇔ C [ j ] + p [ j + 1 ] ≥ q + p [ j + 1 ] ⇔ C [ j + 1 ] ≥ d [ j + 1 ] 情形4) j > i + 1 ：工件 J [ j ] 被排在工件 J [ i + 1 ] 之后。对于一个给定的排序π，如果 C [ j ] ≤ d [ j ] ，那么 C [ j ] = C [ j − 1 ] + p [ j ] ≤ d [ j ] = q + p [ j ] ⇒ C [ j − 1 ] ≤ q ⇒ C [ j − 2 ] ≤ q ⇔ C [ j − 2 ] + p [ j − 1 ] ≤ q + p [ j − 1 ] ⇔ C [ j − 1 ] ≤ d [ j − 1 ] 如果 C [ j ] ≥ d [ j ] ，那么 C [ j ] = C [ j − 1 ] + p [ j ] ≥ d [ j ] = q + p [ j ] ⇒ C [ j ] ≥ q ⇔ C [ j ] + p [ j + 1 ] ≥ q + p [ j + 1 ] ⇔ C [ j + 1 ] ≥ d [ j + 1 ] 因此，得到引理3结论。证毕。 引理4：对于任一给定的序列π，都存在一个最优的松弛交货期，它的公共松弛时间q等于某工件的等待时间。 证明：令 J [ j ] 表示在一个工件序列中，被排在第j个位置的工件。假设存在一个工件序列π，使得对于工件 J [ s ] 有 W [ s − 1 ] ≤ q ≤ W [ s ] 。主要考虑 i < s 的情况，其它情况可以类似地证明。令 Δ = q − W [ s − 1 ] ，注意 0 ≤ Δ ≤ p [ s − 1 ] 。对于给定的 i < s ，维护所用时间为 f ( t ′ ) = μ + σ t ′ = μ + σ C [ i ] = μ + σ ( p [ 1 ] + p [ 2 ] + ⋯ + p [ i ] ) = μ + σ ∑ j = 1 i ( a [ j ] / u [ j ] ) k j m ∏ l = j + 1 i ( 1 + b l m ) 根据引理3可知，所有排在 J [ s ] 前的工件都提前，所有排在 J [ s ] 后的工件都延迟。 1) 工件 J [ j ] ( j = 1 , 2 , ⋯ , s − 1 ) 提前的费用之和如下： ∑ j = 1 s − 1 α E [ j ] = α [ ( s − 1 ) Δ + i μ + ∑ j = 1 i ( j + i σ ) p [ j ] + ∑ j = i + 1 s − 2 j p [ j ] ] 2) 工件 J [ j ] ( j = s , s + 1 , ⋯ , n ) 延迟的费用之和如下： ∑ j = s n β T [ j ] = β [ ∑ j = s − 1 n ( n − j ) p [ j ] − ( n − s + 1 ) Δ ] 3) 公共松弛时间的费用(表示为 Z q )为： Z q = ∑ j = 1 n γ q = n γ ( Δ + W [ s − 1 ] ) = n γ ( Δ + μ + ∑ j = 1 i ( 1 + σ ) p [ j ] + ∑ j = i + 1 s − 2 p [ j ] ) 4) δ 1 C max = δ 1 ( ∑ j = 1 n p [ j ] + f ( t ′ ) ) 5) δ 2 ∑ j = 1 n C [ j ] = δ 2 ( ∑ j = 1 n ( n − j + 1 ) p [ j ] + ( n − i ) f ( t ′ ) ) 因此，总费用由 Z ( q , u , π ) = ∑ j = 1 n ( α E [ j ] + β T [ j ] + γ q + v [ j ] u [ j ] ) + δ 1 C max + δ 2 ∑ j = 1 n C [ j ] 给定，可以将其表示为 Z ( q , u , π ) = A Δ + B ，其中 A = α ( s − 1 ) − β ( n − s + 1 ) + n γ B = α ( i μ + ∑ j = 1 i ( j + i σ ) p [ j ] + ∑ j = i + 1 s − 2 j p [ j ] ) + β ∑ j = s − 1 n ( n − j ) p [ j ] + n γ μ     + n γ ( ∑ j = 1 i ( 1 + σ ) p [ j ] + ∑ j = i + 1 s − 2 p [ j ] ) + ∑ j = 1 n v [ j ] u [ j ] + δ 1 ( ∑ j = 1 i ( 1 + σ ) p [ j ] + ∑ j = i + 1 n p [ j ] )     + δ 1 μ + δ 2 ( ( n − i ) μ + ∑ j = 1 i [ n − j + 1 + ( n − i ) σ ] p [ j ] + ∑ j = i + 1 n ( n − j + 1 ) p [ j ] ) 显然，A,B都是常数，与Δ无关，且Z是关于Δ的线性函数， B ≥ 0 ，要使 Z ( q , u , π ) 最小必须使 Δ = { 0 ,     α ( s − 1 ) − β ( n − s + 1 ) + n γ ≥ 0 p [ s − 1 ] ,     α ( s − 1 ) − β ( n − s + 1 ) + n γ < 0 因此，对于任一给定的序列π，都存在一个最优的公共松弛时间q等于某工件的等待时间。证毕。 接下来，确定其等待时间等于公共松弛时间q的工件 J [ s ] 的s值。要证明工件 J [ s ] 的位置是费用参数的一个函数，且与维护无关。 引理5：对于最优排序π，必有 q = C [ s − 1 ] = W [ s ] ，其中 s = ⌈ n ( β − γ ) / ( α + β ) ⌉ ( ⌈ x ⌉ 表示对x上取整，即取大于等于x的最小整数)。 证明：考虑一个最优排序和最优公共松弛时间，使得对某工件 J [ s ] 有 q = C [ s − 1 ] = W [ s ] ，利用经典扰动技术，研究当移动松弛时间时总费用的变化。当松弛时间左移充分小的正数ε个单位时间，总费用的改变值为 Δ Z 1 = − α ( s − 1 ) ε + β ( n − s + 1 ) ε − n γ ε ；相反地，当松弛时间右移ε个单位时间，总费用的改变值为 Δ Z 2 = α s ε − β ( n − s ) ε + n γ ε 。显然，因为π为最优排序，所以 Δ Z 1 ≥ 0 ， Δ Z 2 ≥ 0 。由 Δ Z 1 ≥ 0 ，得 s ≤ n ( β − γ ) / ( α + β ) + 1 ；由 Δ Z 2 ≥ 0 ，得 s ≥ n ( β − γ ) / ( α + β ) 。因为 s ∈ Ζ ，故 s = ⌈ n ( β − γ ) / ( α + β ) ⌉ 。证毕。"
"引理6：在问题1)中，第s个工件的实际加工时间为 p [ s ] = ( a [ s ] / u [ s ] ) k s m + b ( ∑ r = 1 s − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 s − 1 ( 1 + b l m ) ) s m , s ≤ i p [ s ] = ( a [ s ] / u [ s ] ) k ( s − i ) m + b ( μ + ( 1 + σ ) ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) ) ( s − i ) m                   + b ( ∑ r = i + 1 s − 1 ( a [ r ] / u [ r ] ) k ( r − i ) m ∏ l = r + 1 s − 1 ( 1 + b l m ) ) ( s − i ) m , s > i 由上边引理可得下述结论： 1) 如果在加工 J [ s ] 之前进行维护，即 i < s ，那么总费用为： Z ( q , u , π ) = ∑ j = 1 n ( α E [ j ] + β T [ j ] + γ q + v [ j ] u [ j ] ) + δ 1 C max + δ 2 ∑ j = 1 n C [ j ] = ∑ j = 1 n ω j p [ j ] + ∑ j = 1 n v [ j ] u [ j ] + D = ∑ j = 1 i ω j ( ( a [ j ] / u [ j ] ) k j m + b ( ∑ r = 1 j − 1 ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 j − 1 ( 1 + b l m ) ) j m )       + ∑ j = i + 1 n ω j ( ( a [ j ] / u [ j ] ) k ( j − i ) m + b μ ( j − i ) m )       + ∑ j = i + 1 n ω j b ( ( 1 + σ ) ∑ r = 1 i ( a [ r ] / u [ r ] ) k r m ∏ l = r + 1 i ( 1 + b l m ) ) ( j − i ) m       + ∑ j = i + 1 n ω j b ( ∑ r = i + 1 j − 1 ( a [ r ] / u [ r ] ) k ( r − i ) m ∏ l = r + 1 j − 1 ( 1 + b l m ) ) ( j − i ) m + ∑ j = 1 n v [ j ] u [ j ] + D = ∑ j = 1 n Ω j ( a [ j ] / u [ j ] ) k + ∑ j = i + 1 n b μ ω j ( j − i ) m + ∑ j = 1 n v [ j ] u [ j ] + D (2) 其中 ω j = { α ( j + i σ ) + n γ ( 1 + σ ) + δ 1 ( 1 + σ ) + δ 2 [ n − j + 1 + ( n − i ) σ ] ,     j = 1 , 2 , ⋯ , i α j + n γ + δ 1 + δ 2 ( n − j + 1 ) ,     j = i + 1 , i + 2 , ⋯ , s − 1 β ( n − j ) + δ 1 + δ 2 ( n − j + 1 ) ,     j = s , s + 1 , ⋯ , n (3) D = [ α i + n γ + δ 1 + δ 2 ( n − i ) ] μ (4) Ω 1 = ω 1 1 m + b ω 2 1 m 2 m + b ω 3 1 m ( 1 + b 2 m ) 3 m + ⋯ + b ω i 1 m i m ∏ l = 2 i − 1 ( 1 + b l m )     + b ( 1 + σ ) ω i + 1 1 m 1 m ∏ l = 2 i ( 1 + b l m ) + b ( 1 + σ ) ω i + 2 1 m 2 m ∏ l = 2 i ( 1 + b l m ) + ⋯     + b ( 1 + σ ) ω n 1 m ( n − i ) m ∏ l = 2 i ( 1 + b l m ) Ω 2 = ω 2 2 m + b ω 3 2 m 3 m + b ω 4 2 m ( 1 + b 3 m ) 4 m + ⋯ + b ω i 2 m i m ∏ l = 3 i − 1 ( 1 + b l m )     + b ( 1 + σ ) ω i + 1 1 m 2 m ∏ l = 3 i ( 1 + b l m ) + b ( 1 + σ ) ω i + 2 2 m 2 m ∏ l = 3 i ( 1 + b l m ) + ⋯     + b ( 1 + σ ) ω n 2 m ( n − i ) m ∏ l = 3 i ( 1 + b l m ) ⋯ (5) Ω i − 1 = ω i − 1 ( i − 1 ) m + b ω i ( i − 1 ) m i m + b ( 1 + σ ) ω i + 1 1 m ( i − 1 ) m ( 1 + b i m )     + b ( 1 + σ ) ω i + 2 2 m ( i − 1 ) m ( 1 + b i m ) + ⋯ + b ( 1 + σ ) ω n ( n − i ) m ( i − 1 ) m ( 1 + b i m ) Ω i = ω i i m + b ( 1 + σ ) ω i + 1 1 m i m + b ( 1 + σ ) ω i + 2 2 m i m + ⋯ + b ( 1 + σ ) ω n ( n − i ) m i m Ω i + 1 = ω i + 1 1 m + b ω i + 2 1 m 2 m + b ω i + 3 1 m ( 1 + b ( i + 2 ) m ) 3 m + ⋯ + b ω n 1 m ( n − i ) m ∏ l = i + 2 n − 1 ( 1 + b l m ) Ω i + 2 = ω i + 2 2 m + b ω i + 3 2 m 3 m + b ω i + 4 2 m ( 1 + b ( i + 3 ) m ) 4 m + ⋯ + b ω n 2 m ( n − i ) m ∏ l = i + 3 n − 1 ( 1 + b l m ) ⋯ Ω n − 1 = ω n − 1 ( n − 1 − i ) m + b ω n ( n − 1 − i ) m ( n − i ) m Ω n = ω n ( n − i ) m 2) 如果在加工 J [ s ] 之后进行维护，即 i ≥ s ，那么总费用为： Z ( q , u , π ) = ∑ j = 1 n ( α E [ j ] + β T [ j ] + γ q + v [ j ] u [ j ] ) + δ 1 C max + δ 2 ∑ j = 1 n C [ j ] = ∑ j = 1 n Φ j ( a [ j ] / u [ j ] ) k + ∑ j = i + 1 n b μ υ j ( j − i ) m + ∑ j = 1 n v [ j ] u [ j ] + E (6) 其中 υ j = { α j + β ( n − i ) σ + n γ + δ 1 ( 1 + σ ) + δ 2 [ n − j + 1 + ( n − i ) σ ] ,     j = 1 , 2 , ⋯ , s − 1 β [ n − j + ( n − i ) σ ] + δ 1 ( 1 + σ ) + δ 2 [ n − j + 1 + ( n − i ) σ ] ,     j = s , s + 1 , ⋯ , i β ( n − j ) + δ 1 + δ 2 ( n − j + 1 ) ,     j = i + 1 , i + 2 , ⋯ , n (7) E = [ β ( n − i ) + δ 1 + δ 2 ( n − i ) ] μ (8) Φ 1 = υ 1 1 m + b υ 2 1 m 2 m + b υ 3 1 m ( 1 + b 2 m ) 3 m + ⋯ + b υ i 1 m i m ∏ l = 2 i − 1 ( 1 + b l m )       + b ( 1 + σ ) υ i + 1 1 m 1 m ∏ l = 2 i ( 1 + b l m ) + b ( 1 + σ ) υ i + 2 1 m 2 m ∏ l = 2 i ( 1 + b l m ) + ⋯       + b ( 1 + σ ) υ n 1 m ( n − i ) m ∏ l = 2 i ( 1 + b l m ) Φ 2 = υ 2 2 m + b υ 3 2 m 3 m + b υ 4 2 m ( 1 + b 3 m ) 4 m + ⋯ + b υ i 2 m i m ∏ l = 3 i − 1 ( 1 + b l m )       + b ( 1 + σ ) υ i + 1 1 m 2 m ∏ l = 3 i ( 1 + b l m ) + b ( 1 + σ ) υ i + 2 2 m 2 m ∏ l = 3 i ( 1 + b l m ) + ⋯       + b ( 1 + σ ) υ n 2 m ( n − i ) m ∏ l = 3 i ( 1 + b l m ) ⋯ (9) Φ i − 1 = υ i − 1 ( i − 1 ) m + b υ i ( i − 1 ) m i m + b ( 1 + σ ) υ i + 1 1 m ( i − 1 ) m ( 1 + b i m )       + b ( 1 + σ ) υ i + 2 2 m ( i − 1 ) m ( 1 + b i m ) + ⋯ + b ( 1 + σ ) υ n ( n − i ) m ( i − 1 ) m ( 1 + b i m ) Φ i = υ i i m + b ( 1 + σ ) υ i + 1 1 m i m + b ( 1 + σ ) υ i + 2 2 m i m + ⋯ + b ( 1 + σ ) υ n ( n − i ) m i m Φ i + 1 = υ i + 1 1 m + b υ i + 2 1 m 2 m + b υ i + 3 1 m ( 1 + b ( i + 2 ) m ) 3 m + ⋯ + b υ n 1 m ( n − i ) m ∏ l = i + 2 n − 1 ( 1 + b l m ) Φ i + 2 = υ i + 2 2 m + b υ i + 3 2 m 3 m + b υ i + 4 2 m ( 1 + b ( i + 3 ) m ) 4 m + ⋯ + b υ n 2 m ( n − i ) m ∏ l = i + 3 n − 1 ( 1 + b l m ) ⋯ Φ n − 1 = υ n − 1 ( n − 1 − i ) m + b υ n ( n − 1 − i ) m ( n − i ) m Φ n = υ n ( n − i ) m 引理7：对于问题1)的一个给定排序，可以得到最优资源分配如下： 对于 i < s 的情况： u [ j ] * = ( k Ω j / v [ j ] ) 1 / ( k + 1 ) ( a [ j ] ) k / ( k + 1 ) ,     j = 1 , 2 , ⋯ , n (10) 其中 Ω j 由式(5)给定。 另外，对于 i ≥ s 的情况： u [ j ] * = ( k Φ j / v [ j ] ) 1 / ( k + 1 ) ( a [ j ] ) k / ( k + 1 ) ,     j = 1 , 2 , ⋯ , n (11) 其中 Φ j 由式(9)给定。 证明：下面只证 i < s 的情况，对于 i ≥ s 的情况可以类似地证明。式(2)对 u [ j ] ( j = 1 , 2 , ⋯ , n ) 求导，并令其导数等于0，得 u [ j ] * = ( k Ω j / v [ j ] ) 1 / ( k + 1 ) ( a [ j ] ) k / ( k + 1 ) 。 引理8： [ 13 ] 假设存在两个数列 { M j } 和 { N j } ， j = 1 , 2 , ⋯ , n 。其中一个数列按递增顺序排列，另一个数列按递减顺序排列，则对应元素乘积的和 ∑ j = 1 n M j N j 最小。 对于 i < s 的情况，将式(10)代入式(2)，得到目标函数 Z ( q , u , π ) 在最优资源分配下的一个新的统一表达式： Z ( q , u * ( π ) , π ) = ( k − k / ( k + 1 ) + k 1 / ( k + 1 ) ) ∑ j = 1 n ( v [ j ] a [ j ] ) k / ( k + 1 ) ( Ω j ) 1 / ( k + 1 ) + ∑ j = i + 1 n b μ ω j ( j − i ) m + D 其中 ω j , D , Ω j 分别由式 ( 3 ) , ( 4 ) , ( 5 ) 给定。 对于 i ≥ s 的情况，将式(11)代入式(6)，得到目标函数 Z ( q , u , π ) 在最优资源分配下的一个新的统一表达式： Z ( q , u * ( π ) , π ) = ( k − k / ( k + 1 ) + k 1 / ( k + 1 ) ) ∑ j = 1 n ( v [ j ] a [ j ] ) k / ( k + 1 ) ( Φ j ) 1 / ( k + 1 ) + ∑ j = i + 1 n b μ υ j ( j − i ) m + E 其中 υ j , E , Φ j 分别由式 ( 7 ) , ( 8 ) , ( 9 ) 给定。 明显地，极小化上边两个式子给出的 Z ( q , u * ( π ) , π ) 分别等价于极小化 ∑ j = 1 n ( v [ j ] a [ j ] ) k / ( k + 1 ) ( Ω j ) 1 / ( k + 1 ) 和 ∑ j = 1 n ( v [ j ] a [ j ] ) k / ( k + 1 ) ( Φ j ) 1 / ( k + 1 ) 。 因此，对于问题1)可以给出如下最优算法： 算法1 第一步 根据引理5，计算出公共松弛时间的最优位置 s = ⌈ n ( β − γ ) / ( α + β ) ⌉ ； 第二步 令维护位置 r = 1 ； 第三步 对于 j = 1 , 2 , ⋯ , n ，计算 ( v [ j ] a [ j ] ) k / ( k + 1 ) 和 ( Ω j ) 1 / ( k + 1 ) 或 ( Φ j ) 1 / ( k + 1 ) 。 第四步 根据引理8对这些工件重新编号，得到一个局部最优排序，并计算出总费用； 第五步 r = r + 1 ，如果 ，那么执行第三步；否则，执行第六步； 第六步 全局的最优排序是局部最优排序中总费用最小的排序； 第七步 根据式(10)或(11)计算出最优资源分配 u [ j ] * ，并计算最优排序中的每个工件实际加工时间，松弛交货期 d * 。 定理1 对于问题1)，利用算法1可以通过求解匹配问题在 O ( n 2 log n ) 时间内得到最优解。 证明 定理的正确性由上述分析保证。第一、三步的时间复杂度为 O ( 1 ) ，第四步的时间复杂度为 O ( n log n ) 。因为任一工件完工后都可立即进行维护，所以必须对n个不同的维护位置进行评估进而得到全局最优解。因此求解问题(1)的时间复杂度为 O ( n 2 log n ) 。证毕。"
"本文研究了带有可变加工时间和维护的松弛交货期与凸资源分配的单机排序问题。确定了最优工件排序、最优公共松弛时间、最优维护位置和最优资源分配方案，使得由工件的提前惩罚、延误惩罚、交货期公共松弛时间、资源分配费用、最大完工时间和总完工时间构成的总费用最小。根据优化的相关知识，将问题转化为匹配问题，证明了该问题在多项式时间内是可解的，给出了多项式时间最优算法。"
