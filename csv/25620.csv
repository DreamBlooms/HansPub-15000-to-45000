"研究了离散时间多智能体系统中的一致性问题。在不使用任何全局信息的情况下，将粒子群的变步长算法应用到最小均方(LMS)算法中进行多智能体局部自调，实现了多智能体的一致性。在这个过程中，网络模型的代价函数取决于智能体的状态和邻居状态平均值之间的误差。同时证明了网络图强连通的情况下，所有的智能体状态将达到一致性。最后，通过在不同拓扑结构下的仿真实例对提出的算法进行验证。 关键词 :多智能体系统，一致性，自调优，最小均方算法 Copyright © 2018 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"近年来，多智能体系统的协调控制问题受到了系统与控制领域专家学者的广泛关注。在多智能体系统网络中，一致性问题作为协调控制的代表性问题，也是其它分布式控制和估计的研究基础。系统达到一致性，也就是多智能体系统中每个智能体的状态在一致性协议或者算法的控制下渐进地或者在有限时间内达到相同的数值。随着多智能体协调控制的研究深入，一致性问题已经成为当前研究的热点问题，在理论和实际的应用方面都取得了很多的成果。它是多智能体系统的分布式控制研究中的基本问题之一，在交汇问题、编队控制、传感器网络的信息融合等方面有广泛应用 [ 1 ] - [ 10 ] 。 一致性理论的早期研究始于管理科学，分布式计算以及在自然界中出现的蜂群、鸟群和鱼群等常见的集群行为。在过去的二十年中，大量的论文涵盖了群集和分布式编队、分布式优化和估计、通信和传感器网络、耦合振荡器同步问题等方面的问题。2013年，Cao等人对近年来在多智能体协调方面的进展进行了较为全面的综述 [ 11 ] 。2006年，Zhou，Lu等人提出动态网络自适应一致性，作者假设整个自治网络的解是已知的，并且每个智能体使用全局信息作为智能体状态跟踪的参考，局部控制输入与智能体状态与此参考状态之间的误差成正比，并且证明了这个误差收敛到零 [ 12 ] 。2008年，Zhou，Lu等人在复杂网络中假设同步解决方案是已知的或有限制性的，得出了相似的结果 [ 13 ] 。2009年，DeLellis等人证明了全局同步依赖于自适应变化的耦合增益施加的循环条件。要求收益矩阵依赖于耦合半负定时刻 [ 14 ] 。2009年，Das等人考虑了每个智能体都必须跟踪已知或估计的领导者轨迹的问题。在未知参数和已知基函数的基础上，用一个中立的网络结构来表示非线性动力学 [ 15 ] 。2012年，Yu等人对领导者的动力学进行了类似的参数化。领导者的轨迹是全局信息，智能体间的耦合参数是一个非自适应的，它的值对于网络的所有节点都是相同的 [ 16 ] 。2013年，Li等人提出了连续时间自适应一致性问题的研究。作者分析了无向图，并假设已知输入增益对所有智能体都是相同的。证明了每个智能体的状态都收敛于所有智能体状态的平均值 [ 17 ] 。2015年，Miloje等人提出了多智能体系统的自适应一致性协议，不应用任何全局信息，应用定步长的自适应一致性算法，最后证明了每个智能体的状态都趋于所有智能体初始状态的平均值 [ 18 ] 。 总的来说，上述的研究工作对多智能体一致性的发展做出了有益的理论和实践探索。但是也存在一定的问题：一方面，需要考虑多智能体的状态到达一致性的时间问题，比如加快智能体的收敛速度；另一方面，在切换拓扑网络中的应用需要进行验证。 针对上述问题，我们在Miloje等人提出的多智能体自适应一致性协议的基础之上，提出了一种基于LMS的变步长自调优一致性协议。我们考虑了有向图拓扑，在不使用任何全局信息的情况下，每个智能体都通过最小化其本地代价函数和基于变步长LMS的参数估计器来生成耦合系数的值。代价函数等于智能体状态与其邻居状态平均值之间的局部误差的平方。结果表明，基于LMS的变步长自调优一致性算法是收敛的，所有的智能体状态都趋于一致的值。"
"在多智能体系统一致性问题的研究中，图论是非常重要的分析工具。通常，用记号 G = { V , E , A } 表示一个加权的有向图。其中， V = { v 1 , v 2 , ⋯ , v n } 表示具有n个节点的节点集合，它的边集合 E ⊆ V × V ，节点的下标集合 I = { 1 , 2 , ⋯ , n } ；邻接矩阵 A = [ a i j ] ∈ R n × n ，当有向边 ( v i , v j ) ∈ E 时，表示节点 v j 可以获得 v i 的信息，此时 a i j > 0 ；否则， a i j = 0 [ 19 ] 。 定义节点i的邻居集合： N i = { j : a i j > 0 } 。 矩阵 D = d i a g { d i , i = 1 , 2 , ⋯ , n } ， d i = ∑ j = 1 n a i j 为矩阵A的第i行元素之和，称为节点i的出度，矩阵 L = D − A 为图G的拉普拉斯矩阵 [ 20 ] 。 最小均方算法简称LMS算法，是一种最陡下降算法的改进算法，是在维纳滤波理论上运用速下降法后的优化延伸，最早是由Widrow和Hoff提出来的。LMS算法是一种随机梯度算法。它以系统均方误差为代价函数，利用随机估计值代替最速下降法中的梯度向量，在统计意义上以最速下降方向收敛到Wiener解。其具有计算复杂程度低、在信号为平稳信号的环境中收敛性好、其期望值无偏地收敛到维纳解和利用有限精度实现算法时的平稳性等特性，使LMS算法成为自适应算法中稳定性最好、应用最广的算法 [ 21 ] 。在本文中应用最小均方算法。  考虑一组用离散时间积分器来表示的N个智能体： x i ( t + 1 ) = x i ( t ) + β i u i ( t ) ,     i = 1 , ⋯ , N (1) x i ( t ) ∈ R ， u i ( t ) ∈ R 分别表示智能体在离散时间 t = 0 , 1 , 2 , ⋯ 时的状态和控制输入。 β i 表示第i个智能体的输入增益。假设 β i 的符号已知，但是它的大小是一个未知数。公式(1)可以被视为一组连续时间多智能体系统的离散版本 [ 18 ] 。 在本文中，考虑以下简单的一致性协议： u i ( t ) = ∑ j ∈ N i θ i j ( t ) ( x j ( t ) − x i ( t ) ) (2) θ i j ( t ) 是控制参数，也是要进行估计的数值，以便智能体的状态 x i ( t ) 收敛到相同的值。例如， lim t → ∞ x i ( t ) = x c , ∀ i ∈ V , x c ∈ R (3) x c 为多智能体系统的状态变量达到一致的数值。在本文中，提出了基于LMS的变步长算法自适应地调整参数 θ i j ( t ) 。定义参数向量： θ i ( t ) T = [ θ i 1 ( t ) l i 1 , ⋯ , θ i N ( t ) l i N ] , ∀ i ∈ v (4) 这里的 l i j 是指示函数，定义如下： l i j = { 1         j ∈ N i 0         其 他 所以(2)中的 u i ( t ) 可以写为如下的形式 u i ( t ) = θ i ( t ) T φ i ( t ) (5) φ i ( t ) 是信号向量，定义如下： φ i ( t ) T = [ ε i 1 ( t ) l i 1 , ⋯ , ε i N ( t ) l i N ] (6) 其中： ε i j ( t ) = x j ( t ) − x i ( t ) (7) 由于 β i 是未知的，智能体i将会自调整参数向量 θ i ( t ) ，使得下面的代价函数最小化： J i ( θ i ) = 1 2 ( x i ( t + 1 ) − x ¯ i ( t + 1 ) ) 2 (8) 这里的 x ¯ i ( t + 1 ) 是第i个智能体邻居状态的平均值（也包含其自身的值） x ¯ i ( t + 1 ) = 1 1 + N ∑ j ∈ N i x j ( t ) , N ¯ i = N i ∪ { i } (9) 其中N是 N i 中元素的个数。 假设 β i 的符号是已知的，参数向量 θ i ( t ) 可以通过使用以下归一化LMS算法来估计： θ i ( t + 1 ) = θ i ( t ) − μ i sgn ( β i ) φ i ( t ) e i ( t + 1 ) r i ( t ) (10) 其中： r i ( t ) = 1 + ‖ φ i ( t ) ‖ 2 (11) e i ( t + 1 ) = x i ( t + 1 ) − x ¯ i ( t + 1 ) (12) 这里的 x ¯ i ( t + 1 ) 由公式(9)定义。在公式(10)中， μ i > 0 是步长参数，提出的这个算法的步长是改变的，在每次的迭代过程中，改变这个参数，加快收敛的速度。 sgn ( β i ) 是 β i 的符号。公式(10)从任意初始条件 θ i ( 0 ) 开始迭代。将 u i ( t ) 从公式(5)中代入公式(1)中可以得到： x i ( t + 1 ) = x i ( t ) + β i θ i ( t ) T φ i ( t ) (13) 由公式(8)给出的 J i ( θ i ) 对 θ i ( t ) 的梯度是： ∂ J i ( θ i ) ∂ θ i ( t ) = e i ( t + 1 ) ∂ x i ( t + 1 ) ∂ θ i ( t ) = β i φ i ( t ) e i ( t + 1 ) (14) 其中 e i ( t + 1 ) 由公式(12)定义。因此公式(10)中的第二项等于公式(8)的负梯度并进行规范化，而 β i 被替换为其符号标示。 公式(13)可以写成如下的紧凑的形式： x ( t + 1 ) = W ( t ) x ( t ) (15) 这里的 x ( t ) 是： x ( t ) T = [ x 1 ( t ) , x 2 ( t ) , ⋯ , x N ( t ) ] (16) 而 W ( t ) ∈ R N × N 是耦合权重矩阵，定义如下: W ( t ) = [ w i j ] , w i j ( t ) = { β i θ i j ( t ) ,                         j ∈ N i 1 − ∑ K ∈ N i β i θ i j ( t ) ,       j = i 0 ,                                             其 他 (17)  假设图G是强连通的，且对所有的 i = 1 , 2 , ⋯ , N ，公式(10)中的步长 μ i 是可变的，并且步长 μ i 满足 μ i < 2 / β i max 。 由公式(9)给出的 x ¯ i ( t + 1 ) 可以写成： x ¯ i ( t + 1 ) = a i T x ( t ) (18) 这里的 x ( t ) 由公式(16)定义的。 a i T = [ a i 1 , ⋯ , a i N ] , a i j = { 1 1 + N i     j ∈ N i , j = i 0                             其 他 (19) 定义： e ( t ) T = [ e i ( t ) , ⋯ , e N ( t ) ] (20) 从公式(12) (16) (18)可以得到： x ( t + 1 ) = A x ( t ) + e ( t + 1 ) (21) 矩阵 A ∈ R N × N ， A = [ a i j ] 中的 a i j 是由公式(19)中定义。注意到A是具有正对角元素的随机矩阵。由于假设图是强连通的，非负矩阵A是不可约的，因此，矩阵A在 λ 1 = 1 处，只有一个特征值，其他的特征值 λ i , 2 ≤ i ≤ N ，满足 | λ i | < 1 。 l = ( 1 , ⋯ , 1 ) T 是对应于 λ i = 1 的右特征向量。让 y A 的作为矩阵A对应于特征值 λ 1 的左特征向量并且标准化，得到 y A T l = 1 。因此，矩阵A可以分解为： A = A 1 + l y A T ,       l t A T = 1 (22) 其中 A 1 l = 0 , y A T A 1 = 0 ，并且 A 1 的谱半径满足 ρ ( A 1 ) < 1 。把(22)带入(21)可以得到： x ( t + 1 ) = A 1 x ( t ) + l y A T x ( t ) + e ( t + 1 ) (23) 定义： H ( q − 1 ) = ( I − q − 1 A 1 ) − 1 (24) 这里的 q − 1 是单位延迟算子。由于 A 1 l = 0 可以得到 H ( q ) − 1 l = ( I + ∑ k = 1 ∞ q − k A 1 k ) l = l 。再由公式(23)可以得到： x ( t + 1 ) = l y A T x ( t ) + H ( q − 1 ) e ( t + 1 ) (25) 让 ϕ i ( t ) = x ( t ) − x i ( t ) l , i ∈ v (26) 由公式(25) (26)可以得到： ϕ i ( t + 1 ) = l y A T ( x ( t ) − l x i ( t ) ) + l y A T l x i ( t ) − l x i ( t + 1 ) + H ( q − 1 ) e ( t + 1 ) (27) 由于 y A T l = 1 ，因此公式(27)可以写为： ϕ i ( t + 1 ) = l y A T ϕ i ( t ) + l [ x i ( t ) − x i ( t + 1 ) ] + H ( q − 1 ) e ( t + 1 ) (28) 公式(9)可以写成： x ¯ i ( t + 1 ) = x i ( t ) + b i T ϕ i ( t ) (29) 其中 b i 为： b i T = [ b i 1 , ⋯ , b i N ] , b i j = { 1 1 + N i     j ∈ N i 0                       其 他 (30) 然后由公式(12)给出的误差 e i ( t + 1 ) 可以表示为： e i ( t + 1 ) = x i ( t + 1 ) − x i ( t ) − b i T ϕ i ( t ) (31) 通过把公式(31)的 x i ( t + 1 ) − x i ( t ) 代入公式(28)，可以得到下式： ϕ i ( t + 1 ) = Q i ϕ i ( t ) − l e i ( t + 1 ) + H ( q − 1 ) e ( t + 1 ) (32) 其中： Q i = l ( y A − b i ) T (33) b i T = [ b i 1 , ⋯ , b i N ] , b i j = { 1 1 + N i     j ∈ N i 0                     其 他 (34) 公式(33)中的矩阵 Q i 的秩为1，它唯一的非零特征值为： ρ 1 = l T ( y A − b i ) = 1 − l T b i = 1 − ∑ k = 1 N b i k = 1 − N i 1 + N i < 1 因此存在正常数 c 0 ，使得对于所有的 k ≥ 0 ， ‖ Q i k ‖ ≤ c 0 ρ 1 k , 0 < ρ 1 < 1 。 从公式(32)可以得到： ϕ i ( t + 1 ) = Q i t + 1 ϕ i ( 0 ) + ∑ k = 0 t Q i t − k [ H ( q − 1 ) e ( k + 1 ) − l e i ( k + 1 ) ] (35) 可以得到： ‖ ϕ i ( t + 1 ) ‖ 2 ≤ c 1 ρ 1 k + c 2 ∑ k = 0 t ρ 1 t − k ‖ e ( k + 1 ) ‖ 2 (36) 其中， c 1 ， c 2 均为常数。式(36)两边从 t = 0 到 t = n 两边求和得到下式： ∑ t = 0 n ‖ ϕ i ( t + 1 ) ‖ 2 ≤ c 1 + c 2 ∑ t = 0 n ‖ e ( t + 1 ) ‖ 2 , ∀ n ≥ 0 (37) 由公式(6)和公式(18)得到 x ¯ i ( t + 1 ) = x i ( t ) + a i T φ i ( t ) ，再结合公式(12)和公式(13)可以得到推出如下公式： e i ( t + 1 ) = θ ˜ i ( t ) φ i ( t ) (38) e i ( t + 1 ) 由公式(12)定义，并且： θ ˜ i ( t ) = β i θ i ( t ) − a i (39) 再结合公式(10)得到： θ ˜ i ( t + 1 ) = θ ˜ i ( t ) − μ i | β i | r i ( t ) φ i ( t ) e i ( t + 1 ) (40) 将公式(40)两边平方后得到： V i ( t + 1 ) = V i ( t ) − 2 μ i | β i | r i ( t ) θ ˜ i ( t ) φ i ( t ) e ( t + 1 ) i + ( μ i β i ) 2 r i ( t ) ⋅ φ i ( t ) 2 r i ( t ) e i ( t + 1 ) 2 (41) 这里的 V i ( t ) = ‖ θ ˜ i ( t ) ‖ 2 ，把公式(38)中的 θ ˜ i ( t ) φ i ( t ) 带入到公式(41)，并且由公式(11) r i ( t ) = 1 + ‖ φ i ( t ) ‖ 2 可以得到 ( ‖ φ i ( t ) ‖ 2 / r i ( t ) ) ≤ 1 ，可以得到： V i ( t + 1 ) ≤ V i ( t ) − 2 μ i | β i | ( 1 − μ i | β i | 2 ) ∑ t = 0 n e i ( t + 1 ) 2 r i ( t ) (42) 把公式(42)的两边从 t = 0 到 t = n 进行求和，可以得到下式： V i ( n + 1 ) + 2 μ i | β i | ( 1 − μ i | β i | 2 ) ∑ t = 0 n e i ( t + 1 ) 2 r i ( t ) ≤ V i ( 0 ) (43) 由于 μ i | β i | > 0 ，并且开始的假设成立，所以 μ i | β i | < 2 。因此，对于所有的 n ≥ 0 ∑ t = 0 n e i ( t + 1 ) 2 r i ( t ) ≤ c 3 < ∞ , i ∈ v (44) 其中 c 3 是常数。 定义： r ¯ ( t ) = ∑ i = 1 N max 1 ≤ τ ≤ t r i ( τ ) (45) 可以由公式(44)得到： ∑ t = 0 n ‖ e ( t + 1 ) ‖ 2 r ¯ ( t ) ≤ c 4 ≤ ∞ (46) 其中， c 4 是常数， e ( t ) 由公式(20)定义。如果 { r ¯ ( t ) } , t ≥ 0 是一个有界的序列，则由公式(46)可以得到： ∑ t = 0 n ‖ e ( t + 1 ) ‖ 2 ≤ c 5 < ∞ (47) 其中， c 5 为常数。而如果 lim t → ∞ r ¯ ( t ) = + ∞ ，则由克罗内克引理可以得到： lim n → ∞ 1 r ¯ ( n ) ‖ e ( t + 1 ) ‖ 2 = 0 (48) 由公式(6)和公式(26)可以得到 ‖ φ i ( t ) ‖ ≤ ‖ ϕ i ( t ) ‖ ，再应用公式(11) (37) (45)可以得到： r ¯ ( n ) ≤ c 6 + c 7 ∑ t = 0 n ‖ e ( t + 1 ) ‖ 2 (49) 其中， c 6 和 c 7 均为常数。由公式(48) (49)得到： ∑ t = 0 n ‖ e ( t + 1 ) ‖ 2 ≤ c 8 < ∞ (50) 其中， c 8 为常数。由公式(37)(47)以及 ‖ φ i ( t ) ‖ ≤ ‖ ϕ i ( t ) ‖ 得到： ∑ t = 0 n ‖ φ i ( t ) ‖ 2 ≤ ∑ t = 0 n ‖ ϕ i ( t ) ‖ 2 ≤ c 9 ≤ ∞ (51) 其中， c 9 为常数。最后，由公式(26)和公式(51)可以得到： lim t → ∞ ( x ( t ) − x i ( t ) l ) = 0 , i ∈ v (52) 证明了该多智能体系统的一致性。"
"在这个仿真示例中，首先应用一个由5个智能体组成的网络。其中，该一致协议中的耦合参数由公式(10)定义的变步长LMS递归生成。多智能体系统的拓扑结构如图1所示： 公式(10)中的步长 μ i 采用固定步长时，如果步长过大或过小，可能导致多智能体系统收敛速度慢，后期可能不会收敛。因此，在算法的运行初期保持较大的值，随着迭代次数的增加，步长自适应的进行减小。因此，在多次的实验的情况下，将 μ i 的初始数值设置为较大的数值，在之后的迭代过程中设置为可变步长 μ i = μ i − 0.001 × n , i ∈ v ，让其随着迭代次数的增加而减小。 表1显示了每个智能体的初始位置和初始的速度。 对图1所示的拓扑结构进行仿真，仿真结果如图2和图3所示。 由于图1所示的拓扑结构含有有向生成树，多智能体的状态变量最后达到了一致。图2显示了每个智能体状态 x i ( t ) , i ∈ v 的收敛。图3显示了每个智能体的方向和位置信息。 如果改变该多智能体系统的拓扑结构，使得该图不含有生成树。如图4所示。 对图4所示的拓扑结构进行仿真。仿真结果如图5和图6所示。 图1. 含有生成树的拓扑结构 Table 1 初始位置分量x 初始位置分量y 初始速度分量vx 初始速度分量vy 智能体1 0.5 2 0 3 智能体2 1 2 1 2 智能体3 1.5 2 4 1 智能体4 2 2 3 3 智能体5 2.5 2 3 1 表1. 智能体的初始位置和初始速度 图2. 智能体速度的幅值 图3. 智能体的位置和方向 图4. 不含生成树的拓扑结构 图5. 智能体速度的幅值 图6. 智能体的位置和方向 由仿真结果可以看到，由于图4所示的拓扑结构不含有向生成树，所以得到的多智能体系统的状态变量没有实现一致性。也可以由图4所示的拓扑结构图进行直观的分析，由于智能体5不接收任何智能体的信息，所以，智能体5的状态一直保持不变。智能体2也不接收其他智能体的任何信息，所以智能体1、3、4的状态值最后收敛到智能体2的状态值。"
"本文针对多智能体系统的一致性问题进行了研究，提出了一种基于LMS的变步长自调优一致性算法，证明了该算法收敛。最后通过在不同拓扑结构中仿真，验证了所设计一致性算法的正确性。"
