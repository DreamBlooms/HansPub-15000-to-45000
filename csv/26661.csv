"本文主要研究张量的分解算法及其应用。在张量的T-SVD [ 1 ]算法的基础上提出TST-SVD算法，并且解决了T-SVD算法在分解时可能无法保留其主要信息的情况。而我们的TST-SVD则通过软阈值的方法可以很好地保留其主要信息，并且对于噪音图片也可以达到很好去噪效果。在图片的识别和重构方面也有着不错的表现。 关键词 :T-SVD算法，TST-SVD算法，软阈值，图片的识别和重构 Copyright © 2018 by author and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"张量分解早在19世纪就被提出来了，随着计算机的发展张量活跃在各个领域。例如在神经影像，信号处理，化学统计学，计算机视觉，心理测验学，数据挖掘，图像处理等领域有着极其重要的应用。由于数据的复杂性以及我们所需要的一些特征，这就需要我们研究张量的内部结构特征。张量的经典分解有CP分解 [ 2 ]和Tucker分解 [ 2 ]，CP分解表示为由一系列秩一的向量外积之和，Tucker表示一个核张量 [ 2 ]与因子矩阵的n模积。 Tamara G. Kold和Brett W. Bader在2007发表了一篇关于张量的分解和应用的综述 [ 2 ]，文章讲解了什么是张量，如何做张量分解以及张量的一些应用。文章也提到了经典的CP分解和Tucker分解，也列举了其他的一些分解方法，并且用对比试验分析了它们的优缺点，给予研究人员很大的启发。Genevera I. Allen [ 3 ]提出了一种稀疏的CP分解算法，基于张量乘积的稀疏CP分解算法，创新性的使用软阈值操作以达到分解成分稀疏的效果。Eric C. Chi和Tamara G. Kolda [ 4 ]提出了基于泊松分布的张量分解模型，利用非线性Gauss-Seidel来构造优化函数加入一些约束条件得出KKT条件求得最优解。经过迭代到收敛得出新的稀疏非负的分解。Will Wei Sun [ 5 ]等人在Genevera I. Allen在稀疏CP分解的基础上提出了截断的张量CP分解，也取得了不错的效果。Misha E. Kilmer [ 1 ]等人提出了对张量做矩阵操作的张量T-SVD分解方法。这些算法在不同情况下已经被证实可以取得不错的效果。 这篇文章中我们提出了一个新的张量分解TST-SVD，它是在Misha E. Kilmer等人的基础上对其算法缺点做了修改并且实验结果也达到了预期的效果。针对T-SVD算法中直接对重构张量进行压缩处理而导致某些重要信息缺失的情况，我们对分解出的成分做软阈值操作以达到稀疏效果和保留重要信息的作用。 本文的组织结构如下：第2章介绍张量；第3章介绍张量的T-SVD并且详细讨论T-SVD算法及其总流程；第4章详细讲解我们新的算法(TST-SVD)；第5章为实验设置和结果分析；第6章总结全文。"
"张量是一个多维数组 [ 2 ]，一个零阶张量对应一个标量，一个一阶对应一个向量，一个二阶对应一个矩阵。一个三阶对应一个立方体 A ∈ R I × J × K 如图1，一个n阶张量表示为 X ∈ R I 1 × I 2 × ⋯ × I N 。 图1. 3阶张量 A ∈ R I × J × K 图2. 3阶张量的切片 向量的第i个元素表示为 a i ，矩阵的第 ( i , j ) 个元素表示为 a i j ，同样三阶张量的第 ( i , j , k ) 个元素可以表示为 a i j k ，高阶张量以此类推。 张量的切片如图2所示。"
"它是在傅里叶域中一种基于矩阵的新的分解形式，类似与矩阵的奇异值分解他们有一些相似的性质。这对于张量是一个很实用的方法。 张量的T-SVD分解，A是一个 n 1 × n 2 × n 3 的实数张量，则A可以表示为： A = U ∗ S ∗ V T (1)  由张量frontal切片组成的块循环矩阵： circ ( A ) = [ A ( 1 ) A ( n 3 ) A ( n 3 − 1 ) ⋯ A ( 2 ) A ( 2 ) A ( 1 ) A ( n 3 ) ⋯ A ( 3 ) ⋮ ⋱ ⋱ ⋱ ⋮ A ( n 3 ) A ( n 3 − 1 ) ⋯ A ( 2 ) A ( 1 ) ] (2) 其中 A ∈ R n 1 × n 2 × n 3 的张量， A ( i ) 是张量A的 n 1 × n 2 的frontal切片， circ ( A ) 是一个 n 1 n 3 × n 2 n 3 的块循环矩阵。 我们定义MatVec操作， MatVec ( A ) 的作用是把 n 1 × n 2 × n 3 的张量变成了一个 n 1 n 3 × n 2 n 3 的块矩阵，fold操作是对MatVec的一个还原。两个操作如下： MatVec ( A ) = [ A ( 1 ) A ( 2 ) ⋮ A ( n 3 ) ] ,     fold ( MatVec ( A ) ) = A (3)  我们来定义一个张量的t-product： A ∗ B = fold ( circ ( A ) ⋅ MatVec ( B ) ) (4) 其中 A ∈ R n 1 × n 2 × n 3 ， B ∈ R p × n 2 × n 3 。  前面我们对矩阵做了一些操作使其具备了某些性质：块矩阵可以通过傅里叶变换变成块对角矩阵。这就意味着，当 A ∈ R n 1 × n 2 × n 3 ，F是一个正则化的 n 3 × n 3 的DFT (Discrete Fourier Transform)矩阵，则存在 n 3 个 n 1 × n 2 的矩阵 D i 使得： ( F ⊗ I ) circ ( A ) ( F * ⊗ I ) = blockdiag ( D 1 , D 2 , ⋯ , D n 3 ) (5)  当张量是f-diagonal (对角)时，则他的每个frontal slice都是对角的。同样地，当张量是f-upper triangular或f-lower triangular时，则张量的frontal slice是上三角或者下三角。 定理1：A是一个 n 1 × n 2 × n 3 的实数张量，则A的分解为： A = U ∗ S ∗ V T (6) 其中 U , V 分别是 n 1 × n 2 × n 3 和 n 2 × n 2 × n 3 的正交张量，S是一个 n 1 × n 2 × n 3 的f-diagonal张量。这就是张量的T-SVD分解 [ 6 ]。 证明：首先我们把A变换成公式(2)的傅里叶域中，接着我们计算每个 D i 的SVD，则 D i = U i Σ i V i T ( i = 1 , 2 , ⋯ , n 3 ) [ D i ⋱ D n 3 ] = [ U 1 ⋱ U n 3 ] [ Σ 1 ⋱ Σ n 3 ] [ V 1 T ⋱ V n 3 T ] (7) 由公式(2)可得(6)式。  算法1： 1) 输入 n 1 × n 2 × n 3 的张量A。 2) 把A映射到傅里叶域中， D = f f t ( A , [   ] , 3 ) 。 3) 对张量D的每一个frontal slice做矩阵的奇异值分解，得到的每个 u , s , v 都分别存储在 U ( : , : , i ) , S ( : , : , i ) , V ( : , : , i ) 中。 4) 在分别对 U , S , V 做一个傅里叶逆变换。就可以得到张量A的奇异值分解。  一个 n 1 × n 2 × n 3 张量的A，它的T-SVD分解为 A = U ∗ S ∗ V T 。 k < min ( n 1 , n 2 ) ，则有 A k = ∑ i = 1 k U ( : , i , : ) ∗ S ( i , i , : ) ∗ V ( : , i , : ) T (8)  算法2： 1) 输入 n 1 × n 2 × n 3 的张量A，截断k。 2) 用算法1得出 U ( : , i , : ) , S ( i , i , : ) , V ( : , i , : ) 。 3) 分别计算 U ( : , i , : ) 的 k 1 个奇异值分解， S ( i , i , : ) ∗ V ( : , i , : ) 的 k 2 个奇异值分解。 4) 计算 σ i μ ( j ) λ ( l ) ‖ circ ( q ( j ) ) t ( l ) ‖ ∞ > tol [ 6 ]当满足条件时，可以得出张量A的截断T-SVD。  我们定义两个操作squeeze和twist。 1) squeeze可以把张量矩阵化， X : = squeeze ( x ) ⇒ X ( i , j ) : = x ( i , 1 , j ) 。 2) twist把矩阵张量化， twist ( squeeze ( x ) ) = x 。 其中 x ∈ R n 1 × 1 × n 3 。我们可以用它们来构造图片的张量矩阵，当M为图片的平均值矩阵，则 A ( : , j , : ) = twist ( X j − M ) , j = 1 , ⋯ , m 。其中 A ( : , j , : ) 是张量A的lateral slice， X j 是第j张图片。"
"张量的TST-SVD是张量的T-SVD算法和张量的软阈值CP分解算法的基础上改进的。张量的TST-SVD在张量截断T-SVD算法的基础上合理的引入了软阈值操作。由于张量的T-SVD算法在去噪方面对于某些特征图片并没有很好地优化，因此加入了软阈值操作可以很好地平滑去噪。TST-SVD在人脸识别方面与传统的PCA和T-SVD相比有着较好的效果。  软阈值操作的公式为 S ( · , ρ ) = sign ( · ) ( | · | − ρ ) + · [ 3 ]， U = sign ( U ) ( | U | − ρ U ∗ I U ) + U S = sign ( S ) ( | S | − ρ s ∗ I S ) + S V = sign ( V ) ( | V | − ρ V ∗ I V ) + V 其中 ρ 是软阈值参数，在这里通过多次试验当 ρ U = 0.001 时软阈值效果最好。I是元素全为1的张量并且与它们各自的规模相同。  算法3： 1) 输入 n 1 × n 2 × n 3 的张量A，截断k。 2) 用算法1得出 U ( : , i , : ) , S ( i , i , : ) , V ( : , i , : ) 。 3) 分别计算 U ( : , i , : ) 的 k 1 个奇异值分解， S ( i , i , : ) ∗ V ( : , i , : ) 的 k 2 个奇异值分解。 4) 计算 σ i μ ( j ) λ ( l ) ‖ circ ( q ( j ) ) t ( l ) ‖ ∞ > tol [ 6 ]当满足条件时，得出 U , S , V 。 5) 分别对 U , S , V 做软阈值 S ( · , ρ ) 操作，得出最终的张量TST-SVD分解。  由于U是正交的， U st 是U的正交集合。并且 U st ∗ U st T 是一个正交投影，它把图片投影到更小的空间维度中。我们对张量A的lateralslice进行投影： A ( : , j , : ) ≈ U st ∗ U st T ∗ A ( : , j , : ) = ∑ t = 1 k U st ∗ C ( t , j , : ) (9) 其中 C ( : , j , : ) = U st T ∗ A ( : , j , : ) ，C就是我们图片投影的系数。当做人脸识别时，我们只需比较训练图片的投 影系数与测试图片的投影系数即可。 算法4： 1) 输入训练集图片 I i , i = 1 , 2 , ⋯ , N ；测试图片J。 2) 计算训练集图片的均值，得出均差图片 ς i 。然后把每张图片以 ς i → A ( : , i , : ) 的形式存储到张量A的lateral slice中。 3) 由算法3得出U的软阈值 U st ， U st T ∗ A 表示训练集的正交投影。 4) 对测试图片做均值处理，再做一个 twist ( J − M ) → T ( : , 1 , : ) 的变换，对 T ( : , 1 , : ) 做正交投影 B ← U st T ∗ T 得出测试图片的投影系数C。 5) 对测试图片的系数与训练图片的系数做2-范数，直到收敛。 6) 找出2-范数最小的那个就可以找出训练集图片的位置，从而达到识别的效果。"
"为了比较张量的TST-SVD算法的性能，本文将TST-SVD算法，T-SVD算法和经典的PCA算法用于Yale faces [ 7 ]的人脸识别实验，并对实验结果进行结果对比分析。  我们选取10个不同的人，每个人有10种不同的表情，图片的大小是100 px × 100 px。第一组我们随机选取每个人的3个表情作为训练集的30张图片，剩下的70张图片作为测试集。第二组我们随机选取每个人的4个表情作为训练集的40张图片，剩下的60张图片作为测试集。第三组我们随机选取每个人的5个表情作为训练集的50张图片，剩下的50张图片作为测试集。第四组我们随机选取每个人的6个表情作为训练集的60张图片，剩下的40张图片作为测试集。第五组我们随机选取每个人的7个表情作为训练集的70张图片，剩下的30张图片作为测试集。分别使用上述的三种算法，针对每个组进行实验。并记录实验结果的人脸识别率和人脸重构的情况。实验平台为MATLAB R2014a。  为了使实验更加有效每组做20次实验所得的人脸识别率取平均值。其中人脸识别率等于识别正确的个数与测试集总数之比。在多次实验中TST-SVD的软阈值操作U的阈值为0.001时实验效果最好，在这里我们也取 ρ U = 0.001 (表1)。 我们再来比较TST-SVD与PCA的重构图片效果如何。重构图片的公式为： J ≈ U ∗ U T ∗ J + M [ 8 ]。 由图3可以看出在相同训练集和测试集的情况下TST-SVD的识别率更高。图4可以看出在图片重构方面TST-SVD也有着不错的表现。 Table 1 算法 30 40 50 60 70 TST-SVD 0.7857 0.8333 0.7600 0.9500 0.7333 T-SVD 0.7100 0.8010 0.7000 0.9000 0.6900 PCA 0.6000 0.7500 0.6777 0.8500 0.6333 表1. TST-SVD，T-SVD和PCA的平均人脸识别率 图3. TST-SVD，T-SVD和PCA的算法识别率对比图 图4. TST-SVD与PCA的重构图片对比图"
"原T-SVD算法的截断操作有可能会导致丢失重要的信息，而我们的TST-SVD算法找到了一种可以更好保留重要信息的能力，因为它加入了软阈值操作可以对重要信息进行平滑的去噪。在图像识别方面也取得了不错的效果。当重构图片时，加入软阈值之后的正交投影可以更好地重构图片的主要信息。在跟PCA算法做重构图片对比时，TST-SVD重构的图片明显比PCA更好。"
