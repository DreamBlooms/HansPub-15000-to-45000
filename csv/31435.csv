"本文在机器学习(ML)的正则化风险函数模型(SRM)的基础上，结合求解非光滑函数的束方法，提出了一种求解经验风险函数模型的算法，用割平面模型去近似目标函数，用非精确线搜索去获得步长，在适当的假设下，分析了算法的全局收敛和收敛速度。 关键词 :机器学习，束方法，风险最小化，全局收敛 Copyright © 2019 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"本文主要考虑以下最优化问题(文 [ 1 ] ): min w J ( w ) : = λ Ω ( w ) + R e m p ( w ) , (1.1) 其中， R e m p ( w ) : = 1 m ∑ i = 1 m l ( x i , y i , w ) 是经验风险函数。 x i ∈ X ⊆ R d 是训练实例， y i ∈ Y 是相应的标签。l是一个凸的损失函数，用来衡量y与通过w产生的预测值之间的差异，例如， l ( x , y , w ) = ( 〈 w , x 〉 − y ) 2 ，其中 〈 ⋅ ， ⋅ 〉 定义为标准的欧几里得内积。最后， Ω ( w ) 是一个凸函数且作为正则化项，而 λ ≥ 0 是正则化参数。特别的， Ω ( w ) 是可微的且易于计算。与之相反的，经验风险函数项 R e m p ( w ) 通常是不可微的，而且它的计算代价总是很大的(文 [ 2 ] )。 目前，各种各样的机器学习问题都可以描述成一类最小化正则风险函数问题，具体地，不同的机器学习算法会形成不同的风险函数和正则化项，例如：线性支持向量机(SVMs)，逻辑回归，条件随机场(CRFs)等等。因而研究此类凸优化问题具有重要的理论和现实意义。本文在束方法的基础上，结合一类BMRM算法，对BMRM算法的精确线搜索进行改进，推广到非精确的情形，给出一个改进的BMRM算法来求解正则化风险函数问题，在一定条件下，证明算法的全局收敛性。"
"机器学习问题建立在最优化基础理论上，为了更好的研究机器学习，下面将简要介绍与最优化理论相关的基本概念和一些重要结论，次梯度和束方法等。先介绍一些记号，其中：序列或者集合元素的索引记在下标，如 u 1 , u 2 。向量u的第i个分量记为 u ( i ) ， [ k ] 表示集合 { 1 , 2 , ⋯ , k } ， L p 范数定义为： ‖ u p ‖ = ( ∑ i = 1 d | u ( i ) | p ) 1 / p ，这里的 p ≥ 1 ，然后使用 ‖ ⋅ ‖ 来定义 ‖ ⋅ ‖ 2 。 次梯度(文 [ 3 ] )：对于一类非光滑的凸函数，次梯度是对于梯度的一个近似，假设 w ′ 是凸函数J上的一点， s ′ 是J在点 w ′ 处的次梯度，当且仅当： 对任意的w，有 J ( w ) ≥ J ( w ′ ) + 〈 w − w ′ , s ′ 〉     成立 (2.1) 则在 w ′ 处所有的次梯度组成的集合叫做次微分，记为 ∂ w J ( w ′ ) 。 切平面模型(CPM) (文 [ 4 ] )： 给定点 w 0 , w 1 , ⋯ , w t − 1 处的次梯度 s 1 , s 2 , ⋯ , s t ，产生一系列分段线性下界来迫近J： J ( w ) ≥ J t C P ( w ) : = max 1 ≤ i ≤ t { J ( w i − 1 ) + 〈 w − w i − 1 , s i 〉 } . (2.2) 迭代点 w t 的更新： w t : = arg min w J t C P ( w ) . (2.3) 切平面模型(CPM)的模型迭代过程不断改进分段线性下界 J C P ，且使整个模型逐步逼近J的最小值。 邻近束方法(Proximal Bundle Methods) (文 [ 5 ] )： 虽然切平面模型是收敛的，但是当新的迭代点与上一个迭代点距离较大时，切平面模型收敛速度很慢。为了改进切平面模型的不稳定性，邻近束方法通过增加一个邻近函数来改进下一个点的选取，其中，一般选取 1 2 ‖ ⋅ ‖ 2 作为邻近函数： w t : = arg min w { ζ t 2 ‖ w − w ^ t − 1 ‖ 2 + J t C P ( w ) } . (2.4) 这里 w ^ t − 1 是最近的邻近中心， ζ t 是正邻近项参数。但是，这样的改进会使束方法需要对参数进行仔细地调整。"
"结合次梯度和邻近束方法，文章 [ 6 ] 提出了一种新的机器学习凸优化算法：BMRM算法。在求解一类机器学习问题(1.1)时，对于每一次迭代t，BMRM算法都会构建下界 R t C P 来近似经验风险函数 R e m p ，而新的迭代点 w t 则由最小化 J t 更新， J t 由 R t C P 与正则项 Ω 组成。这是BMRM算法和邻近束方法的最大不同。 实际上，BMRM算法不涉及邻近中心，进一步，BMRM算法甚至不包括邻近项。 BMRM算法具体如下： 算法1 (BMRM算法) 步骤1：输入及初始化： ε ≥ 0 , w 0 , t : = 0 步骤2：循环： t : = t + 1 ，计算： a t ∈ ∂ ω R e m p ( w t − 1 ) , b t : = R e m p ( w t − 1 ) − 〈 w t − 1 , a t 〉 , 步骤3：(更新模型) R t C P : = max 1 ≤ i ≤ t { 〈 w , a i 〉 + b i } 步骤4：(迭代点更新) w t : = arg min w J t ( w ) : = λ Ω ( w ) + R t C P (w) 步骤5： ε t : = min 0 ≤ i ≤ t J ( w i ) − J t (wt) 步骤6：直到 ε t ≤ ε ，返回 w t 与邻近束方法相比较，BMRM算法有两点不同： a) BMRM算法是用一个分段线性下界来接近 R e m p ( w ) 而不是 J ( w ) 。 b) 在邻近束方法中，邻近项( ζ 2 ‖ w − w ^ t ‖ 2 )被正则化项 Ω ( w ) 替代，因此，就不需要调整邻近参数了。 进一步，考虑存在有效的精确线搜索时，BMRM算法可以实现更快速的收敛，所以，结合线搜索的BMRM算法如下(文 [ 4 ] )： 算法2 (结合精确线搜索的BMRM算法) 步骤1：输入及初始化： ε ≥ 0 , θ ∈ ( 0 , 1 ] , w 0 b , w 0 c : = w 0 b , t : = 0 步骤2：循环： t : = t + 1 ，计算： a t ∈ ∂ ω R e m p ( w t − 1 c ) , b t : = R e m p ( w t − 1 c ) − 〈 w t − 1 c , a t 〉 , 步骤3：(更新模型) R t C P : = max 1 ≤ i ≤ t { 〈 w , a i 〉 + b i } 步骤4： w t : = arg min w J t ( w ) : = λ Ω ( w ) + R t C P (w) 步骤5：(线搜索) η t : = arg min η ∈ R J ( w t − 1 b + η ( w t − w t − 1 b ) ) w t b : = w t − 1 b + η t ( w t − w t − 1 b ) w t c : = ( 1 − θ ) w t b + θ w t 步骤6： ε t : = min 0 ≤ i ≤ t J ( w t b ) − J t (wt) 直到 ε t ≤ ε ，返回 w t b 。 注意到，对所有的t，如果设 η t = 1 ，则算法2可以简化为算法1，且两个算法使用相同的终止准则.值得注意的是，带线搜索的BMRM算法并不能应用于结构化的机器学习问题，例如：最大边际马尔科夫网络问题。"
"在机器学习的优化问题中，算法2中的精确线搜索往往需要计算很多的函数值和梯度值，这样的话会产生较大的计算代价，特别是当迭代点离最优点比较远的时候，精确线搜索往往不是最有效和合理的。所以，对于许多像问题(1.1)的机器学习凸优化问题，非精确线搜索既能保证目标函数具有可接受的下降量，又能使最终形成的迭代序列收敛，以下将考虑非精确线搜索和BMRM算法的结合。 算法3 (结合非精确线搜索的BMRM算法) 步骤1：输入及初始化： ε ≥ 0 , θ ∈ ( 0 , 1 ] , w 0 b , w 0 c : = w 0 b , t : = 0 步骤2：循环： t : = t + 1 ，计算： a t ∈ ∂ ω R e m p ( w t − 1 c ) , b t : = R e m p ( w t − 1 c ) − 〈 w t − 1 c , a t 〉 , 步骤3：(更新模型) R t C P : = max 1 ≤ i ≤ t { 〈 w , a i 〉 + b i } 步骤4： w t : = arg min w J t ( w ) : = λ Ω ( w ) + R t C P (w) 步骤5：(线搜索)内循环： m : = 0 , β ∈ ( 0 , 1 ) , σ ∈ ( 0 , 0.5 ) if   J ( w t − 1 b + β m ( w t − w t − 1 b ) ) ≤ J ( w t − 1 b ) + σ β m ( a t + λ Ω ′ ( w ) ) ( w t − w t − 1 b ) η t = β m m : = m + 1 步骤6：更新点列： w t b : = w t − 1 b + η t ( w t − w t − 1 b ) w t c : = ( 1 − θ ) w t b + θ w t 步骤7： ε t : = min 0 ≤ i ≤ t J ( w t b ) − J t (wt) 直到 ε t ≤ ε ，返回 w t b 。 在证明算法3的收敛性之前，先介绍相关引理。 定义4.1 (Fenchel对偶) 定义 Ω : W → R 是一个在凸集W上的凸函数，则 Ω 的对偶 Ω ∗ 定义为： Ω ∗ ( μ ) : = sup w ∈ W 〈 w , μ 〉 − Ω ( w ) . 定理4.1 定义 A = [ a 1 , ⋯ , a t ] 的列向量为(次)梯度， b = [ b 1 , ⋯ , b t ] ，则问题： w t : = arg min w ∈ R d { J t ( w ) : = max 1 ≤ i ≤ t 〈 w , a i 〉 + b i + λ Ω ( w ) } (4.1) 的对偶问题为： α t = arg max α ∈ R t { J t ∗ ( α ) : = − λ Ω ∗ ( − λ − 1 A α ) + α T b | α ≥ 0 , ‖ α ‖ 1 = 1 } (4.2) 此外， w t 和 α t 之间有对偶关系式 w t = ∂ Ω ∗ ( − λ − 1 A α t ) 。 证明：首先将(4.1)式改写成一个带约束的最优化问题： min w , ξ λ Ω ( w ) + ξ st .         ξ ≥ 〈 w , a i 〉 + b i 式中 i = 1 , 2 , ⋯ , t 。通过引入非负的拉格朗日乘子 α 和元素都是1的t维向量 1 t ，相应的拉格朗日函数可以写成： { L ( w , ξ , α ) = λ Ω ( w ) + ξ − α T ( ξ 1 t − A T w − b ) α ≥ 0 (4.3) 式中， α ≥ 0 表示向量 α 的每一个分量都是非负的，对 ξ 求导可得： 1 − α T 1 t = 0 。此外，对变量w最小化L意味着求解问题： max w 〈 w , − λ − 1 A α 〉 − Ω ( w ) = Ω ∗ ( − λ − 1 A α ) . 把上述两项插回到(4.3)式中，就可以消除了原始变量 ξ 和w。得证。 推论4.1 当 Ω ( w ) = 1 2 ‖ w ‖ 2 2 时，即取二次正则项的时候，(4.2)式可以写成： α t = arg max α ∈ R t { − 1 2 λ α T A T A α + α T b | α ≥ 0 , ‖ α ‖ 1 = 1 }"
"接下来证明结合非精确线搜索的BMRM算法具有较好的收敛速度。事实上，对于求解非光滑优化问题，水平束方法收敛速度为 O ( 1 / ε 2 ) 。本文将证明，对于求解具有非光滑损失函数的正则化风险函数问题，算法3将具有 O ( 1 / ε ) 的收敛速度。更具体的说，我们将证明以下收敛性： 假设 max u ∈ ∂ w R e m p ( w ) ‖ u ‖ ≤ G ，而对于正则化项 Ω ( w ) 有 ‖ ∂ μ 2 Ω ∗ ( μ ) ‖ ≤ H ∗ ，本文将证明在上述假设下，算法具有 O ( 1 / ε ) 收敛速度，即算法将在 O ( 1 / ε ) 的迭代次数中，得到其 ε -最优解。 在以下的证明过程中，我们使用了类似于文 [ 7 ] 的技术： 定理5.1 假设 max u ∈ ∂ w R e m p ( w ) ‖ u ‖ ≤ G   对于所有的 w ∈ d o m J 成立，且 ‖ ∂ μ 2 Ω ∗ ( μ ) ‖ ≤ H ∗ 对于所有的 μ ∈ { − λ − 1 ∑ i = 1 t + 1 α i α i } 成立，这里 α i ≥ 0 ，且对 ∀ i 有 ∑ i = 1 t + 1 α i = 1 成立，即，存在： ε t − ε t + 1 ≥ ε t 2 min ( 1 , λ ε t 4 G 2 H ∗ ) . 证明：定理5.1的证明参考文献 [ 4 ] 。 定理5.2 假设对于所有的w有 J ( w ) ≥ 0 ，在定理5.1成立的条件下，可以证明算法1的收敛性。即对任 意的 ε < 4 G 2 H ∗ λ ，算法会在至多： n ≤ log 2 λ J ( 0 ) G 2 H ∗ + 8 G 2 H ∗ λ ε − 1 步后，收敛到所需精度。 证明：定理5.2的证明参考文献 [ 4 ] 。 在证明算法3收敛性之前先介绍相关引理。 引理5.1 J t + 1 ( w t ) = λ Ω ( w t ) + 〈 w t , a t + 1 〉 + b t + 1 。 证明：由 w t b 和 w t 与 w t − 1 b 的关系，且 w t c 是 w t 和 w t b 的凸组合，此外，根据 a t + 1 和 b t + 1 的定义，得到 J ( w t c ) = J t + 1 ( w t c ) 。因此有： J ( w t c ) = J t + 1 ( w t c ) = λ Ω ( w t c ) + 〈 a t + 1 , w t c 〉 + b t + 1 ≥ J ( w t b ) . (5.1) 因为 Ω 是凸的，所以： Ω ( ( 1 − θ ) w t b + θ w t ) ≤ ( 1 − θ ) Ω ( w t b ) + θ Ω ( w t ) , 即： θ ( Ω ( w t b ) − Ω ( w t ) ) ≤ Ω ( w t b ) − Ω ( w t c ) , 上式两边乘以 λ ，然后加上 θ R e m p ( w t b ) 和减去 θ R t ( w t ) 得： λ θ   Ω ( w t b ) + θ R e m p ( w t b ) − λ θ   Ω ( w t ) − θ R t ( w t ) ≤ λ Ω ( w t b ) + R e m p ( w t b ) − λ Ω ( w t c ) − ( 1 − θ ) R e m p ( w t b ) − θ R t ( w t ) , 结合算法3的步骤7： θ ε t ≤ J ( w t b ) − λ Ω ( w t c ) − ( 1 − θ ) R e m p ( w t b ) − θ R t ( w t ) , (5.2) 联立(5.1)和(5.2)： 〈 a t + 1 , w t c 〉 + b t + 1 ≥ J ( w t b ) − λ Ω ( w t c ) ≥ ( 1 − θ ) R e m p ( w t b ) + θ R t ( w t ) + θ ε t 由 w t c = ( 1 − θ ) w t b + θ w t 可得： ( 1 − θ ) 〈 a t + 1 , w t b 〉 + θ 〈 a t + 1 , w t 〉 + b t + 1 ≥ J ( w t b ) − λ Ω ( w t c ) ≥ ( 1 − θ ) R e m p ( w t b ) + θ R t ( w t ) + θ ε t , 化简得： ( 1 − θ ) ( 〈 a t + 1 , w t b 〉 − R e m p ( w t b ) ) + θ ( 〈 a t + 1 , w t 〉 − R t ( w t ) ) + b t + 1 ≥ J ( w t b ) − λ Ω ( w t c ) ≥ θ ε t . (5.3) 因为 〈 w t b , a t + 1 〉 + b t + 1 是凸函数 R e m p 的泰勒近似，所以有： R e m p ( w t b ) ≥ 〈 w t b , a t + 1 〉 + b t + 1 (5.4) 把(5.4)带入(5.3)，得到： ( 1 − θ ) ( − b t + 1 ) + θ ( 〈 w t b , a t + 1 〉 − R t ( w t ) ) + b t + 1 ≥ θ ε t 两边除以 θ > 0 ，得到： 〈 w t b , a t + 1 〉 + b t + 1 ≥ R t ( w t ) + ε t 又： R t + 1 ( w t ) = max ( 〈 w t , a t + 1 〉 + b t + 1 , R t ( w t ) ) = 〈 w t , a t + 1 〉 + b t + 1 J t + 1 ( w t ) = λ Ω ( w t ) + R t + 1 (wt) 故： J t + 1 ( w t ) = λ Ω ( w t ) + 〈 w t , a t + 1 〉 + b t + 1 . 引理5.2 ε t − ε t + 1 ≥ J t + 1 ( w t + 1 ) − J t ( w t ) 。 证明： ε t − ε t + 1 = J ( w t b ) − J t ( w t ) − J ( w t + 1 b ) + J t + 1 ( w t + 1 ) = J ( w t b ) − J ( w t + 1 b ) + J t + 1 ( w t + 1 ) − J t ( w t ) ≥ J t + 1 ( w t + 1 ) − J t ( w t ) . 引理5.3 令 α t 如定理4.1中的定义， A ¯ : = [ a 1 , ⋯ , a t + 1 ] 和 b ¯ : = [ b 1 , ⋯ , b t + 1 ] ，则在定理5.1里下述条件成立 max u ∈ ∂ w R e m p ( w ) ‖ u ‖ ≤ G 情况下，下式成立： [ − α t , 1 ] T A ¯ T A ¯ [ − α t , 1 ] ≤ 4 G 2 . 证明：首先，有对偶关系 ∂ w λ Ω ( w t ) = − A α t ，且(4.2)在第t迭代时， α t ≥ 0 和 ‖ α t ‖ 1 = 1 ，随后，因为 ∂ w λ Ω ( w t ) 在 a t ′ ∈ ∂ w R e m p ( w t ′ c ) , ∀ t ′ ≤ t 的凸包里面，因此 ‖ ∂ w λ Ω ( w t ) ‖ ≤ G ，接下来，由Cauchy-Schwarz不等式得： [ − α t , 1 ] T A ¯ T A ¯ [ − α t , 1 ] = ‖ ∂ w λ Ω ( w t ) + a t + 1 ‖ 2 = ‖ ∂ w λ Ω ( w t ) ‖ 2 + 2 ∂ w λ Ω ( w t ) T a t + 1 + ‖ a t + 1 ‖ 2 ≤ 4 G 2 . 引理5.4 对满足以下递推条件： c > 0 是一个常数，当 t ≥ 1 时 ρ t − ρ t + 1 ≥ c ( ρ t ) 2 的非负序列 〈 ρ 1 , ρ 2 , ⋯ 〉 ，有当整数 t ≥ 1 时： ρ t ≤ 1 c ( t − 1 + 1 ρ 1 c ) . 此外，当 t ≥ 1 c ρ − 1 ρ 1 c + 1 时：总有 ρ t ≤ ρ 成立。 证明：此引理通过归纳法易得，参考文献 [ 8 ] 。 定理 5.3 在定理5.1成立条件下，算法3收敛到任意 ε < 4 G 2 H ∗ / λ 精度需要： n ≤ 8 G 2 H ∗ λ ε 步。 证明：对于 ε < 4 G 2 H ∗ λ ，结合定理5.1及其证明过程，易知： ε t − ε t + 1 ≥ λ ε t 2 8 G 2 H ∗ 又由引理5.4可知 ε t ≤ 1 c ( t − 1 + 1 ε 1 c ) ，这里 c = λ 8 G 2 H ∗ 。令 1 c ( t − 1 + 1 ε 1 c ) = ε ，假设 ε 1 > 0 ，然后 解出n，有： n ≤ 1 c ε = 8 G 2 H ∗ λ ε ."
