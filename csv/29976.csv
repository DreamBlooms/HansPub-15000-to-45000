"针对一般约束优化问题，本文提出了一类新的无参数填充函数，分析该函数的理论性质并设计算法，利用Python编程语言进行数值实验并且与前人结果进行比较，表明该填充函数算法不仅是有效的而且在处理某些函数时效果更好。进一步地，尝试将该算法与化学实验酶促反应的反应速度和反应浓度关系的处理结合，实验结果表明该算法在实际应用中也有较好的适应性。 关键词 :全局优化，无参数填充函数，酶促反应，最小二乘 Copyright © 2019 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"非线性规划，作为数学规划的重要组成部分在经营管理、工程设计、科学研究、军事指挥等方面得到广泛的应用。近年来有关全局优化的理论和算法层出不穷。全局优化方法大致可分为三类：1) 在局部极小点中搜寻全局极小点，一般来说就是调用辅助函数跳出当前局部极小点得到更优的局部极小点；2) 采用启发式或者随机搜索方法如模拟退火算法，遗传算法、人工神经网络法等；3) 针对特殊结构的问题采用特定的解决方法如D.C规划。而本文所研究的内容是属于第一类，构造填充函数来求取全局极小点。填充函数法首先由西安交通大学葛仁溥教授 [ 1 ] 在1984年提出，是一类较为有效的确定性全局优化方法。随后其在文献 [ 2 ] 中对最初提出的双参数填充函数进行改进，提出了一类性能更优的单参数填充函数。 上海大学的张连生教授 [ 3 ] 对填充函数的定义进行改进，并提出一系列性能更优的填充函数；而且在张教授科研团队的深入研究下，填充函数内容越来越丰富。如：针对非线性等式约束问题，杨永健教授在文献 [ 4 ] 中提出了一类单参数填充函数；针对一般约束性优化问题，王伟祥教授在文献 [ 5 ] 中提出了一类单参数填充函数；张莹在文献 [ 6 ] 中针对非光滑约束问题提出了一类单参数填充函数。 在分析现有填充函数时发现多数研究者所构造的填充函数或者带有指数项 [ 7 ] ，或者结构比较复杂 [ 8 ] ，本文提出一种新的不带指数项的无参数填充函数，具有结构简单的优点。通过分析该填充函数的性质知：若填充函数 p ( x , x * ) > 0 ，则说明在 x 的邻域内一定存在比当前局部极小点的值更小的局部极小点。这个优良性质应用到算法设计中，可以提升算法的实用性。通过几个数值算例，表明该算法是有效的。最后通过对化学实验酶促反应中反应速度和反应浓度的关系数据的处理得知：该算法在实际应用中也有较好的适应性。"
"考虑如下问题： ( P ) { min f ( x ) , s .t .   x ∈ R n . (2.1) 其中 f : R n → R 是连续可微函数。 假设2.1：函数 f ( x ) 是强制性的，也就是当 ‖ x ‖ → + ∞ 时，有 f ( x ) → + ∞ 。 由假设2.1可以推出，一定存在一个紧集 X ⊂ R n ，它的内部包含了 f ( x ) 的所有全局极小点和函数值较小的局部极小点，而且还可以认为目标函数在 X 的边界上的函数值大于在其内部的函数值，因此，问题(2.1)可等价于如下问题： { min f ( x ) , s .t .   x ∈ X (2.2) 假设2.2：问题(2.2)的不同局部极小点的个数是有限个。 下面给出葛仁浦教授在文献 [ 1 ] 中提出的填充函数的定义。 定义2.1：函数 p ( x , x * ) 称为 f ( x ) 在局部极小点 x * 处的填充函数，如果满足： 1) x * 是 p ( x , x * ) 的一个严格局部极大点， f ( x ) 在点 x * 处的盆谷 B * 成为 p ( x , x * ) 的峰的一部分。 2) p ( x , x * ) 在比 B * 高的盆谷里没有平稳点，即 ∇ p ( x , x * ) ≠ 0 。 3) 如果存在比 B * 低的盆谷 B 1 * ，则在 x ′ 和 x * 的连线上极小化 p ( x , x * ) 得到极小点 x ″ ∈ B * ，其中， N ( x 1 * , δ 1 ) ( δ 1 > 0 ) ， x ′ ∈ N ( x 1 * , δ 1 ) 。 定义2.2：函数 f ( x ) 在一局部极小点 x * 处的盆谷是指一连通域 B * ，具有下列性质： 1) x * ∈ B * ； 2) 对于任意一点 x ∈ B * 使得 x ≠ x * 及 f ( x ) > f ( x * ) ，存在一条从 x 到c的下降路径。 针对问题(2.1)，提出了一类无参数填充函数如下： p ( x , x * ) = − ln ( 1 + ‖ x − x * ‖ 2 ) ( f ( x ) − f ( x * ) ) . (2.3) 其中 x * 是目标函数 f ( x ) 的当前局部极小点。 下面来证明该函数是符合定义(2.1)的填充函数。 定理2.1： x * 是 p ( x , x * ) 的严格局部极大点。 证明：因为 x * 是 f ( x ) 的一个局部极小点，则存在它的一个邻域 N ( x * , δ * ) ( δ * > 0 ) ，使得对于任意 x ∈ N ( x * , δ ) \ { x * } ，有 f ( x ) > f ( x * ) 。则有， p ( x , x * ) = − ln ( 1 + ‖ x − x * ‖ ) ( f ( x ) − f ( x * ) ) < 0 = p ( x * , x * ) 证毕。 定理2.2： p ( x , x * ) 在比 B * 高的盆谷 B 1 * 里没有平稳点，即 ∇ p ( x , x * ) ≠ 0 。 证明：由定理条件可知：对 ∀ x ∈ B 1 * ，有 f ( x ) > f ( x * ) ，又因为 f ( x ) 在 R n 上连续可微，可以得到 f ( x ) 在 x * 处的泰勒展开式为： f ( x ) = f ( x * ) + ( x − x * ) T ∇ f ( x ) + o ( ‖ x − x * ‖ ) 所以有： f ( x ) − f ( x * ) = ( x − x * ) T ∇ f ( x ) + o ( ‖ x − x * ‖ ) > 0 则有： ( x − x * ) T ∇ f ( x ) > 0 。 p ( x , x * ) 梯度如下： ∇ p ( x , x * ) = − [ 2 ( x − x * ) 1 + ‖ x − x * ‖ 2 ( f ( x ) − f ( x * ) ) + ln ( 1 + ‖ x − x * ‖ 2 ) ∇ f ( x ) ] 于是 ∇ p ( x , x * ) T ( x − x * ) = [ 2 ‖ x − x * ‖ 2 1 + ‖ x − x * ‖ 2 ( f ( x ) − f ( x * ) ) + ln ( 1 + ‖ x − x * ‖ 2 ) ∇ f ( x ) T ( x − x * ) ] < 0 所以 ∇ P ( x , x * ) ≠ 0 。证毕。 定理2.3：如果 x * 不是全局极小点，并且 x 1 * 是离 x * 最近的一个局部极小点并且满足 f ( x 1 * ) < f ( x * ) ，则对 ∀ x ′ ∈ N ( x 1 * , δ 1 * ) ( δ 1 * > 0 ) 则在 x ′ 和 x * 的连线上极小化 p ( x , x * ) ，得到 p ( x , x * ) 局部极小点 x ″ ∈ B * 。 证明：因为 x * 是 f ( x ) 的局部极小点，则存在 x * 的小邻域 N ( x * , δ * ) ( δ * > 0 ) ，对任意的 x ∈ N ( x * , δ * ) ，有 f ( x ) ≥ f ( x * ) ，则有 p ( x , x * ) = − ln ( 1 + ‖ x − x * ‖ 2 ) ( f ( x ) − f ( x * ) ) < 0 其中 x ∈ N ( x * , δ * ) 且 x ≠ x * 。 相似地，对于 x 1 * ，则存在它的一个小邻域 N ( x 1 * , δ 1 * ) ( δ 1 * > 0 )，对任意的 x ′ ∈ N ( x 1 * , δ 1 * ) ，有 f ( x * ) > f ( x ′ ) ≥ f ( x 1 * ) ，显然有： p ( x ′ , x * ) = − ln ( 1 + ‖ x ′ − x * ‖ 2 ) ( f ( x ′ ) − f ( x * ) ) > 0 通过分析 x ′ 和 x * 的轨迹可知：在最初 p ( x * , x * ) = 0 ，x从 x * 处开始迭代搜索，有 p ( x , x * ) < 0 ，而当 x 接近 x ′ 时，可知 p ( x , x * ) > 0 ，所以可以知道在 f ( x ) ≥ f ( x * ) 时， p ( x , x * ) 递减，在 f ( x ) < f ( x * ) 时， p ( x , x * ) 递增。由此可以知道在 x ′ 和 x * 的连线上存在 x ″ 极小化 p ( x , x * ) 。证毕。 定理2.1~定理2.3表明 p ( x , x * ) 是符合定义2.1的填充函数。下面的定理2.4表明该填充函数具有一个很好的性质，能在算法执行中快速地找到更优的局部极小点。 定理2.4：若 x * 是 f ( x ) 的全局极小点，则对任意的 x ∈ X 都有 p ( x , x * ) ≤ 0 成立；否则存在点 x * * 以及它的邻域 N ( x * * , δ ) ( δ > 0 ) ，使得对任意的 x ∈ N ( x * * , δ ) ，成立 p ( x , x * ) > 0 。 证明：若 x * 是 f ( x ) 的全局极小点，则对任意 x ∈ X ，都有 f ( x ) ≥ f ( x * ) ，所以 p ( x , x * ) = − ln ( 1 + ‖ x − x * ‖ 2 ) ( f ( x ) − f ( x * ) ) ≤ 0 ；若 x * 不是 f ( x ) 的全局极小点，则存在点 x * * 使得 f ( x * * ) < f ( x * ) ，由 f ( x ) 的连续性可知存在 x * * 的邻域 N ( x * * , δ * * ) ( δ * * > 0 ) ，则 ∀ x ∈ N ( x * * , δ * * ) 有 f ( x ) < f ( x * ) 。所以有 p ( x , x * ) > 0 。证毕。 注：由定理2.2的证明可以发现 d = x − x * 是填充函数 p ( x , x * ) 的一个下降方向；通过定理2.4可以发现，当遇到 p ( x , x * ) > 0 时，可以知道 f ( x ) < f ( x * ) ，则在算法实施过程中说明找到一个比当前局部极小点的值更小的点。"
"填充函数法是求解全局优化问题的有效方法，该方法的基本思想是：在可行域 X 中选取一点 x 0 ，利用已有的局部优化算法如最速下降法、共轭梯度法和拟牛顿法等来求出目标函数 f ( x ) 的一个局部极小点 x * ，然后在 x * 处构造一个填充函数，在 x * 的某个邻域内选取一点作为初始点，极小化填充函数，得到一点 x 1 * ，使得 f ( x 1 * ) < f ( x * ) ；然后用 x 1 * 代替 x 0 并重复上述过程，直到找到全局极小点。根据这种思想，结合本文所提出填充函数的特点以及文献的算法 [ 9 ] ，提出相应改进算法。步骤如下： 步骤0：初始化数据，设定搜索步长 δ > 0 , k = 1 ，选择方向 d i ( i = 1 , 2 , ⋯ , m ) , m ≥ 2 n ，其中 n 为变量的维度，选取一个初始点 x 0 ∈ X 。 步骤1：以 x 0 为初始点，应用局部优化算法如拟牛顿法求出 f ( x ) 的一个局部极小点 x * ，并求出局部极小值 f ( x * ) 。 步骤2：设置 i = 1 。 步骤3：如果 i ≤ m ，转步骤4；否则 x * 作为全局极小点，停止计算。 步骤4：令 x 1 = x * + δ d i ，构造 f ( x ) 在 x * 处的填充函数 P ( x , x * ) 。然后从 x 1 开始使用局部优化算法得到 P ( x , x * ) 的局部极小点 x 1 * 。 步骤5：令 x = x 1 * 。 步骤6：若 p ( x , x * ) > 0 ，则令 k = k + 1 且 x 0 = x ，转步骤1，否则令 i = i + 1 ，转步骤2，若 x ∉ X ，则令 i = i + 1 ，转到步骤3。 在步骤4中的 x 1 一般是这样选取的： m = 2 n ，令 x 1 的选取是对称的。例如对 n = 2 ， x 1 为： x * + δ ( 1 , 0 ) , x * + δ ( 0 , 1 ) , x * − δ ( 1 , 0 ) , x * − δ ( 0 , 1 )"
"为了验证本文所提出的无参数填充函数算法是有效的，应用上述算法，使用常用的几个测试函数，使用Python3.5.6进行编程计算。  1) 6-Hump Back Camel函数 [ 10 ] { min f ( x ) = 4 x 1 2 − 2.1 x 1 4 + 1 3 x 1 6 − x 1 x 2 − 4 x 2 2 + 4 x 2 4 s .t .   − 3 ≤ x 1 , x 2 ≤ 3 2) Restrign函数 [ 10 ] { min f ( x ) = x 1 2 + x 2 2 − cos ( 18 x 1 ) − cos ( 18 x 2 ) s .t .   − 1 ≤ x 1 , x 2 ≤ 1 3) 文献 [ 11 ] 中的一个二维函数(c = 0.05) { min f ( x ) = [ 1 − 2 x 2 + c * sin ( 4 π x 2 ) − x 1 ] 2 + [ x 2 − 0.5 sin ( 2 π x 1 ) ] 2 s .t .   − 10 ≤ x 1 , x 2 ≤ 10  以表格形式给出数值结果，表1~3分别对应测试函数(1)~(3)的数值结果，表4是文献 [ 11 ] 算例与本文算例的数值对照表。下面是表格中符号的解释。 k ：求解第 k 次局部极小点的迭代步数； x k ：满足 x k ∈ X 的第 k 次初始点； x k * ：第 k 个局部极小点； f ( x k * ) ：第 k 个局部极小点的目标函数值； iter ：算法迭代步数； x * ：算法最终得到的全局极小点； f ( x * ) ：算法最终得到的全局极小值。 Table 1k x k x k * f ( x k * ) 1 ( 1 2 ) ( 1.70360672 0.79608357 ) −0.21546382438372103 2 ( 0.96346164 0.76342669 ) ( 0.08984232 0.71265641 ) −1.0316284534895122 表1. 初始点为 x = ( 1 , 2 ) T Table 2k x k x k * f ( x k * ) 1 ( 1 1 ) ( 1.04075871 1.04075871 ) 0.17977496636886192 2 ( 0.69788109 0.69788109 ) ( 8.75480363 e − 12 8.75480363 e − 12 ) −2.0 表2. 初始点为 x = ( 1 , 1 ) T Table 3k x k x k * f ( x k * ) 1 ( 6 − 2 ) ( 5.71982142 − 1.9162353 ) 2.7433787691978955 2 ( 1.60870902 − 0.29679585 ) ( 1.59746304 − 0.2874076 ) 4.959859574394102e-15 表3. c = 0.05 ，初始点为 x = ( 6 , − 2 ) T Table 4 iter x * f ( x * ) 本文算例1 2 ( 0.089842 , 0.71265641 ) −1.3016284534898765 文献 [ 11 ] 2 ( 0.0899 , 0.7127 ) −1.0316 本文算例2 2 ( 8.75480363 e − 12 8.75480363 e − 12 ) −2.0 文献 [ 11 ] 6 ( 0.2718 , 0.2718 ) × e − 4 −2.0000 本文算例3 2 ( 1.59746304 − 0.2874076 ) 4.959859574394102e−15 文献 [ 11 ] 5 ( 1.8513 , − 0.4021 ) 4.8751e−9 表4. 本文算例与文献 [ 11 ] 算例对照表 本文算例与文献 [ 11 ] 算例对比表明，应用本文算法所得结果精度更高，迭代步数更少，特别对算例3而言，更好的迭代步数得到更优的全局极小点。"
"酶是一种具有特异性的高效生物催化剂，绝大多数的酶是活细胞产生的蛋白质。酶的催化条件温和，在常温、常压下即可进行。酶催化的反应称为酶促反应，要比相应的非催化反应要快 10 3 ∼ 10 17 倍。酶促反应动力学简称酶促动力学，主要研究酶促反应的速度和底物(即反应物)浓度以及其他因素的关系。在底物浓度很低时酶促反应是一级反应；当底物浓度处于中间范围时，是混合级反应；当底物浓度增加时，向零级反应过度 [ 12 ] 。 某生化系学生为了研究嘌呤霉素在某项酶促反应中对反应速度与底物浓度之间关系的影响，设计了两个实验，一个实验中所使用的酶是经过嘌呤霉素处理的，而另一个实验所用的酶是未经嘌呤霍素处理过的，所得的实验数据见表5。试根据问题的背景和这些数据建立一个合适的数学模型，来反映这项酶促反应的速度与底物浓度以及嘌呤霉素处理与否之间的关系。 Table 5 底物浓度/ppm 0.02 0.06 0.11 0.22 0.56 反应速度 处理 76 47 97 107 0。11 139 159 152 191 201 未处理 67 51 84 86 98 115 131 124 144 158 表5. 嘌呤霉素实验中的反应速度与底物浓度数据 注：ppm = 0.001%。 本文仅对嘌呤毒素处理过的数据进行拟合，为了方便处理，对数据取平均值，数据如表6： Table 6 反应物浓度 0.02 0.06 0.11 0.22 0.56 反应速度 61.5 102 131 155.5 196 表6. 对嘌呤毒素处理后数据取平均值处理  记酶促反应速度为 y ，底物浓度为 x ，二者之间的关系写作 y = f ( x , β ) ，其中 β 为参数。由酶促反应的基本性质可知，当底物浓度较小时，反应速度大致与浓度成正比(即一级反应)；当底物浓度很大，渐进饱和时，反应速度将趋于一个固定值–最终反应速度(即零级反应)。下面是针对该种性质提出的模型： 指数增长模型 y = f ( x , β ) = β 1 ( 1 − e − β 2 x ) 本文将求解系数 β 转换为下面无约束优化问题： min f ( x ) = ∑ i = 1 n ( y i − y ^ i ) 2 = ∑ i = 1 n ( β 1 ( 1 − e − β 2 x ​ ) − y ^ i ) 2 给定初始值 β 0 = ( 155 , 14 ) T ，经过2次迭代得到 β * = ( 181.54213939 , 13.10716834 ) T ，而文献 [ 12 ] 中所给出参数估计 β 1 = ( 192.0969 , 11.3846 ) T 。本文目标函数值为 918.2109 ，剩余标准差 RMSE = 17.4949 ，而 图1. 拟合曲线 文献 [ 12 ] 所得的目标函数值为 1041.9798 ，剩余标准差 RMSE = 18.6367 。由此可知，使用本文算法所得的全局极小值更小，拟合效果更好。所得拟合曲线如图1所示。"
"本文给出了一个形式简单，性能更优的填充函数，分析其性质并根据该性质设计算法，数值实验表明该算法是有效的，与文献 [ 11 ] 数值结果的比较可知，该算法在处理某些函数时，有着较好的适应性。同时，本文也尝试使用该算法求解最小二乘问题，实验结果表明该算法在实际应用中也有较好的适应性。"
