"分裂可行问题是一类应用很广泛的最优化问题。经典的CQ算法仅具有弱收敛性。为了得到强收敛性，本文通过改进文献中的算法，构造了一个具有强收敛性的算法。该算法为了避免计算有界线性算子的范数，还采用了变步长策略。并且在较弱的条件下，证明了算法的强收敛性。 关键词 :分裂可行问题，CQ算法，强收敛，投影 Copyright © 2020 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY 4.0). http://creativecommons.org/licenses/by/4.0/"
"Censor和Elfving在1994年提出了分裂可行问题(SFP)，该问题在信号处理和图像重建中已经引起了广泛的关注 [ 1 ] [ 2 ]。分裂可行问题可表述为： 找一点 x ∈ C ，使得 A x ∈ Q ， (1.1) 其中C和Q分别是Hilbert空间 H 1 和 H 2 的非空闭凸子集， A : H 1 → H 2 是有界线性算子。 为了求解分裂可行问题，Censor和Elfving在文 [ 1 ] 中提出了一种迭代算法，但是他们的算法在每次迭代时都要计算矩阵的逆。Byrne在文 [ 3 ] [ 4 ] 中提出一种不需要计算矩阵逆的CQ算法。设 P C 和 P Q 分别是C和Q上的投影算子，I表示恒等算子， A * 是线性算子A的伴随算子。则CQ算法的迭代公式如下： x k + 1 = P C ( x k − γ A * ( I − P Q ) A x k ) ， (1.2) 其中 γ ∈ ( 0 , 2 ‖ A ‖ 2 ) 。由于CQ算法(1.2)更容易实现，得到了广泛的研究。然而，为了实现CQ算法，我们必须计算或者估计有界线性算子A的范数 ‖ A ‖ ，但是在一般情况下这是非常难的任务。为了克服这一困难，许多学者构造了不依赖算子范数的变步长CQ算法 [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ]。Yang在文 [ 8 ] 考虑如下的步长： τ k : = ρ k ‖ A * ( I − P Q ) A x k ‖ ， 其中 { ρ k } 是一正实数列且满足 ∑ k = 0 ∞ ρ k = ∞ ,   ∑ k = 0 ∞ ρ k 2 < ∞ 。 同时文 [ 8 ] 还要求下面两个条件成立：(i) Q是有界集，(ii) A是列满秩矩阵。为了去掉这两个条件，Lopez在文 [ 2 ] 引入一种新的选择步长的方法： τ k : = ρ k ‖ ( I − P Q ) A x k ‖ 2 ‖ A * ( I − P Q ) A x k ‖ 2 ,   0 < ρ k < 2 。 (1.3) 但是以上算法在无穷维空间中仅有弱收敛性。Xu在 [ 10 ] 中构造了如下的强收敛算法： x k + 1 = α k u + ( 1 − α k ) P C ( x k − γ k A * ( I − P Q ) A x k ) ， (1.4) 其中 u ∈ H 1 是固定的， 0 < γ k < 2 ‖ A ‖ 2 ， { α k } 是 ( 0 , 1 ) 中的实数列。若 { α k } 满足下列条件： (C1) lim k → ∞ α k = 0 , ∑ k = 0 ∞ α k = ∞ ； (C2) ∑ k = 0 ∞ | α k + 1 − α k | < ∞ 或 lim k → ∞ α k α k + 1 = 1 。 则由上述算法生成的序列 { x k } 强收敛到问题(1.1)的一个特解 P S ( u ) 。Lopez在 [ 2 ] 中改进了算法(1.4)，给出了以下强收敛算法： x k + 1 = α k u + ( 1 − α k ) P C ( x k − τ k A * ( I − P Q ) A x k ) ， (1.5) 其中 u ∈ C 是固定的， τ k 由(1.3)给出。Lopez在文 [ 2 ] 证明了：在 { α k } 仅仅满足(C1)的条件下，由算法(1.5)生成的序列 { x k } 强收敛到问题(1.1)的一个特解 P S ( u ) 。 但是在算法(1.5)中，却要求 u ∈ C ，这样就会产生如下两个问题：(i) 对于一般的闭凸集，找 u ∈ C 比较困难，需要一个迭代算法来计算。(ii) 限制了算法(1.5)的应用。比如，在实际应用中，人们经常求问题(1.1)的最小2-范数解。通常取 u = 0 ，就可得到最小2-范数解。但是在算法(1.5)中，如果 u = 0 ∉ C ，就不能得到最小2-范数解。为了克服这一缺点，本文对算法(1.5)进行改进，构造了一个同样具有强收敛性的算法，该算法同样不需要满足条件(C2)。"
"我们首先给出一些定义和基本结论，未给出的概念可参见文 [ 11 ]。以下H表示实Hilbert空间，其内积和范数分别为 〈 ⋅ , ⋅ 〉 和 ‖   ⋅   ‖ 。在本文中， → 代表强收敛，而 ⇀ 代表弱收敛。 ω w ( x k ) 表示序列 { x k } 的所有弱聚点之集。 定义2.1 设 C ⊆ H 是非空闭凸集，对任意 x ∈ H ，x到C上的投影定义为： P C x = arg min { ‖ y − x ‖ | y ∈ C } 。 显然，若 x ∈ C ，则 x = P C ( x ) 。投影 P C 具有下面重要的性质。 引理2.1 [ 11 ] 设 C ⊆ H 是非空闭凸集，则对任意 x , y ∈ H ， (i) 〈 x − P C x , z − P C x 〉 ≤ 0 , ∀ z ∈ C ； (ii) ‖ P C x − P C y ‖ ≤ ‖ x − y ‖ ； (iii) ‖ P C x − P C y ‖ 2 ≤ ‖ x − y ‖ 2 − ‖ ( I − P C ) x − ( I − P C ) y ‖ 2 ； (iv) 〈 P C x − P C y , x − y 〉 ≥ ‖ P C x − P C y ‖ 2 ； (v) 〈 ( I − P C ) x − ( I − P C ) y , x − y 〉 ≥ ‖ ( I − P C ) x − ( I − P C ) y ‖ 2 。 引理2.2 设 a , b ∈ H ， 0 ≤ α ≤ 1 。则 ‖ α a + ( 1 − α ) b ‖ 2 ≤ ( 1 − α ) ‖ b ‖ 2 + 2 〈 α a , α a + ( 1 − α ) b 〉 。 引理2.2的证明是容易的，因此我们省略了它的证明。 引理2.3 [ 12 ] 设 { s k } 是一个非负实数列，且满足 s k + 1 ≤ ( 1 − α k ) s k + α k β k ,   k ≥ 0 ， 其中 { α k } 和 { β k } 满足：(i) { α k } ⊆ [ 0 , 1 ] ， ∑ k = 0 ∞ α k = ∞ ；(ii) lim sup k → ∞ β k ≤ 0 。则 lim k → ∞ s k = 0 。 定义2.1称函数 f : H → ℝ 在点x处是弱下半连续的，若 x k ⇀ x ，则 f ( x ) ≤ lim inf k → ∞ f ( x k ) 。 若f在每个点 x ∈ H 都是弱下半连续的，则称f是H上的弱下半连续函数。 引理2.4 [2,4]设 f ( x ) = 1 2 ‖ ( I − P Q ) A x ‖ 2 。则 (i) f是可微的凸函数； (ii) ∇ f ( x ) = A * ( I − P Q ) A x ； (iii) f是H上的弱下半连续函数； (iv) ∇ f 是 ‖ A ‖ 2 -Lipschitz连续的，即 ‖ ∇ f ( x ) − ∇ f ( y ) ‖ ≤ ‖ A ‖ 2 ‖ x − y ‖ ， x , y ∈ H 。"
"受算法(1.4)和(1.5)的启发，下面我们构造一个求解SFP的强收敛算法，并在较弱的条件下证明了算法的收敛性。 算法3.1 设 u ∈ H 1 是固定的， x 0 ∈ H 1 是任意的。给定 x k ，构造 x k + 1 如下： x k + 1 = P C ( α k u + ( 1 − α k ) ( x k − τ k A * ( I − P Q ) A x k ) ) ， (3.1) 其中 { α k } ⊆ ( 0 , 1 ) ， τ k 由(1.3)给出。 定理3.1假设SFP的解集 S ≠ ∅ ， { α k } 满足条件(C1)，且 inf k ρ k ( 2 − ρ k ) > 0 。则由算法(3.1)生成的序列 { x k } 强收敛到问题(1.1)的一个解v，这里 v = P S ( u ) 。 证明 令 u k = x k − τ k A * ( I − P Q ) A x k ， y k = α k u + ( 1 − α k ) u k 。由于 v ∈ S ，再利用引理2.1，我们有 ‖ u k − v ‖ 2 = ‖ x k − v − τ k A * ( I − P Q ) A x k ‖ 2 = ‖ x k − v ‖ 2 − 2 τ k 〈 ( I − P Q ) A x k − ( I − P Q ) A v , A x k − A v 〉     + τ k 2 ‖ A * ( I − P Q ) A x k ‖ 2 ≤ ‖ x k − v ‖ 2 − 2 τ k ‖ ( I − P Q ) A x k ‖ 2 + τ k 2 ‖ A * ( I − P Q ) A x k ‖ 2 ≤ ‖ x k − v ‖ 2 − ρ k ( 2 − ρ k ) ‖ ( I − P Q ) A x k ‖ 4 ‖ A * ( I − P Q ) A x k ‖ 2 。(3.2) 以下我们将证明分成5步。 第1步，证明 { x k } ， { u k } 和 { y k } 是有界的。由引理2.1和(3.2)式，我们有 ‖ x k + 1 − v ‖ ≤ ‖ α k ( u − v ) + ( 1 − α k ) ( u k − v ) ‖ ≤ α k ‖ u − v ‖ + ( 1 − α k ) ‖ x k − v ‖ ≤ α k ‖ u − v ‖ + ( 1 − α k ) ‖ x k − v ‖ ≤ max { ‖ u − v ‖ , ‖ x k − v ‖ } 。 由数学归纳法可得，对所有的 k ≥ 0 ， ‖ x k + 1 − v ‖ ≤ max { ‖ u − v ‖ , ‖ x 0 − v ‖ } 。 由此可知 { x k } 是有界的。再由(3.2)式可得， { u k } 也是有界的。又因为 ‖ y k − u k ‖ = α k ‖ u − u k ‖ → 0 ， 所以 { y k } 也是有界的。 第2步，证明下面的不等式成立： s k + 1 ≤ ( 1 − α k ) s k + α k β k ， (3.3) 其中 s k = ‖ x k − v ‖ 2 ， β k = 2 〈 u − v , y k − v 〉 − 1 α k ( ‖ ( I − P C ) y k ‖ 2 + ( 1 − α k ) ρ k ( 2 − ρ k ) ‖ ( I − P Q ) A x k ‖ 4 ‖ A * ( I − P Q ) A x k ‖ 2 ) 。 事实上，利用引理2.2和(3.2)，我们有 ‖ y k − v ‖ 2 = ‖ α k ( u − v ) + ( 1 − α k ) ( u k − v ) ‖ 2 ≤ ( 1 − α k ) ‖ u k − v ‖ 2 + 2 α k 〈 u − v , y k − v 〉 ≤ ( 1 − α k ) ‖ x k − v ‖ 2 + 2 α k 〈 u − v , y k − v 〉     − ( 1 − α k ) ρ k ( 2 − ρ k ) ‖ ( I − P Q ) A x k ‖ 4 ‖ A * ( I − P Q ) A x k ‖ 2 。 再由引理2.1可得 ‖ x k + 1 − v ‖ 2 = ‖ P C ( y k ) − P C ( v ) ‖ 2 ≤ ‖ y k − v ‖ 2 − ‖ ( I − P C ) y k ‖ 2 ≤ ( 1 − α k ) ‖ x k − v ‖ 2 + α k [ 2 〈 u − v , y k − v 〉 − 1 α k ( ‖ ( I − P C ) y k ‖ 2     + ( 1 − α k ) ρ k ( 2 − ρ k ) ‖ ( I − P Q ) A x k ‖ 4 ‖ A * ( I − P Q ) A x k ‖ 2 ) ] 。 所以不等式(3.3)成立。 第3步，证明 lim sup k → ∞ β k 是有限的。由于 { y k } 是有界的，所以我们有 β k ≤ 2 〈 u − v , y k − v 〉 ≤ 2 ‖ u − v ‖ ⋅ ‖ y k − v ‖ < + ∞ 。 于是 lim sup k → ∞ β k < + ∞ 。下面我们用反证法证明 lim sup k → ∞ β k ≥ − 1 。假设 lim sup k → ∞ β k < − 1 ，则存在 k 0 使得对任意 k ≥ k 0 ，有 β k ≤ − 1 。由不等式(3.3)可知，对所有 k ≥ k 0 ，不等式 s k + 1 ≤ ( 1 − α k ) s k + α k β k ≤ ( 1 − α k ) s k − α k = s k − α k ( s k + 1 ) ≤ s k − α k 成立。再由数学归纳法可得 s k + 1 ≤ s k 0 − ∑ i = k 0 k α i 。 由于 ∑ i = k 0 ∞ α i = ∞ ，故存在 K ≥ k 0 满足 ∑ i = k 0 K α i > s k 0 。于是我们有 s K + 1 ≤ s k 0 − ∑ i = k 0 K α i < 0 。 这显然与 { s k } 是非负实数列相矛盾。因此 lim sup k → ∞ β k ≥ − 1 。从而 lim sup k → ∞ β k 是有限的。 第4步，证明 lim sup k → ∞ β k ≤ 0 。既然 lim sup k → ∞ β k 是有限的，我们能取子序列 { k i } 满足 lim sup k → ∞ β k = lim i → ∞ β k i = lim i → ∞ [ 2 〈 u − v , y k i − v 〉 − 1 α k i ( ‖ ( I − P C ) y k i ‖ 2                               + ( 1 − α k i ) ρ k i ( 2 − ρ k i ) ‖ ( I − P Q ) A x k i ‖ 4 ‖ A * ( I − P Q ) A x k i ‖ 2 ) ] 。 (3.4) 由于序列 { 〈 u − v , y k i − v 〉 } 是有界的，不失一般性，我们假设极限 lim i → ∞ 〈 u − v , y k i − v 〉 存在。所以下面的极限 lim i → ∞ 1 α k i ( ‖ ( I − P C ) y k i ‖ 2 + ( 1 − α k i ) ρ k i ( 2 − ρ k i ) ‖ ( I − P Q ) A x k i ‖ 4 ‖ A * ( I − P Q ) A x k i ‖ 2 ) 也存在。由此及条件 α k i → 0 可得 lim i → ∞ ‖ ( I − P C ) y k i ‖ = 0 (3.5) 和 lim i → ∞ ‖ ( I − P Q ) A x k i ‖ 4 ‖ A * ( I − P Q ) A x k i ‖ 2 = 0 。 (3.6) 由(3.6)容易得到 ‖ u k i − x k i ‖ = τ k i ‖ A * ( I − P Q ) A x k i ‖ = ρ k i ‖ ( I − P Q ) A x k i ‖ 2 ‖ A * ( I − P Q ) A x k i ‖ → 0 。 于是，我们有 ‖ y k i − x k i ‖ = ‖ α k i ( u − x k i ) + ( 1 − α k i ) ( u k i − x k i ) ‖ ≤ α k i ‖ x k i − u ‖ + ( 1 − α k i ) ‖ u k i − x k i ‖ → 0 。 (3.7) 又由于 ‖ ( I − P Q ) A x k i ‖ 4 ‖ A * ( I − P Q ) A x k i ‖ 2 ≥ ‖ ( I − P Q ) A x k i ‖ 4 ‖ A ‖ 2 ‖ ( I − P Q ) A x k i ‖ 2 = ‖ ( I − P Q ) A x k i ‖ 2 ‖ A ‖ 2 。 所以由(3.6)可得 lim i → ∞ ‖ ( I − P Q ) A x k i ‖ = 0 。 (3.8) 下面我们证明 { x k i } 的任意弱聚点都属于S，即 ω w ( x k i ) ⊆ S 。设 x ¯ ∈ ω w ( x k i ) ，不失一般性，我们假设 x k i ⇀ x ¯ 。由 f ( x ) = 1 2 ‖ ( I − P Q ) A x ‖ 2 的弱下半连续性和(3.8)可得， 0 ≤ f ( x ¯ ) ≤ lim inf i → ∞ f ( x k i ) = lim i → ∞ f ( x k i ) = 0 。 所以 f ( x ¯ ) = 0 ，i.e. A x ¯ ∈ Q 。令 g ( x ) = 1 2 ‖ ( I − P C ) x ‖ 2 ，同样由 g ( x ) 的弱下半连续性和(3.5)可得， 0 ≤ g ( x ¯ ) ≤ lim inf i → ∞ g ( x k i ) = lim i → ∞ g ( x k i ) = 0 。 所以 g ( x ¯ ) = 0 ，i.e. x ¯ ∈ C 。于是我们证明了 ω w ( x k i ) ⊆ S 。 再由(3.7)可知 { y k i } 的任意弱聚点也都属于S。不失一般性，我们设 { y k i } 弱收敛于 y ¯ ∈ S 。因为 v = P S ( u ) ，所以由引理2.1可得 lim i → ∞ 〈 u − v , y k i − v 〉 = 〈 u − v , y ¯ − v 〉 ≤ 0 。 由(3.4)，我们有 lim sup k → ∞ β k ≤ lim i → ∞ 2 〈 u − v , y k i − v 〉 ≤ 0 。 第5步，证明 { x k } 强收敛到v。事实上，容易验证引理2.3的条件都满足。应用引理2.3到(3.3)，我们就得到 ‖ x k − v ‖ → 0 。证毕。 注3.1 (i)在算法(3.1)中，参数 α k 可选取如下： α k = 1 ( k + 1 ) p ， 0 < p ≤ 1 。 (ii)在算法(1.5)中，要求 u ∈ C ，然而在算法(3.1)中，并没有这一限制，实际上，对任意 u ∈ H 1 ，算法(3.1)均是强收敛的。特别地，若令 u = 0 ，则算法(3.1)强收敛到问题(1.1)的最小2-范数解。 (iii)在算法(3.1)中，我们并不要求条件(C2)成立。另外，和算法(1.4)相比，算法(3.1)的迭代方法也不相同。"
"本文在Hilbert空间中研究了分裂可行问题。传统的CQ算法采用常数步长，需要计算有界线性算子的范数，并且仅具有弱收敛性。为了克服这些缺点，本文中我们构造了一个具有强收敛性的算法，同时该算法采用变步长策略，从而避免了计算有界线性算子的范数。同时我们构造的算法与已有文献中的算法的形式也不太相同。"
