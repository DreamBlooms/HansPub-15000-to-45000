"记忆依赖性导数与分数阶导数相比，其核函数可以根据实际情况进行选择，具有更强的表现力。本文主要讨论一阶记忆依赖微分方程组解的存在性与唯一性。在特殊情况下找到一阶线性记忆依赖型微分方程组的准确解。首先利用分部积分对等式进行一系列的变换，然后通过构造皮卡迭代序列，进一步论证向量级数一致收敛，从而证明了当其时滞足够小，核函数一阶可微时，该方程组的解存在；再通过Grownwall不等式论证其解唯一。找到了当核函数取特定形式时，一阶线性记忆赖型微分方程组的准确解。并将其与常微分方程组的解进行比较，发现当时滞越大时两者的解越接近。 关键词 :记忆依赖型导数，分数阶导数，唯一性，存在性，皮卡迭代 Copyright © 2020 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY 4.0). http://creativecommons.org/licenses/by/4.0/"
"分数阶导数是数学领域的一个重要分支，分数阶微分算子主要有三种形式：Grunwald-Letnikov定义，Rieman-Liouvile定义和Cupto定义。而在2011年，Wang & Li [ 1 ] 参照Cupto型分数阶导数提出了新的导数——记忆依赖性导数。 定义1：设m是一个正数，对m-次可微函数 f ( t ) 。 D τ m f ( t ) = 1 τ ∫ t − τ t   K ( t − s ) f m ( s ) d s . (1) 被称为m阶记忆依赖型导数， τ ( τ > 0 ) 是时滞，它代表记忆依赖时段的长短，权重 K ( t − s ) 是一个m阶连续函数。 为了让记忆依赖性导数与普通导数的数值保持基本一致，Sun [ 2 ] 定义了新的记忆依赖性导数。 定义2：设m是一个正数，对m-次可微函数 f ( t ) 。 D τ m f ( t ) = 1 R ∫ t − τ t   K ( t − s ) f m ( s ) d s . (2) 被称为m阶记忆依赖型导数， τ ( τ > 0 ) 是时滞，它代表记忆依赖时段的长短，权重函数 K ( t − s ) 是一个m阶连续函数。这里的 R = ∫ t − τ t   K ( t − s ) d s . 令 t − s = r ，则有 R = ∫ 0 τ   K ( r ) d r . 与Caputo 型分数阶导数相比，其核函数可以根据实际情况选择。例如： 1, s − t + 1, [ ( s − t ) / τ + 1 ] , [ ( s − t ) / τ + 1 ] 2 , [ ( s − t ) / τ + 1 ] 1 4 核函数被理解为对过去的依赖程度。所以 [ ( s − t ) / τ + 1 ] , [ ( s − t ) / τ + 1 ] 2 , [ ( s − t ) / τ + 1 ] 1 4 的形式更加实用，它们都是单调函数且在 t − τ 处 K = 0 而在t处 K = 1 。除此之外，记忆依赖的区间不再依赖于一个定点而是一个滑动的区间，不会随着时间的增大而增大。 此外，Li & Wang [ 3 ] 提出了记忆依赖性微分方程，并证明了一阶非线性，二阶线性记忆依赖性微分方程的解存在且唯一。Sun [ 2 ] [ 4 ] 讨论了记忆依赖型偏微分方程数值解的问题，将记忆依赖性导数引入传统的热传导方程，以及弦振动方程。讨论了扩散系数时滞对其数值解的影响。当记忆依赖性导数一提出就引发了国内外学者的广泛关注，Ezzat [ 5 ] [ 6 ] [ 7 ]，Soumen Shaw [ 8 ] 等人将其运用在广义的热粘弹性方面。 由于Li & Wang [ 3 ] 中论证了一阶非线性以及二阶线性记忆依赖性微分方程的解存在且唯一，因此引发思考能否一阶记忆依赖性微分方程组解的存在唯一性能否论证？若其解存在且唯一能否找到其准确解？ 本文的主要目的是证明如下的一阶记忆依赖微分方程组解的存在唯一性： ( D τ U = F ( t , U ) , 0 < t ≤ h , U ( t ) = U * ( t ) , − τ ≤ t ≤ 0 , (3) 其中 U = [ u v ] ， F ( t , U ) = [ f 1 ( t , u , v ) f 2 ( t , u , v ) ] 。这里的 U * ( t ) 是已知的且在区间 [ − τ ,0 ] 连续。而这里的h是一个常数( 0 < h ≤ τ )。采用如下范数： ‖ F ( t , U ) ‖ = f 1 ( t , u , v ) 2 + f 2 ( t , u , v ) 2 , F ( t , U ) 满足范数下的Lipschiz条件即存在 L > 0 ，使得 ‖ F ( t , U 2 ) − F ( t , U 1 ) ‖ ≤ L ‖ U 2 ( t ) − U 1 ( t ) ‖ ,0 ≤ t ≤ h . 根据定义(2)经过分部积分变换可以得到： D τ U = 1 R ∫ t − τ t   K ( t − s ) ∂ U ∂ s d s = 1 R U ( t ) − 1 R ∫ t − τ t ∂ K ∂ s U ( s ) d s . (4) 将(4)带入初值问题可以得到： U ( t ) = ∫ t − τ t   ∂ s K ⋅ U ( s ) ( s ) d s + τ R ⋅ F ( t , U ) . (5) 这里的 ∂ s K = ∂ K / ∂ s ，注意到当 t ∈ ( 0, h ] 时有 t − τ ∈ ( − τ ,0 ] 。故而(5)可以写为 U ( t ) = ∫ 0 t   ∂ s K ⋅ U ( s ) d s + ∫ t − τ 0   ∂ s K ⋅ U * ( s ) d s + τ R ⋅ F ( t , U ) . (6) 则有满足等式(6)的函数即是初值问题(3)的解。 定理1：如果 F ( t , U ) 关于U满足范数下的Lipschiz条件，核函数 K ( t − s ) 在区间 [ 0, h ] 上是一阶可导且满足 K ( τ ) = 0 与 K ( 0 ) = 1 ，则当 ( M + R L ) τ < 1 时。初值问题(3)存在唯一的解，定义于区间 0 ≤ t ≤ h 上，这里 M = m a x ( t − s ) ∈ [ 0, τ ] | ∂ K / ∂ s | . 证明： 首先论证方程组解的存在性。 利用(6)构造皮卡迭代如下： U 0 ( t ) = U * ( 0 ) , t ∈ [ 0, h ] , (7) U n ( t ) = ∫ 0 t     ∂ s K ⋅ U n − 1 ( s ) d s + ∫ t − τ 0     ∂ s K ⋅ U * ( s ) d s + τ R ⋅ F ( t , U n − 1 ( t ) ) , (8) 要证明解的存在性，主要步骤是证明函数序列 U n ( t ) 0 ∞ 在区间 [ 0, h ] 上一致收敛。这等价于证明下列无穷级数一致收敛： U 0 ( t ) + ∑ k = 1 ∞ [ U k ( t ) − U k − 1 ( t ) ] ,0 ≤ t ≤ h (9) 由于 U 1 ( t ) 是由 U 0 ( t ) 定义的，故而存在 N > 0 ，使得 ‖ U 1 ( t ) − U 0 ( t ) ‖ ≤ N 。 ‖ U 2 ( t ) − U 1 ( t ) ‖ ≤ M ∫ 0 t ‖ U 1 ( s ) − U 0 ( s ) ‖ d s + τ R L ‖ U 1 ( t ) − U 0 ( t ) ‖ ≤ ( M t + τ R L ) N ≤ ( M + R L ) τ N . 假设当 n = k 时 ‖ U k ( t ) − U k − 1 ( t ) ‖ ≤ ( ( M + L R ) τ ) k − 1 N . (10) 现在证明当 n = k + 1 时仍然成立。此时 ‖ U k + 1 ( t ) − U k ( t ) ‖ ≤ M ∫ 0 t ‖ U k ( s ) − U k − 1 ( s ) ‖ d s + τ R L ‖ U k ( t ) − U k − 1 ( t ) ‖ ≤ ( ( M + L R ) τ ) k N . 则由数学归纳法在 0 ≤ t ≤ h 上，对任意正整数n都有 ‖ U n ( t ) − U n − 1 ( t ) ‖ ≤ ( ( M + L R ) τ ) n − 1 N . (11) 由Weierstrass判别法，当 ( M + L R ) τ < 1 时， U k ( t ) 一致收敛。 从而存在 U ( k ) 使： l i m k → ∞ U k ( t ) = U ( t ) ,   0 ≤ t ≤ h . (12) 而由 U k ( t ) 在 [ 0, h ] 上一致收敛于 U ( t ) 以及 ∂ k / ∂ s 的连续性，对(6)两边取极限 l i m n → ∞ U n ( t ) = l i m n → ∞ { ∫ 0 t     ∂ s K ⋅ U n − 1 ( s ) d s + ∫ t − τ 0     ∂ s K ⋅ U * ( s ) d s + τ R ⋅ F ( t , U n − 1 ( t ) ) } . 在一致收敛的条件下，极限运算可以和积分运算交换： l i m n → ∞ U n ( t ) = ∫ 0 t     ∂ s K ⋅ l i m n → ∞ U n − 1 ( s ) d s + ∫ t − τ 0     ∂ s K ⋅ U * ( s ) d s + τ R ⋅ F ( t , l i m n → ∞ U n − 1 ( t ) ) . 即 U ( t ) = ∫ 0 t     ∂ s K ⋅ U ( s ) d s + ∫ t − τ 0     ∂ s K ⋅ U * ( s ) d s + τ R ⋅ F ( t , U ( t ) ) , 故而 U ( t ) 是积分方程(6)定义在区间 [ 0, h ] 上的连续解。 接下来讨论解的唯一性。 假设 U ( t ) ， W ( t ) 是积分方程(6)的两个解 ‖ W ( t ) − U ( t ) ‖ = ∫ 0 t     ∂ s K ⋅ ‖ W ( s ) − U ( s ) ‖ d s + τ R ⋅ ‖ F ( t , W ( t ) ) − F ( t , U ( t ) ) ‖ . 由Lipschiz条件得： ‖ W ( t ) − U ( t ) ‖ ≤ ∫ 0 t | ∂ s K | ⋅ ‖ W ( s ) − U ( s ) ‖ d s + τ R L ‖ W ( t ) − U ( t ) ‖ . (13) 则有： ( 1 − τ R L ) ⋅ ‖ W ( t ) − U ( t ) ‖ ≤ 0 + ∫ 0 t | ∂ s K | ⋅ ‖ W ( s ) − U ( s ) ‖ d s . (14) 注意到 1 − τ R L > 0 ，根据Gronwall不等式可以得到 0 ≤ ‖ W ( t ) − U ( t ) ‖ ≤ 0 1 − τ R L ⋅ e x p { ∫ 0 t | ∂ s K | / ( 1 − τ R L ) d s } = 0. 从而解唯一，证毕。"
"前面论证了当时滞足够小时，一阶记忆依赖型微分方程的解存在且唯一，那现在考虑能否找到其准确解？拿最简单的线性记忆依赖方程组举例。考虑如下方程组： ( D τ U = A U + F ( t ) , 0 < t ≤ h , U ( t ) = U * ( t ) , − τ ≤ t ≤ 0 , (15) 其中 U = [ u v ] ， A = [ a b c d ] ， F ( t ) = [ f 1 ( t ) f 2 ( t ) ] 。 根据定义(1)通过分部积分变换得 D τ U = 1 τ ∫ t − τ t     K ( t − s ) ∂ U ∂ s d s = 1 τ U ( t ) − 1 τ ∫ t − τ t ∂ K ∂ s U ( s ) d s . 核函数是根据实际情况进行选择的，这里我们用 K ( t − s ) = [ ( s − t ) / τ + 1 ] n 举例，当 n = 1 时，上述等式就变成了 D τ U = 1 τ U ( t ) − 1 τ 2 ∫ t − τ t   U ( s ) d s , (16) 将其带入方程组中可以得到等式 U ( t ) = 1 τ ∫ t − τ t ( E − A τ ) − 1 U ( s ) d s + τ ( E − A τ ) − 1 F ( t ) , (17) 将(17)等式两边同时对t求导得到 U ′ ( t ) = 1 τ ( E − A τ ) − 1 U ( t ) − 1 τ ( E − A τ ) − 1 U * ( t − τ ) + τ ( E − A τ ) − 1 F ′ ( t ) . (18) 这里的 ( E − A τ ) − 1 = [ e f g h ] 则(18)变为 u ′ ( t ) = e τ u ( t ) + f τ v ( t ) − e τ u * ( t − τ ) − f τ v * ( t − τ ) + e τ f 1 ( t ) + f τ f 2 ( t ) , v ′ ( t ) = g τ u ( t ) + h τ v ( t ) − g τ u * ( t − τ ) − h τ v * ( t − τ ) + g τ f 1 ( t ) + h τ f 2 ( t ) . (19) 求解上述常微分方程组就可以得到该记忆依赖性微分方程组在区间 [ 0, h ] 上，当核函数 K ( t − s ) = [ ( s − t ) / τ + 1 ] 的解。 当核函数 K ( t − s ) = [ ( s − t ) / τ + 1 ] n ( n > 1 ) 时，(16)变成了： D τ U = 1 τ U ( t ) − n τ 2 ∫ t − τ t ( s − t τ + 1 ) n − 1 U ( s ) d s , 带入方程组(16)可以得到 U ( t ) = n τ ∫ t − τ t ( s − t τ + 1 ) n − 1 U ( s ) d s + τ F ( t ) . (20) 将上述等式两边同时对t求导得 U ′ ( t ) = − n ( n − 1 ) τ 2 ∫ t − τ t ( s − t τ + 1 ) n − 2 U ( s ) d s + n τ 2 U ( t ) − n τ 2 u * ( t − τ ) + τ F ′ ( t ) . (21) 若 U ( t ) n阶可导时，对上式进行 n − 1 次求导，可以得到关于 U ( t ) 的n阶微分方程，求解常微分方程组，即可得到(3)的解。"
"记忆依赖型导数是在Caputo型分数阶微分算子的基础上提出的，故而与普通的导数之间存在一定的差异，其数值解也会不同。下面将举例将两者数值解进行比较： ( D τ U = A U + F ( t ) , 0 < t ≤ h , U ( t ) = U * ( t ) , − τ ≤ t ≤ 0 , (22) U = [ u v ] , A = [ 1 / τ 2 / τ 2 / τ 1 / τ ] , F ( t ) = [ e 3 t / τ + e − t / τ e − t / τ − e 3 t / τ ] ( u * ( t ) = 3 τ ( 3 t + 3 τ ) / τ + τ e ( − t − τ ) / τ , − τ ≤ t ≤ 0 v * ( t ) = − 3 τ ( 3 t + 3 τ ) / τ − τ e ( − t − τ ) / τ . − τ ≤ t ≤ 0 通过上面的方法可以求得当核函数取线性函数时，初值问题(22)的解为 u = ( 3 τ e 3 − τ e − 1 + 10 − 4 ) e − t / τ − 10 − 4 ⋅ e t / τ . v = ( − 3 τ e 3 − τ e − 1 + 10 − 4 ) e − t / τ − 10 − 4 ⋅ e t / τ . 考虑如下常微分方程组： ( U ′ ( t ) = A U + F ( t ) , 0 < t ≤ h , U ( 0 ) = U * ( 0 ) . (23) 除了 ( u * ( 0 ) = 3 τ ( 3 t + 3 τ ) / τ + τ e ( − t − τ ) / τ . v * ( 0 ) = − 3 τ ( 3 t + 3 τ ) / τ − τ e ( − t − τ ) / τ . 其他初值条件与(22)的相同。求解上述常微分方程组有： u ( t ) = ( 3 τ e 3 − τ e − 1 + 10 − 4 ) e − t / τ − 10 − 4 ∗ e 3 ∗ t / τ , v ( t ) = ( − 3 τ e 3 − τ e − 1 + 10 − 4 ) e − t / τ − 10 − 4 ∗ e 3 ∗ t / τ 将其与记忆依赖型微分方程组的解相比较，见图1。 图1. (a) (b)分别为当 τ = 1 时，记忆依赖性导数微分方程与常微分方程u分量和v分量；(c) (d)分别为当 τ = 0.5 时，记忆依赖性导数微分方程与常微分方程u分量与v分量 由图1可见，在时间较小时，两者的数值解间差距很小，随着时间的增大差距开始变大，而且当时滞越大时两个初值问题解越接近。对于分量u记忆依赖导数的衰减速度比较缓慢，普通导数的衰减速度前期较快而后期变得缓慢。而对于分量v，前期两者都呈缓慢上升趋势，但后期普通导数出现了下降。"
"本文利用皮卡迭代，以及Gronwall不等式定理证明了当 ( M + R L ) τ < 1 时，一阶记忆依赖微分方程的解存在且唯一。除此之外，找到了当核函数 K ( t − s ) = [ ( s − t ) / τ + 1 ] n 时，一阶线性记忆依赖性微分方程的准确解，当核函数取其他形式时，该初值问题的准确解还有待探索，讨论了时滞对其解的影响，发现当时滞越大时两者的解越接近。"
