"针对欠定线性方程组稀疏非负解的求解问题，本文首先将原问题松弛为 l 0 正则优化模型。随之提出有效集方法识别严格L-稳定点邻域内的零分量，基于这种快速识别技术，设计了有效集Barzilar-Borwein算法求解 l 0 正则极小化模型。最后的数据实验证明该算法可以快速有效地求解欠定线性方程组的稀疏非负解。 关键词 :稀疏非负解， l 0 正则优化模型，严格L-稳定点，有效集Barzilar-Borwein算法 Copyright © 2020 by author(s) and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY 4.0). http://creativecommons.org/licenses/by/4.0/"
"基于欠定线性方程组 A x = b ，这里 b ∈ R m ， x ∈ R n ，A是 m × n ( m < n ) 的矩阵，b是已知的，x是未知的，本文只考虑非负解 x ≥ 0 的部分。寻找欠定线性方程组的稀疏非负解，就是求解如下的优化问题： min ‖ x ‖ 0 s .t .   A x = b , x ≥ 0. (1) 其中 ‖ x ‖ 0 指向量x中非零分量的个数。这类问题在信号处理，图像恢复和多光谱数据处理等领域引起了广泛的研究 [ 1 ] [ 2 ] [ 3 ]。 在现有的研究成果中，主要用贪婪法和松弛法来解决问题(1)。贪婪法主要包括正交匹配追踪算法 [ 4 ]，正则化正交匹配追踪算法 [ 5 ] 以及压缩采样匹配追踪 [ 6 ] 和子空间追踪 [ 7 ]。这种类型的算法由于其相对较快的计算速度，而在实践中得到了广泛的应用。然而，当信号不是很稀疏或观测噪声水平较高时，贪婪法的性能无法得到保证。 松弛法是通过用一定的非负连续函数代替 l 0 范数，将 l 0 极小化模型转化为更易于处理的模型。常用于逼近 l 0 极小化模型的是 l 1 极小化模型。 l 1 极小化是一个凸优化问题，在矩阵A满足适当的条件下， l 1 极小化可以精确地恢复稀疏信号。因此， l 1 极小化被认为是解决稀疏性问题的非常有用的工具并得到了广泛的运用。此外，一些非凸函数 l p ( 0 < p < 1 ) 范数被提出作为 l 0 范数的松弛。与 l 1 极小化方法相比，非凸松弛模型通常具有更好的稀疏性，但通常较难求解。 求解约束优化问题(1)主要有两种算法。第一种算法是迭代重加权算法，其中两个最重要的迭代重加权算法是重加权 l 1 极小化 [ 8 ] 和迭代重加权最小二乘算法 [ 9 ]。另一种方法通常称为正则化方法，它通过引入正则化参数将问题(1)转化为下面的优化问题： min ϕ ( x ) : = f ( x ) + μ ‖ x ‖ 0 s .t .   x ≥ 0. (2) 其中 f ( x ) = 1 2 ‖ A x − b ‖ 2 2 ，且 μ > 0 是给定的正则化参数。 本文的其他内容如下：首先给出一些符号定义和关于问题(2)的一阶优化条件。基于Cheng和Chen [ 10 ] 的研究，我们在加入非负约束 x ≥ 0 后，重新定义了四种关于问题(2)的稳定点：基本稳定点，强基本稳定点，L-稳定点，严格L-稳定点，并说明了它们之间的关系。随之提出了有效集方法求解问题(2)，这种方法能够精准地找出L-稳定点邻域内的值为零的分量。接着提出了有效集Barzilar-Borwein算法求解问题(2)。最后进行了数据实验，证明了该算法可以有效的求解欠定线性方程组的稀疏非负解。"
"在本节中，我们将定义一些符号说明。假设 x * 是问题(2)的最优解，我们定义有效集 γ ( x * ) 是 x * 中零分量的下标集合，无效集 τ ( x * ) 是 x * 中非零分量的下标集合： γ ( x * ) = { i : x i * = 0 } 和 τ ( x * ) = { i : x i * > 0 } . 定义2.1 [ 11 ] 令 ν ∈ R n ， α > 0 ，若向量值函数 h 0 ( ν , α ) 满足 h 0 ( ν , α ) i = { ν i , | ν i | > 2 α , 0 , | ν i | ≤ 2 α .     i = 1 , 2 , ⋯ , n . 则称 h 0 ( ν , α ) 为硬阈值算子。 注2.1 硬阈值算子是 l 0 极小化问题的最优解，即 h 0 ( ν , α ) = arg min u ∈ R n { ‖ u ‖ 1 : u = arg min x ∈ R n { α ‖ x ‖ 0 + 1 2 ‖ x − ν ‖ 2 } } . 在最近的研究中，Beck和Hallak [ 12 ] 提出了下面问题的一些基本定义 (3) 其中 μ > 0 ， B ⊆ R n 。 定义2.2 (基本稳定点)如果 B = R + n ，则有： g i ( x * ) = 0 , ∀ i ∈ τ ( x * ) . (4) 其中 g i ( x * ) 表示 f ( x * ) 在第i个分量的梯度。那我们称满足条件(4)的 x * 为问题(2)的基本稳定点。 定义2.3 (L-稳定点)向量 x * 称作问题(3)的L-稳定点需满足： x * ∈ p r o x μ L g B ( x * − 1 L g ( x * ) ) = arg min x ∈ B { μ L ‖ x ‖ 0 + 1 2 ‖ x − ( x * − 1 L g ( x * ) ) ‖ 2 } . 其中 L > 0 ， g B ( x ) = δ B ( x ) + ‖ x ‖ 0 且 δ B ( x ) 是集合B的指标函数，而指标函数也就是 δ B ( x ) = { 0 , x ∈ B ; 1 , x ∉ B . 当 B = R + n 时，问题 等价于问题 ，则上述条件等价于下面的条件： { 0 ≤ g i ( x * ) ≤ 2 μ L , i ∈ γ ( x * ) ; x i * ≥ 2 μ L 且 g i ( x * ) = 0 , i ∈ τ ( x * ) . 向量 x * 满足如下条件就称为问题(2)的严格L-稳定点： { 0 ≤ g i ( x * ) ≤ 2 μ L , i ∈ γ ( x * ) ; x i * > 2 μ L 且 g i ( x * ) = 0 , i ∈ τ ( x * ) . (5) 向量 x * 满足如下条件就称为问题(2)的强基本稳定点： { 0 ≤ g i ( x * ) ≤ 2 μ L , i ∈ γ ( x * ) ; g i ( x * ) = 0 , i ∈ τ ( x * ) . 由上述条件不难得出由问题(2)的严格L-稳定点可以推出问题(2)的L-稳定点，强基本稳定点和基本稳定点。 对于函数 ϕ ( x ) ，称 d ∈ R n 是函数 ϕ ( x ) 在x处的下降方向，如果常数 δ > 0 ，使得 ϕ ( x + α d ) < ϕ ( x ) , ∀ α ∈ ( 0 , δ ) . 我们用 D ( x ) 表示函数 ϕ ( x ) 的所有下降方向的集合： D ( x ) = { d ∈ R n | ϕ ( x + α d ) < ϕ ( x ) , ∀ α ∈ ( 0 , δ ) } . 类似于文献 [ 10 ] 的定理2.1，下面的定理将给出集合 D ( x ) 更精确的表达形式，这将有利于我们设计线性搜索方法解决问题(2)。 定理2.1 假设 x > 0 ，由于 f ( x ) 是连续可微的，集合 D ( x ) 可表示为： D ( x ) = { d ∈ R n | g τ ( x ) T d τ ( x ) < 0 , d γ ( x ) = 0 } ."
"通常来说，有效集的效率很大程度上取决于如何找到最优点处的有效约束。接下来，将介绍有效集的估计并用它来逼近原问题的严格L-稳定点。我们用集合 A ( x ) 逼近 γ ( x * ) ，集合 F ( x ) 逼近 τ ( x * ) ： A ( x ) = { i : 0 ≤ x i ≤ 1 L g i ( x ) + 2 μ L } , 和 F ( x ) = { i : x i > 1 L g i ( x ) + 2 μ L } . 下面的定理表明，当点 x k 足够接近严格L-稳定点时，则上述有效集的逼近集合 A ( x k ) 是集合 γ ( x * ) 的子集。 定理3.1 假设 x * 是问题(2)的严格L-稳定点，序列 { x k } 收敛于 x * ，则对于足够大的k有： A ( x k ) ⊆ γ ( x * ) 且 τ ( x * ) ⊆ F ( x k ) . 证明：假设 x * 是问题(2)的严格L-稳定点，如果 τ ( x * ) = ∅ ，由于 A ( x k ) ∪ F ( x k ) = γ ( x * ) ∪ τ ( x * ) = { 1 , 2 , ⋯ , n } . 所以结论成立。假设 τ ( x * ) ≠ ∅ ，对于任意的 i ∈ τ ( x * ) ，由(5)可知： x i * − 1 L g i ( x * ) = x i * > 2 μ L . 因为 g ( x ) 是连续的，故有： x i k − 1 L g i ( x k ) > 2 μ L . 因此， i ∈ F ( x k ) 也就是 τ ( x * ) ⊆ F ( x k ) 。 另一方面，对于任意的 i ∈ A ( x k ) ，有 0 ≤ x i k ≤ 1 L g i ( x k ) + 2 μ L . 由于序列 { x k } 收敛于 x * ，可得： 0 ≤ x i * ≤ 1 L g i ( x * ) + 2 μ L . 对于足够大的k，可得 x i * = 0 。再由最优性条件，我们有 0 ≤ g i ( x * ) ≤ 2 μ L 。因此， i ∈ γ ( x * ) 也就是 A ( x k ) ⊆ γ ( x * ) ，证毕。 下面的定理表明，当 x k 是问题(2)的严格L-稳定点时，我们可以得到集合 A ( x k ) = γ ( x k ) 。 定理3.2 假设 是问题的严格L-稳定点，则有： A ( x k ) = γ ( x k ) , F ( x k ) = τ ( x k ) . 证明：假设 x k 是问题的严格L-稳定点，对于任意的 i ∈ γ ( x k ) ，由条件(5)可得 i ∈ A ( x k ) 。而对于任意的 i ∈ A ( x k ) ，我们有 x i k = 0 。但事实上，如果存在 x i k ≠ 0 ，由条件(5)可得 g i ( x k ) = 0 且有： x i k ≤ 2 μ L ⇒ x i k = 0. 由此可得 i ∈ γ ( x k ) ，故 A ( x k ) = γ ( x k ) 。同理可得 F ( x k ) = τ ( x k ) ，证毕。"
"在本节中，首先给出搜索方向的定义和一些相关性质，然后介绍一种有效集Barzilar-Borwein算法来求解问题(2)，并分析了该算法的全局收敛性。  令 x k ∈ Ω 是第k个迭代点，为了简化表述，令 A k = A ( x k ) , F k = { i ∈ F ( x k ) : x i > 0 } . 为了定义搜索方向，进一步将 A k 分成两个部分： A 1 k = { i ∈ A k : x i k g i ( x k ) ≥ 0 } , A 2 k = { i ∈ A k : x i k g i ( x k ) < 0 } . 搜索方向 d k = ( d A 1 k k , d A 2 k k , d F k k ) ，定义 d F k k 为： d i k = − λ k g i k , i ∈ F k . (6) 其中 0 < λ min ≤ λ k < λ max 是Barzilar-Borwein算法的步长，其精确的定义将在4.2节中给出。集合 A 1 k 表示零分量的下标集合，且包含满足条件(5)的变量的下标集合。集合 A 2 k 包含不满足条件(5)的变量的下标集合。因此，给出定义： d i k = − x i k , i ∈ A 1 k . (7) d i k = − g i k , i ∈ A 2 k . (8) 下面的定理表明 d k = 0 当且仅当 x k 是问题(2)的一个严格L-稳定点。 定理4.1 假设 d k 由上述定义式(6)~(8)所表示。 d k = 0 当且仅当 x k 是问题(2)的一个严格L-稳定点。 证明：令 d k = 0 ，由 A 2 k 的定义和搜索方向 d i k = − g i k = 0 ，可得 A 2 k = ∅ 。如果 i ∈ A i k ，由 A 1 k 的定义和 d i k = − x i k = 0 可得： x i k = 0 且 g i ( x k ) ≤ 2 μ L . 如果 i ∈ F k ，由 F k 的定义可知： x i k > 2 μ L 且 g i ( x k ) = 0. 反过来，假设 x k 是问题(2)的严格L-稳定点。如果 i ∈ A k ，我们称 x i k = 0 ， d i k = − x i k = 0 且 A 2 k = ∅ 。事实上，如果 x i k ≠ 0 ，由式(5)可得： g i ( x k ) = 0 且 x i k ≤ 2 μ L ⇒ x i k = 0. 这与假设条件矛盾。因此，对 ∀ i ∈ F k 有： g i ( x k ) = 0 且 d i k = 0. 证毕。 定理4.2 假设 x k → x * 且 d k → 0 ，其中 d k 由式(6)~(8)所表示，则 x * 是问题(2)的一个L-稳定点。 证明：对于 ∀ i ∈ A 1 k ，当 x k → x * 时，由于 d i k = − x i k → 0 ，可得 x i * = 0 。再由 A 1 k 的定义，我们可得： x i * = 0 且 g i ( x * ) ≤ 2 μ L , 对于 ∀ i ∈ A 2 k ，由 d i k = − g i k → 0 ，可得： g i ( x * ) = 0. 对于 ∀ i ∈ F k ，由于 g ( x ) 的连续性和 d k → 0 ，有 x i * ≥ 2 μ L 且 g i ( x * ) = 0. 证毕。 下面的定理表明，如果 x k 是问题(2)的强基本稳定点，由(6)~(8)定义的 d k 是f在 x k 处的下降方向。 定理4.3 假设 d k 由(6)~(8)式定义，可得 ( g k ) T d k ≤ 0. (9) 此外，等号成立当且仅当 x k 是问题(2)的强基本稳定点。 证明：由 A 1 k 的定义可知： g i k d i k = − g i k x i k ≤ 0 , ∀ i ∈ A i k . 再由 A 2 k 的定义可知： g i k d i k = − ( g i k ) 2 < 0. 对于任意的 i ∈ F k ，我们有： ( g i k ) T d i k ≤ − λ min ‖ ( g i k ) T ‖ 2 ≤ 0. 综上所述，我们可以得到 ( g k ) T d k ≤ 0 。 假设 x k 是问题(2)的强基本稳定点。对于任意的 i = 1 , 2 , ⋯ , n ，有 x i k g i ( x k ) = 0 。由此，对于任意的 i ∈ A 1 k ，有 d i k = − x i k ，则有 ( g k ) T d k = 0 。由 A 2 k 的定义可知 A 2 k = ∅ 。对于任意的 i ∈ F k ，我们有 g i k = 0 。相反地，假设不等式(9)的左边等于0，我们有： g i ( x k ) = 0 且 x i k > 2 μ L , ∀ i ∈ F k . 由 A 2 k 的定义可知 A 2 k = ∅ 。由 的定义可得： x i k = 0 , 0 ≤ g i k ≤ 2 μ L 或 0 < x i k ≤ 2 μ L , g i k = 0. 由此可知， x k 是问题 的强基本稳定点，证毕。  基于上述讨论和非单调线性搜索 [ 13 ]，类似于文献 [ 10 ]，我们提出了一种有效集Barzilar-Borwein算法来求解问题(2)。但不同于文献 [ 10 ] 的是我们在加入非负约束后，重新定义了有效集和有效集部分的搜索方向，产生了不同的迭代点，加快了算法的收敛速度。 算法4.1 (有效集Barzilar-Borwein算法，简记ABB算法) 步0 初始化 x 0 ∈ R + n ，取 η , δ ∈ ( 0 , 1 ) ， λ 0 = 1 且 λ max > λ min > 0 ，正整数M，取 k = 0 。 步1 进行收敛性检验，如果满足停止条件，则用近似解 x k 终止。 步2 计算 λ k : λ min ≤ λ k ≤ λ max 且 d k 由式(6)~(8)确定。 步3 如果 ，满足不等式 ϕ ( x k + α k d k ) ≤ ϕ ( x k ) − δ ( α k ‖ d k ‖ ) 2 . (10) 执行步5，否则执行步4。 步4 确定 α k : = max { η j , j = 0 , 1 , ⋯ } 满足不等式 f ( x k + α k d k ) ≤ max 0 ≤ j ≤ m ( k ) f ( x k − j ) − δ ( α k ‖ d k ‖ ) 2 . (11) 其中 m ( 0 ) = 0 ， 0 ≤ m ( k ) ≤ min [ m ( k − 1 ) + 1 , M ] ，执行步5。 步5 计算 x k + 1 : = x k + α k d k ，取 k : = k + 1 ，返回步1。 接下来，将给出 λ k 的显性形式，运用了Barzilar-Borwein (BB)算法 [ 14 ] 的基本思想。类似于Barzilar-Borwein步的思想，通过求解下面的优化问题： min λ ∈ R ‖ D ( λ ) s F k k − 1 − y F k k − 1 ‖ 2 . 其中 s F k k − 1 = x F k k − x F k k − 1 且 y F k k − 1 = g F k k − g F k k − 1 ，我们得到Barzilar-Borwein步长如下： λ B B k = ‖ s F k k − 1 ‖ 2 ( s F k k − 1 ) T y F k k − 1 . 为了控制 λ B B k 的大小值，我们用区间 [ λ min , λ max ] 来限制，其中 λ min < λ max 是给定的正常数。因此，我们设 λ k = max { λ min , min { λ max , λ B B k } } (12) 为了简单起见，我们将步长(12)代入式(6)，简化了算法4.1。  下面将分析算法4.1的全局收敛性。类似于文献 [ 13 ] 中的分析，可以得到了如下的引理。 引理4.1 假设序列 是由算法4.1产生。如果存在一个正整数 k 1 ，对于所有 k > k 1 ，满足线性搜索(11)，我们有： lim k → ∞ α k d k = 0. (13) 下面的定理和定理4.2表明序列 { x k } 的任意聚点都是问题(2)的L-稳定点和强基本稳定点。 定理4.4 假设序列 { x k } 是由算法4.1产生。如果对于所有的k都有 d k ≠ 0 ，则序列 { x k } 的任意聚点 x * 都是问题(2)的L-稳定点或强基本稳定点。 证明：假设对于所有的k都有 d k ≠ 0 ，且 x * 为序列 { x k } 的任意聚点。则存在一个无限指标集合K，满足 k ∈ K 使得： lim k → ∞ x k = x * . 考虑到不同集合 A 1 k , A 2 k , F k 的数量是有限的，对于任意的 k ∈ K ，我们考虑两种情况。情形(1)：如果存在一个无限指标集合 K 1 ⊆ K ，对于所有的 k ∈ K 1 ，线搜索(11)都满足。通过对不等式(10)求和，可得 则由定理4.2可知结论成立。情形(2)：如果存在一个正整数 k 1 ，对于所有的 k > k 1 ，线搜索(11)都满 足。如果序列 { α k } k ∈ K 有一个非零的极限值，我们由(13)式可知 lim k → ∞ d k = 0. 则由定理4.2可得知结论成立。否则，如果我们有 lim k → ∞ α k = 0 ，对于所有的 k ≥ 1 ，由线搜索(11)规则可得 f ( x k + α k η d k ) − f ( x k ) ≥ f ( x k + α k η d k ) − max 0 ≤ j ≤ m ( k ) f ( x k − j ) > − δ ( α k η ‖ d k ‖ ) 2 . (14) 另一方面，对于充分大的 k ∈ K ，由中值定理可得 f ( x k + α k η d k ) − f ( x k ) = α k η ( g ( x k + θ k α k η d k ) − g ( x k ) ) T d k + α k η g ( x k ) T d k . 其中 θ k ∈ ( 0 , 1 ) 。将上述等式带入(14)，可得 ( g ( x k + θ k α k η d k ) − g ( x k ) ) T d k + g ( x k ) T d k > − δ α k η ‖ d k ‖ 2 . 由于序列 是有界的，不失一般性地，存在 d * 使得 lim k → ∞ d k = d * ，结合引理4.1可知， lim k → ∞ α k = 0 。再由最后一个不等式取极限得 g ( x * ) T d * > 0 。由定理4.3得出矛盾，故结论成立，证毕。"
"下面将进行一些数值实验来验证算法4.1对于求解欠定线性方程组的稀疏非负解是有效的。所有的实验结果都是在联想笔记本电脑(2.50 GHz, 8.00 GB of RAM)上实现的，数学软件采用MATLAB R2016a。 基于文献 [ 15 ] 的实验证实了 l 0 优化问题可连续的有效性，我们将算法中嵌入连续化过程。具体方法就是在考虑求解问题(2)前，先求解如下一系列问题 x μ k * : = arg min x ∈ R + n { ϕ μ k ( x ) = f ( x ) + μ k ‖ x ‖ 0 } . 其中 μ 0 > μ 1 > ⋯ > μ N 且N是一个正整数。我们用问题的解 x μ k − 1 * 作为下一个问题的初始迭代点。取 μ 0 = 1 2 ‖ A T b ‖ ∞ 2 ， μ N = 10 − 15 μ 0 ，区间 [ μ N , μ 0 ] 经过取对数化处理后，再将其分成N个均匀分布的子区间。我们选择序列 { μ k } 作为子区间的端点，并对 μ k 做了一个处理，即令 μ k = max { μ k , 0.005 } 。算法中涉及的参数设计如下： λ 0 = 1 , M = 10 , λ min = 10 − 3 , λ max = 10 , δ = 10 − 2 , η = 0.5 。首先用标准高斯分布的独立样本填充 m × n 的度量矩阵A，并且对这些行进行正交化。而真实解 x * 是一个具有有效集 A * 的T-稀疏信号，观测向量b定义为： b = A x * + e 其中e是根据均值为零且方差为10 -2 的高斯分布绘制的。 在实验中，我们研究了参数N和L对算法的影响，设 n = 5 × 10 3 和 n = 10 4 ， m = r o u n d ( 0.2 ∗ n ) ，并考虑了稀疏度的范围： x * 的非零分量的数量T在1到60都是可行的。算法的初始点是零向量，当满足 ‖ g ( x k ) τ ( x k ) ‖ ∞ ≤ 10 − 5 或 ‖ g ( x k ) γ ( x k ) ‖ ∞ ≤ 0 .05 条件时，停止运算。下面将从平均迭代步数(Iter)、平均误差( ‖ x k − x * ‖ ∞ )和运算时间(Time)三个方面来对ABB算法的性能进行评估。 Table 1 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.86 4.14e−02 18.85 (15, 1:30) 31.62 4.47e−02 19.21 (20, 1:30) 35.55 4.60e−02 22.03 (10, 31:60) 30.47 5.56e−02 20.35 (15, 31:60) 35.53 5.62e−02 21.48 (20, 31:60) 39.55 5.49e−02 24.86 表1. n = 5 × 10 3 , L = 1 / 5 时ABB算法求解问题的计算结果 Table 2 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.15 4.14e−02 18.03 (15, 1:30) 31.04 4.47e−02 19.08 (20, 1:30) 35.22 4.60e−02 20.67 (10, 31:60) 30.50 5.56e−02 19.33 (15, 31:60) 35.80 5.62e−02 20.59 (20, 31:60) 39.53 5.49e−02 24.70 表2. n = 5 × 10 3 , L = 1 / 4 时ABB算法求解问题的计算结果 Table 3 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.85 4.14e−02 18.87 (15, 1:30) 31.89 4.47e−02 19.09 (20, 1:30) 35.63 4.60e−02 21.33 (10, 31:60) 32.47 5.56e−02 24.51 (15, 31:60) 35.90 5.62e−02 25.47 (20, 31:60) 39.90 5.49e−02 27.64 表3. n = 5 × 10 3 , L = 1 / 2 时ABB算法求解问题的计算结果 Table 4 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.96 4.14e−02 19.03 (15, 1:30) 31.85 4.47e−02 20.55 (20, 1:30) 35.52 4.60e−02 21.10 (10, 31:60) 34.17 5.56e−02 23.65 (15, 31:60) 36.10 5.62e−02 24.88 (20, 31:60) 39.73 5.49e−02 26.78 表4. n = 5 × 10 3 , L = 1 时ABB算法求解问题的计算结果 由上述表1~4可以看出，当问题的规模取 n = 5 × 10 3 时， T = 31 : 60 , N = 15 ，ABB算法产生了较大的平均误差。在 T = 1 : 30 , N = 10 时，ABB算法产生的平均误差较小。而L的取值变化对于ABB算法产生的平均误差影响很小。 对于上述表格中计算的数据，我们将绘图分析在 T = 1 : 30 时，L和N的取值变化对于ABB算法求解问题的平均迭代次数和运算时间产生的影响。 图1. 不同L水平下，N取值变化对平均迭代次数的影响 图2. 不同L水平下，N取值变化对运算时间的影响 图3. 不同N水平下，L取值变化对平均迭代次数的影响 图4. 不同N水平下，L取值变化对运算时间的影响 由图1和图2可以明显看出，当L的值一定时，随着N的取值变大，迭代步数和运算时间都会增加。同样的，由图3和图4可以明显看出，当N的取值一定时，可以看出 L = 1 / 4 时，平均迭代步数和运算时间都是最小的。由此可知，当 L = 1 / 4 , N = 10 时，可以得到最优的实验结果。 Table 5 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.86 4.77e−02 76.62 (15, 1:30) 30.62 4.70e−02 77.02 (20, 1:30) 34.55 4.60e−02 79.56 (10, 31:60) 28.47 5.53e−02 80.35 (15, 31:60) 33.53 5.72e−02 81.46 (20, 31:60) 39.27 5.48e−02 84.06 表5. n = 10 4 , L = 1 / 5 时ABB算法求解问题的计算结果 Table 6 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.41 4.77e−02 75.03 (15, 1:30) 30.59 4.70e−02 76.08 (20, 1:30) 34.62 4.60e−02 78.77 (10, 31:60) 27.70 5.53e−02 77.53 (15, 31:60) 32.03 5.72e−02 80.49 (20, 31:60) 39.23 5.48e−02 82.50 表6. n = 10 4 , L = 1 / 4 时ABB算法求解问题的计算结果 Table 7 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.84 4.77e−02 76.97 (15, 1:30) 30.90 4.70e−02 80.09 (20, 1:30) 34.69 4.60e−02 81.53 (10, 31:60) 30.27 5.53e−02 80.51 (15, 31:60) 33.80 5.72e−02 81.67 (20, 31:60) 40.30 5.48e−02 83.54 表7. n = 10 4 , L = 1 / 2 时ABB算法求解问题的计算结果 Table 8 (N, T) Iter ‖ x k − x * ‖ ∞ Time (sec.) (10, 1:30) 26.98 4.77e−02 77.03 (15, 1:30) 30.93 4.70e−02 79.55 (20, 1:30) 34.66 4.60e−02 81.10 (10, 31:60) 31.43 5.53e−02 80.65 (15, 31:60) 34.07 5.72e−02 82.68 (20, 31:60) 39.90 5.48e−02 83.78 表8. n = 10 4 , L = 1 时ABB算法求解问题的计算结果 由表5~8中的结果可知，当问题规模达到 n = 10 4 时，我们依旧可以得到相同的结论。当L的值一定时，随着N的取值变大，迭代步数和运算时间都会增加。当N的取值一定时，可以看出 L = 1 / 4 时，平均迭代步数和运算时间都是最小的。由此可知，当 L = 1 / 4 , N = 10 时，可以得到最优的实验结果。综上可知，ABB算法可以快速有效地求解欠定线性方程组的稀疏非负解。"
"本文主要讨论了求解欠定线性方程组的稀疏非负解问题。首先将线性约束条件惩罚到目标函数上，给出了 l 0 正则优化模型的严格L-稳定点定义。随之提出有效集方法识别严格L-稳定点邻域内的零分量，基于这种快速精准的识别技术，设计了有效集Barzilar-Borwein算法，并且证明了由该算法产生的序列的任意聚点都是强稳定点。最后进行了数据实验，证明了该算法可以快速有效地求解欠定线性方程组的稀疏非负解。"
