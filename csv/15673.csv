"本文针对利用普通拍照设备在自然环境下抓拍到的含QR码的非标准图像，首先对其进行灰度化处理，其次采用中值滤波、全局阈值二值化、图像矫正等方法与过程完成图像的预处理工作，得到了比较标准的QR码图像。在图像矫正中，采用了Sobel算子边缘提取、Hough变换、图像旋转、平面投影转换及双线性插值法等方法。最后对于矫正后的图像，经过确定寻像图形、确定版本和格式信息、恢复掩膜、恢复码字并纠错、数据码字译码等一系列的处理，对其实现QR码译码。 关键词 :中值滤波，全局阈值法，最大类间方差法，Sobel算子，Hough变换，双线性插值法"
"QR码是快速响应码Quick Response Code的简称，可见快速识别是它最显著的特点，同时还能全方位对它识别。这种矩阵式二维码是日本Denso公司为汽车制造业研制的，它不仅具有使用寿命长、印制和携带方便等优点，而且还具有一维条码及其他二维条码无法实现的信息密度大、防伪性好、能包含图片、指纹、签字、声音和汉字等多种数据及压缩处理中国汉字字符的特点[ 1 ] 。自产生以来，二维条码就受到各个领域的密切关注，目前二维码实际广泛使用主要在亚洲，且已广泛应用于很多领域 [ 2 ] - [ 4 ] 。比如用于身份证明、传媒行业、电子票务、物流行业、制造业等。 二维码的识读方式主要分为两类，一类是激光读取式，一类是图像读取式。激光读取式因为受限于条码的制式，其发展空间变得越来越小。图像读取式因其二维信号的获取优势和可脱离专用识读器的特点，具有很大的发展空间。目前主要采用以下算法对二维条码图像进行预处理：首先将灰度图像二值化，采用适当的边缘提取算子提取边缘，接着利用Hough变换或投影变换计算二维条码倾斜的角度，最后用双线性变换插值，防止失真 [ 5 ] 。使用通用设备采集的条码图像，很容易受到光照不均和采集装置位置导致的几何失真影响，这会给译码带来很大困难，使译码的准确率大大降低。因此，如何对图像进行正确的二值化和几何矫正已成为QR码图像处理要解决的核心问题。 本文主要研究二维条码中QR码图像的处理与矫正，不使用专用条码扫描识读器而是使用普通摄像设备在自然环境下抓拍含QR码的图像，然后对抓拍到的图像通过图像预处理分离出QR码并进行译码。"
"本文的应用背景为：从手机或电脑的摄像设备抓拍到的含有QR码图形的图片中识别QR码并提取出嵌入其中的信息。而使用手机或PC摄像头拍摄到的图像往往存在散焦模糊、阴影、反光、图形旋转及几何失真等缺点，若不降低或消除这些干扰，我们的译码结果将存在很大的误差，或者译码失败，因此图像预处理是QR码识别的关键 [ 6 ] 。如图1所示为实际拍摄得到的图像，以后图像预处理过程均以此图为例。 具体说来，图像预处理的目的是：通过对拍摄到的图像进行一系列处理从中准确地找到QR码图形，并通过图像矫正将其还原为标准的QR码图形。而译码则是对第一步得到QR符号进行解码，提取嵌在其中的信息。 图像预处理流程如图2所示。 图1. 实际拍摄的图像 图流程图  图像灰度化就是将彩色图像转化成灰度图像的过程。像素点是图片的基本单位，任何图片都由很多个像素点构成。每个像素点都有颜色，其颜色由该点的颜色值决定。我们知道，任何一种颜色都是由红R、绿G、蓝B三种基色混合而成，所以像素点的颜色值可用其三种基色分量表示为(R，G，B)，每一基色的分量值可为0~255之间的任意整数，所以彩色图像任一像素点颜色值的变化范围是1600多万(256*256*256)种。灰度图像是像素点颜色值的三个基色分量R、G、B相同的一种特殊的彩色图像，基色分量的值叫做灰度值，由此可见，灰度图像中的任一像素点颜色值的变化范围仅有256 (0~255)种。灰度图像在数字图像处理中的优势就在这里，因为它各像素点的颜色值范围较彩色图像极大地减少了，从而也极大地减少了图像处理过程中的计算量，缩短了处理时间。 图像灰度化方法很多，本课题采用加权平均值法。加权平均值法是根据各个基色的特性将三个基色分量以不同的权重进行平均，其计算各像素点灰度值的公式为： (1) 这样做的理由在于：三种基色中，人眼对绿色最敏感，其次是红色，对蓝色敏感度最低，因此当g > r > b时，所产生的灰度图像更符合人眼的视觉感受。通常r = 30%，g = 59%，b = 11%，图像的灰度最合理。在MATLAB中实现图像灰度化的源程序如下： QR_image_rgb=imread('haut_eng.png'); %读取一张彩色图像 QR_image_gray=rgb2gray(QR_image_rgb); %将读入的彩色图像灰度化 由于QR码图像是由黑白单元模块组成的，也就是说标准的QR码图像中各像素点仅含黑白两种亮度信息，不含色彩信息。故先对原彩色图像进行灰度化、再进行二值化是必要的，而且还能大大减少后续图像处理的计算量，提高运算效率。对例图灰度化的结果如图3所示。  采集到的QR码图像在拍摄过程中因受到干扰而含有一定的噪声，且该类噪声主要是因光学采集系 图3. 灰度化结果 统而产生的椒盐噪声，图像处理中常用均值滤波和中值滤波来减小或消除此类干扰。均值滤波虽能有效减少该类噪声干扰，但是它在减少噪声干扰的同时会钝化图像的边缘及尖锐的细节信息，并且所使用的模板尺寸越大，图像就越模糊，图像边缘及细节信息丢失也就越严重。与之相比，中值滤波的输出是由邻域像素点的中间值决定的，不仅能平滑图像和降噪，还可以比较好地保留边缘的锐度和图像的尖锐细节 [ 7 ] ，因此本文选择中值滤波。 中值滤波属于非线性处理技术，其基本原理是：首先以某个像素点为中心建立一个邻域，这个邻域又被叫做窗口，然后将窗口里包括的所有像素点的灰度值按大小顺序排列，并取中间位置上的值作为该中心像素点的新的灰度值，若有两个中间位置，则取这两个值的算术平均值。 由上可知，中值滤波的效果取决于两个要素，即窗口的大小和形状。由于QR码图像的单元模块均为正方形，因此领域形状采用正方形较好。窗口越大，平滑的效果越明显，但图像边缘信息的损失就会越大，且随着窗口尺寸的增加，比较的次数将增大，计算时间会变长。本文根据实验结果选择3 × 3的正方形窗口。中值滤波部分的源程序为： QR_image_filted=medfilt2(QR_image_gray); %默认采用3 × 3大小窗口 其中QR_image_gray是图像灰度化的返回值。例图中值滤波后的图像如图4所示。  上面已经说到，灰度图像中任一像素点的灰度值可以是0~255之间的任意整数，即有256个值可取，图像二值化就是将具有多灰度值的灰度图像转化为只有0或255两种灰度值的图像，即像素点颜色非黑即白的图像，也叫二值图像：当灰度值为0时像素点为白点，为255时像素点为黑点。其基本处理思路是:首先选择一灰度阈值T，然后按下式重新计算图像各像素点的灰度值： (2) 其中，x为各像素点的原始灰度值，f(x)为新灰度值。 二值化的意义在于标准QR码图像是由黑白单元模块组成的。二值图像在Matlab中是以矩阵形式存储的，矩阵的元素(i, j)就表示图像的第i行、第j列像素点的灰度值，且矩阵元素只有0和1两个值：0表示二值图像中对应像素点的灰度值为0，1表示对应像素点的灰度值为255。 计算阈值的方法很多，但总体上可以分为两类：全局阈值法和局部阈值法 [ 2 ] 。全局阈值法是将图像 图4. 中值滤波结果 中所有像素点看做一个整体，先按照某一特定的规则对这个整体进行统计，然后再对统计结果进行相应的计算处理而得到阈值T。最大类间方差法就是一种全局阈值法，其算法思路是：用阈值将像素点按灰度值大小分为两类，使得这两类的方差的加权和最小的阈值才是最恰当的阈值，某一类的加权系数就是该类像素点占总像素点的比例 [ 8 ] 。二值化部分的源程序如下： threshold=graythresh(QR_image_filted); %用最大类间方差法求全局阈值 QR_image_bw=im2bw(QR_image_filted, threshold); %用上面的全局阈值二值化 实验结果表明，即使是受到污损的QR码图像，采用最大类间方差法求阈值也可以得到效果很好的二值图像。本文例图二值化结果如图5所示。  2.4.1. 图像旋转 [ 9 ] 如果图像仅方向上发生偏转，几何形状未变，那么可以直接通过图像的旋转来进行校正。旋转通常是以图象中心为圆心旋转，如图6所示，在XOY坐标平面内，A点坐标为(x, y)，线段的长度为r，且与x轴的夹角为 。现将线段以O点为中心顺时针旋转 角至位置， 坐标为 。 旋转前： (3) 旋转 角度后： (4) 这样，我们就可以根据旋转前图像各像素点的坐标计算出旋转后图像中对应像素点的坐标，同时由旋转前图像的像素点的灰度值可以得出旋转后的图像各像素点的灰度值。但是，从上面的旋转公式(4)可以看出，转换过程存在浮点运算，计算出来的旋转后的图像的点坐标可能不是整数，为保证图像旋转后的各点灰度值的准确度，必须对旋转后的图像各点进行插值运算，本文采用双线性插值法。 双线性插值(又叫一阶插值)的输出灰度值是在它输入图像对应像素点的2 × 2邻域内所有点的灰度值的平均值，能克服灰度不连续的缺点，相比零阶插值效果更好，在效果和运算时间上均能很好地满足识别要求。其数学模型如图7所示，OABC为XOY平面内的一个边长为W的正方形，四顶点坐标如图所 图5. 图像二值化结果 图6. 图像旋转示意图 图7. 双线性插值的数学模型 示，表示XOY平面上任一点的灰度值，且已知在正方形OABC四顶点上的值。现采用双线性插值法求正方形OABC内任一点的灰度值，其步骤如下： 1) 对顶点 、 进行差值得： (5) 2) 对顶点 、 进行差值得： (6) 3) 做平行于Y轴方向的插值得： (7) 把(5)式和(6)式代入(7)式得： (8) 本部分源程序为： A=imrotate(image,-α,’bilinear’); %图像image采用双线性插值法逆时针旋转α角。  事实上，由于摄像头与QR码图像所在平面不平行或QR图像本身的不平整，造成拍摄到的QR码图像大多是畸变的四边形，即发生了几何失真，如图1所示。几何失真的存在不可避免地给QR码的识别及译码带来了困难，因此必须矫正。矫正思路是：以畸变的QR码图像的4个顶点为控制点进行平面投影转换，将畸变的四边形区域通过一定的映射关系转换到正方形的QR码区域中。 1) 获得控制点 考虑到QR码自身的特点，可先利用Sobel算子对几何失真的图像进行边缘检测，然后对检测出的点进行Hough变换找到4条边界直线，再由4条边界直线的交点来求得4个顶点。边缘检测的目的是减少Hough变换的计算量。其中Sobel算子是一阶导数的边缘检测算子，在算法实现过程中，通过3 × 3模板作为核与图像中的每个像素点做卷积和运算，然后选取合适的阈值以提取边缘。 2) 平面投影转换 [ 10 ] 如图8所示，A, B, C, D为四个控制点，坐标分别为 , , , . , , , 分别为A, B, C, D的投影点，坐标分别为 , , , 。 正方形区域的边长W取畸变四边形边长的平均值，则转换后4个顶点的坐标分别为 , , , 。 平面投影转换公式 [ 11 ] 如下式(9)、(10)， 为待解的8个参数，将转换前后4组对应坐标点代入两式后即可解得参数值。 图8. 平面投影转换映射示意图 (9) (10) 整理后可得： (11) (12) 把 , , , 四点坐标带入(11)、(12)式，并写成矩阵形式得： (13) 解得： (14) 将解得的8个参数代入(9)、(10)式中，即可建立投影后正方形图像内任一点 与投影前畸变四边形中的点(x, y)的对应关系。 由于存在浮点运算，正方形图像中的点通过上面的变换可能会对应到畸变四边形内的非整数点，在此仍然采用双线性插值法对这些点进行灰度插值运算，以获得这些点的准确灰度值。本文例图经图像矫正后的结果如图9所示。"
"QR码译码的流程图如图10。  寻像图形包括3个位置检测模块，它们分别位于QR码符号的左上角、左下角、右上角(如图11所示)，位置检测模块最显著的特征是，深色:浅色:深色:浅色:深色 = 1:1:3:1:1。 1) 根据位置探测图形1:1:3:1:1的结构逐行扫描QR码，找到所有经过位置检测图形3*3深色模块的行，并记下该行与位置探测图形边界相遇的第一点A和最后一点B (如图12)。 图9. 图像矫正结果 图10. QR码译码流程图 图11. QR码符号结构图 图12. 位置探测图形扫描线 2) 按照步骤1)逐列扫描QR码符号，找到所有经过位置探测图形3*3深色模块的列，并记下这些列与位置探测图形的外边缘相遇的第一点C和最后一点D (如图12)。 3) 确定探测图形中心。将所有在同一行上的A、B两点连接，并将所有线段的中点连成直线1，对得到的所有C、D点按照与A、B点同样的规则即可得到直线2，那么直线1和2的交点就可当做这个位置探测模块的中心点 [ 12 ] 。 4) 其他两个位置探测模块的中心点也是按照1)至3)中的步骤确定的。 寻找寻像图形的程序流程图如图13所示。 根据3个位置探测图形中心的坐标，判断QR码图像的方向是否正确，若不正确，计算出旋转角度并通过图像旋转矫正。  版本信息的获得具体可参照国标GB/T 18284-2000 《第11章QR码的参考译码算法》中的有关算法。版本信息的最高位单元模块编号为17，最低位单元模块编号为0，如图14所示。 提取QR码图像中的版本信息后，我们就需要通过建立网罗全图的采样网格来获得整个QR码图像的单元模块阵列。有了单元模块阵列我们就可以很容易地按照QR码的译码规则完成后序的译码。具体可参照国标GB/T 18284-2000《第11章-QR码的参考译码算法》中的有关建立采样网格的算法，此处不再赘述。建立采样网格之后，读取网格交点处的灰度值，建立整个QR码符号的位图。 从位图中读取与左上角位置探测图形相邻的15位格式信息(如图15所示)，并与二进制位流10101 00000 10010进行异或运算，然后对其纠错。若检测出的错误个数大于纠错容量，则按照译码左上角格式信息的方法译码左下角格式信息。由格式信息就可得到纠错等级指示符和掩模图形参考。 其中，关于纠错容量：QR码采用纠错算法生成一系列纠错码字，添加在数据码字序列后，使得符号可以在遇到损坏时不致丢失数据。纠错共有4个纠错等级，对应四种纠错容量，如表1所示。  根据掩膜图形参考及相应的掩膜图形生成条件产生掩模图形，然后将QR码图像编码区的模块阵列依次放在掩模图形的对应位置上进行异或处理。 掩模图形是与QR码符号单元模块大小和数量都相同的矩阵，在掩膜图形中所有行号和列号满足某种判断条件的模块为深色，不满足的为浅色，判断条件由相应的掩膜图形参考决定。掩膜图形参考有8种(如表2所示)，每个版本都相应地存在8种掩膜图形。 判断条件中，i代表行号，j代表列号，二者都从0开始，且i从上到下递增，j从左到右递增。 图13. 寻找位置检测图形程序流程图 图14. 版本信息 图15. 格式信息位置 Table 1 纠错等级 L M Q H 恢复的容量% (近似值) 7 15 25 30 表1. 纠错等级 Table 2 掩膜图形参考 条件 000 (i+j)mod 2=0 001 i mod 2=0 010 jmod3=0 011 (i+j)mod3=0 100 ((idiv2)+(jdiv3))mod2=0 101 (i,j)mod2+(i,j)mod3=0 110 ((i,j)mod2+(i,j)mod3)mod2=0 111 ((i,j)mod3+(i,j)mod2)mod2=0 表2. 掩膜图形参考及其对应的掩模图形判断条件  译码是编码的逆过程，将去掩膜后的QR码图像编码区(版本和格式信息除外)的信息根据编码过程所采用的数据分块规则，按块读取码字，其顺序依次应为：数据码字块1、数据码字块2、……、数据码字块n，纠错码字块1、纠错码字块2、……、纠错码字块n。 在最大纠正范围内用纠错码字块I (I = 1~n)，检查与其对应的数据码字块i中是否有错，若有错则给予纠正。  将上节经纠错译码程序检查过的数据码字块1到数据码字块n合并为一个二进制位流，并从最高位开始根据模式指示符将位流分成多个部分，每一部分为一个模式段。然后按照QR码国标规定的每一模式的解码标准，对每一部分进行解码即可得到嵌入QR码图像中的原始信息 [ 13 ] ，具体译码流程如图16所示。 数字模式译码：将输入的数据每三位分为一组，将每组数据转换为10位二进制数。如果所输入的数据的位数不是3的整数倍，所余的1位或2位数字应分别转换为4位或7位二进制数。将二进制数据连接起来并在前面加上模式指示符和字符计数指示符。 同时有关字母数字模式译码、8位字符模式译码、中国汉字模式译码以及数字模式译码的具体内容及过程由于篇幅过多，可参看QRCode_编码及解码标准，在此不一一赘述。"
"本文在图像预处理算法中，针对采集到的含QR码图像出现的噪声、光照不均匀、失真等情况，分别采用中值滤波、全局性阈值二值化、图像矫正等方法加以改善处理，其中在图像二值化的过程中，对灰度阈值T进行取值时，采用了全局阈值法中的最大类间方差法，实验结果表明，即使是受到污损的QR 图16. 数据码字译码流程图 码图像，采用最大类间方差法求阈值T得到了效果很好的二值图像。在图像矫正中，采用了Sobel算子边缘提取、Hough变换、图像旋转、平面投影转换及双线性插值法等方法，最终得到了比较标准的QR码图像。在QR码解码上，则是按照QR码的国家译码标准进行的，并依照RS纠错理论对QR码进行纠错。"
