"本文提出了一种离散多目标果蝇优化算法，求解以最大完工时间和机床空闲时间最小化为目标的无等待流水线调度问题。与传统的果蝇算法不同，首先，该算法采用基于工序的编码方式，其次，利用GLOVE发生器进行初始化，提高初始解的分散度；最后，利用简单但有效的插入方法在邻域内进化精细搜索，增强算法的全局开发能力。仿真试验表明了所提果蝇算法的有效性和高效性。 关键词 :果蝇优化算法，无等待流水线调度问题，多目标"
"多目标优化问题是需要同时处理多个相互冲突和相互影响的目标，一个子目标的改善有可能会引起另一个或者另几个子目标的性能降低，需要在他们中间进行协调处理。起初，多目标优化问题往往通过加权等方式转化为单目标问题，但此方法效率较低且对权值和次序较为敏感。因此，后来发展了基于Pareto最优解集(Pareto-optimal set)或非支配解集(Nondominated Set)的群体智能算法解决多目标问题。文 [ 1 ] 根据无等待多目标优化问题和粒子群算法的特征，采用近似Pareto前端的分布熵及其变化来估计种群进化状态，并依据这些进化过程反馈信息设计具有动态平衡开发能力的进化策略。文 [ 2 ] 为了解决无等待柔性车间调度的多目标优化问题，结合灰色失联分析和熵理论，提出灰互信息适应度分配策略，以评价Pareto解的优劣。 果蝇优化算法(Fruit Fly Optimization Algorithm, FOA)是由台湾博士潘文超于2011年提出的一类全局进化优化算法。该算法源于对果蝇觅食行为的模拟，已在自动化仓库拣选作业调度问题 [ 3 ] ，边坡稳定预测问题 [ 4 ] ，船舶操纵响应模型的辨识问题 [ 5 ] 等方面得到成功的应用。进化算法通过在代与代之间维持由潜在解组成的种群来实现全局搜索，这种从种群到种群的方法对于搜索多目标优化问题的pareto最优集是很有用的 [ 6 ] 。"
"无等待流水线调度问题要求加工的任务从开始到结束必须连续进行，即同一工件的两个相邻工序之间没有间隔。此类调度广泛存在于食品加工、炼钢、制药等生产领域。该问题可以描述为：有 个工件 在 台机床 上加工 ，工件 在 台机床上的加工操 作为。同时需要满足如下条件：所有工件启动和运输时间包含在工件的加工时间内，均可在零时刻进行加工，每个工件在各机床上的加工顺序相同。为了满足无等待的条件，推迟工件在第一台机床上的加工 时间，使得工件在每台机床上的完成时间必须等于其在下一台机床上的开始加工时间，即 的完成时间必须等于 的开始时间。目的是得到一个可行调度 ，求其Pareto最优解集。该问题的模型如图1所示。 图1. 无等待流水线调度问题  提出以最大完工时间 、机床最大空闲时间 为指标对无等待调度问题进行研究。其中最大完工时间是从第一个工件开始加工计时到最后一个工件完成时间，机床空闲时间为各工件加工的空隙时间和。优化最大完工时间有利于提高生产率，降低工件的生产周期，优化机床空闲时间可以提高机床的利用率。 假设工序 按机床1到 的顺序进行加工，其中 为工件 在机床 上的加工时间， 代表工件 和 在第一台机床上的开始时间差。各工序的加工时间已知，工件 在机床 上的完成时间 的计算公式为： (1) (2) 其中 的计算公式如下： (3) 那么工序的最小化最大完成时间计算公式如下： (4) 最小化最大机器空闲时间的计算公式如下： (5) 两个目标值算法的时间复杂度分别为是O(n)，O(mn)。为了降低算法复杂度，提前定义变量 代表第一个工件与第 个工件在第一台机床的开工时间差 (6) 为工件 在第一台机床到第 台机床上的加工时间和 (7) (8) (9) 通过公式(8)，(9)所示算法的时间复杂度降低为O(1)，O(n)。  不同于单目标优化问题需要求得一个最优解，而多目标问题的优化就是寻找Pareto最优解集。在有限集合 上，给出两个目标的调度优化问题， ，若 ，假定 支配 ，则 ， 。在 中如果有一个没有被任何其他解所支配，则称它为Pareto最优解或非支配解。所有非支配解或Pareto最优解的集合成为Pareto最优解集。"
"果蝇优化算法的基本原理是初始化种群的中心位置，利用敏锐的嗅觉进行搜索，即根据中心位置随机产生多个邻域解。计算各可行解的味道浓度，即评价值，然后利用视觉从中选择较好的解，更新替换中心位置，然后进行迭代寻优，以更好的进靠近食物源。FOA在整个迭代寻优过程中，在连续空间中产生新个体的方法不适合解决MNFSP。故运用FOA算法的主体流程，对其优化过程进行离散化是算法成功应用于MNFSP的关键。基于以上分析，提出了离散果蝇算法(Discrete Fruit Fly Optimization Algorithm DFOA)。  种群中每个果蝇个体对应问题中的一个解，即工件的完整加工序列 ，如 为4个工件的调度实例解。 果蝇初始个体产生采用GLOVE [ 7 ] 发生器产生一组分布均匀的工件排列。对于一个给定排序 ，GLOVE发生器可得到n/2个分散均匀的排列。随机变化给定排列，即可得到足够多的初始果蝇个体，即可构成一个分散性较好的初始种群。  影响FOA算法性能的核心是如何生成嗅觉阶段的邻域个体 [ 8 ] 。一般全局Pareto最优解集中在局部Pareto最优解附近；因此利用Pareto最优解集中的解产生新解的质量较高。 对于MNFSP来讲，插入操作是最有效的邻域解生成方法 [ 8 ] 。因为子代可以很好的继承父代个体的优良基因，可以充分利用非支配解信息优势，引导算法向Pareto最优前沿进化。嗅觉阶段在Pareto最优解集中随机选取一个果蝇个体，对其执行插入邻域操作步骤如下： 步骤1：当前个体记为 ，通过对 进行三次插入操作得到调度 。 步骤2：从 中随机选取一个工件 得到调度 用公式(8)(9)分别计算 和 。 将工件 插入到所有可能的位置 ， 得到调度 ，如图2所示。 指标计算公式如下： (10) 图2. 插入邻域完工时间和空闲时间快速计算方法 (11) 步骤3： 代表临时非支配解集，保存插入过程中得到的非支配解。 步骤4：若 中有解没有被AS中的解支配，则更新AS。 步骤5：若 中有解支配 ，则替换之；若互不支配，则随机选择一个替换 。 确定新解是否为非支配解，若为非支配解，则更新AS，同时选择较好的解替换当前解。"
"基于上述设计，DFOA算法的流程步骤如下所示： 步骤1：设置参数，初始化种群。 步骤2：评价果蝇个体，并判断是否为非支配解，更新AS。 步骤3：在AS中随机选择一个非支配解，利用算法的嗅觉和视觉部分产生新的个体，并更新AS。 步骤4：判断终止条件是否满足，是则转到步骤5，否则转到步骤3。 步骤5：算法终止。"
"将本文所提算法DFOA与文献 [ 9 ] ESFLA进行比较，通过不同规模的解决6个标准问题进行有效性验证。几种算法都在处理器为Intel(R)Core i3 2.13 GHZ、内存为2G的PC机上，采用C++编码进行测试。对于每个算例，两种算法分别独立运行20次， 为第 个算法得到的非支配解集，从中选出非支配解集作为参考非支配解集 。算法最大运行时间为 微秒。采用两个性能指标来评价算法所得到的非支配解集：距Pareto边界的平均距离 、非支配解的比率 。  对文献 [ 9 ] 提出的ESFLA算法进行修改，按文中规定的参数进行设置，并将其应用于求解基于最大 Table 1 算例 DFOA ESFLA 名称 n × m AVG MIN MAX AVG MIN MAX Car01 11 × 5 0.15 0.00 2.94 1.51 2.24 5.14 Car07 7 × 7 0.04 0.03 0.79 0.05 0.00 1.03 Hel1 100 × 10 0.10 0.00 1.96 0.79 0.66 2.07 Hel2 20 × 10 0.07 0.00 1.47 0.99 0.49 3.14 Rec35 50 × 10 0.02 0.00 0.43 0.35 0.17 3.42 Rec37 75 × 20 0.04 0.00 0.72 0.12 0.03 2.35 Mean 0.07 0.01 1.39 0.64 0.60 2.86 表1. DFOA、ESFLA算法的 比较 Table 2 算例 DFOA ESFLA 名称 n × m AVG MIN MAX AVG MIN MAX Car01 11 × 5 0.99 0.97 1.00 0.68 0.56 0.94 Car07 7 × 7 0.96 0.92 1.00 0.89 0.68 1.00 Hel1 100 × 10 0.85 0.59 0.98 0.78 0.32 0.89 Hel2 20 × 10 0.78 0.51 1.00 0.66 0.54 0.78 Rec35 50 × 10 0.71 0.19 0.92 0.65 0.40 0.82 Rec37 75 × 20 0.79 0.13 0.98 0.78 0.31 0.89 Mean 0.85 0.58 0.97 0.76 0.52 0.87 表2. DFOA和ESFLA 算法的 比较 完工时间和最大机床空闲时间的多目标无等待流水线调度问题。两种算法采用相同的终止条件。AVG、MIN和MAX分别代表20次仿真实验目标值的平均值、最小值和最大值。结果如表1，表2所示。 由于真正的非支配解很难搜索到，有必要对所得解集计算 ，距离越近，得到的解质量就越高。由表1可知，DFOA算法的平均 ，最小 ，以及最大 的值分别是0.07，0.01，1.39，均小于ESFLA算法的0.64，0.60，2.86。因此，相对于平均距离而言，DFOA算法性能优于ESFLA。 算法DFOA优于ESFLA的另一个方面表现在非支配解的比率上。由表2可以看出，DFOA算法中平均有85%没有被 中的其他解所支配，而ESFLA算法中只有76%。"
"综上所述，DFOA算法之所以优于ESFLA，因为DFOA算法在算法中执行过程中保留了所以的非支配解，并充分利用了非支配解的优势，在其基础上用插入方法产生邻域解，更好的指导了算法的进化方向，增强算法全局搜索的能力。"
