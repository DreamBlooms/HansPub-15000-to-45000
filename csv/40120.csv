"乘法器的等价性验证目前仍是大规模算术集成电路设计领域内的一大难题。本文利用逻辑门与多项式之间的对应关系，构建了乘法器的代数模型，将乘法器等价性验证问题转化成理想成员判定问题，然后再用计算机代数系统中的Gröbner基方法进行求解。提出了一种对乘法器结构进行切片后再采用增量式验证的新方法。在Linux平台上的计算机代数系统Mathematica上所做的实验结果也表明了该方法的有效性。"
"随着科学技术的发展，集成电路的结构日益复杂，步入SoC时代，在门级抽象层次上已经达到数以百万和千万门系统的设计和验证 [ 1 ]。为了保证设计的错误能及时发现，杜绝因重新设计和流片浪费开发成本和设计周期，就需要对电路进行正确性的验证。传统的模拟验证因其不完备性，已经不能适用于现时的较高抽象层次上的集成电路的验证，为了避免“20世纪60年代的软件危机”和“著名的奔腾FDIV错误”此类情况发生，促使人们去研究更完善的验证方法 [ 2 ] [ 3 ] [ 4 ]。 等价性验证是目前在实际的芯片设计中应用最广泛的形式化验证技术，如Synopsys公司的Formality，Mentor Graphics公司的FormalProTM，Cadence公司的Affirma等，并且能处理较大规模的设计 [ 5 ]。等价性验证一般采用图表示法和代数表示方法 [ 6 ]。图表示法主要使用二叉判定图(BDD)，Brand利用BDD将电路建模为miter，计算所有可达状态这就是典型的基于有限状态机遍历算法 [ 7 ]。尽管最近十多年里，由于BDD方法的研究进展使得基于有限状态机遍历算法有了很大进步，但BDD需要大量储存和操作空间的问题仍无法避免，而且用布尔函数表示的状态集会成指数增长，存在状态空间爆炸问题。并且在抽象层较高的等价性验证中，受图形表示能力和图形构造上的制约，BDD无法胜任验证任务。相比而言，基于代数方法的等价性验证则更适合高层次验证。 代数学是数学的一个基本分支，它所处理和研究的数学对象是抽象的代数符号与概念，如整数、有理数、多项式、环、理想等 [ 8 ] [ 9 ]。其中多项式由于其描述电路时抽象建模能力强，表示具有规范性、无歧义性，使其成为理想的电路建模工具。Buchberger在1915年提出了多项式环上的Gröbner基，因其良序性方面的优势适用于计算机代数领域 [ 10 ] [ 11 ]。本文运用Gröbner基与乘法器电路结合的思想，在Galois域上采用迭代算法验证整数乘法器电路 [ 11 ] [ 12 ] [ 13 ] [ 14 ]。通过实验对比不同方法所需运行时间，易见各方法对乘法器等价性验证的效率影响。"
"对于环R中给定的理想I，其Gröbner基一般并不唯一。这些Gröbner基与项序的选择密切相关，下面给出相关定义 [ 8 ] [ 9 ] [ 10 ]。 定义2.1 设 为任意一个域，变量序列 x 1 , ⋯ , x n 记为X，将含有n个变量的多项式环记为 k [ X ] 或 k [ x 1 , ⋯ , x n ] 。 多项式环中最重要的结构为理想，理想为多项式环中的一种子集，其中的元素对加法和乘法封闭。 定义2.2 多项式集合I 是环 k [ X ] 的子集，如果满足 (1) 0 ∈ I ， (2) 如果 f , g ∈ I ，则 f + g ∈ I ， (3) 如果 f ∈ I , h ∈ K [ X ] ，则 h f ∈ I ， 上述条件，则称I为多项式理想。 对于Gröbner基来说，多项式环 k [ x 1 , ⋯ , x n ] 中单项式序的概念是一个基本概念，他可以定义出任意多项式的首项，从而保证多项式除法操作下余式唯一。 定义2.3 设 α = ( α 1 , ⋯ , α n ) , β = ( β 1 , ⋯ , β n ) ∈ Z ≥ 0 n ，集合Τ上的关系 ≺ 称为一个单项式序，如果 ≺ 满足下面条件： (1) ≺ 为Τ上的一个全序； (2) x α ≺ x β , x γ ∈ T ，那么， x α + γ ≺ x β + γ ； (3) ≺ 为Τ上的良序，即Τ上每一个非空子集有极小元。 其中 T = { X α = x 1 α 1 x 2 α 2 ⋯ x n α n | α = ( α 1 , α 2 , ⋯ , α n ) ∈ Z ≥ 0 n } 是所有单项的集合。 单项式序常见的有三种，字典序，分次字典序，分次逆字典序。 定义2.4 设 α = ( α 1 , ⋯ , α n ) , β = ( β 1 , ⋯ , β n ) ∈ Z ≥ 0 n ，如果 α − β ∈ Z n 的最左边非空元素为正数，则称单项式 x α ≺ l e x x β 为字典序排序。 定义2.5 非零多项式 f ∈ k [ x 1 , ⋯ , x n ] 在给定的单项式序下，可唯一表示为 f = c 1 x α 1 + ⋯ + c n x α n 则称 L C ( f ) = c 1 为多项式f的首项系数， M u l i d e g r e e ( f ) = α 1 为多项式f的次数， L M ( f ) = x α 1 为多项式f的首单项式， L t ( f ) = L C ( f ) L M ( f ) = c 1 x α 1 为多项式f的首项。 定义2.6 在多项式环 k [ x 1 , ⋯ , x n ] 上给定一个单项式序，非零理想I的有限子集 G = { g 1 , ⋯ , g t } ，如果满足 〈 L T ( g 1 ) , ⋯ , L T ( g t ) 〉 = 〈 L T ( I ) 〉 称G为理想I的Gröbner基。 结合多元多项式除法，Gröbner基理论为理想成员问题提供了一个判定过程：给定一个多项式 q ∈ k [ X ] 和理想 I = 〈 G 〉 = 〈 g 0 , ⋯ , g m 〉 ⊆ k [ X ] 。通过计算余数是否等于零，则可判定q是否为I中的元素。"
"Buchberger算法利用S-多项式去求多项式的Gröbner基，该算法的时间和空间复杂度是指数级的，在实际应用中是不可行的。因此本文直接将电路建模为Gröbner基多项式。 考虑一个具有l个布尔输入 a 0 , ⋯ , a l − 1 和m个输出 s 0 , ⋯ , s m − 1 的电路C。它的每个内部门由一个门变量 g 0 , ⋯ , g j 表示。接下来在相同的布尔输入 a 0 , ⋯ , a l − 1 下，设电路C'有m个不同的输出 s ′ 0 , ⋯ , s ′ m − 1 。与电路C中每个门(输出)类似，在电路C'中由门变量 g ′ 0 , ⋯ , g ′ k 表示。 门电路的逻辑门用多项式和信号作为布尔变量建模。其布尔变量之间的多项式关系是 u = ¬ v ⇔ − u + 1 − v = 0 u = v ∧ w ⇔ − u + v w = 0 u = v ∨ w ⇔ − u + v + w − v w = 0 u = v ⊕ w ⇔ − u + v + w − 2 v w = 0 (1) 每个逻辑门都是以门输入变量来描述门输出变量的方式来建模的。 每个多项式的一般形式是： p i = 首 项 ( x i ) + 尾 部 ( p i ) 其中首项 x i 是门的输出变量，尾部 p i 是由门的输入变量组成的术语。根据这个多项式形式，模型的所有首项都是相对素的。电路是在布尔值范围内操作，因此，对于变量u，可得到关系式 u ( u − 1 ) = 0 。满足等式左侧的多项式编码形式称为域多项式F。 定义3.1 设 G ∈ k [ X ] 是满足(1)的对应多项式的电路C每个门的集合，并且多项式 a i ( a i − 1 ) 和 b i ( b i − 1 ) 称为输入域多项式， 0 ≤ i < n 。则 G ∈ k [ X ] 中生成的理想用 J ( C ) 表示。 定义3.2设C是一个电路。一个多项式 p ∈ k [ X ] 被称为电路C的多项式电路约束(PCC)，如果把 ( a 0 , ⋯ , a n − 1 , b 0 , ⋯ , b n − 1 ) ∈ { 0 , 1 } 2 n 和结果值 g 0 , ⋯ , g k , s 0 , ⋯ , s 2 n − 1 带入多形式p得0。 定义3.3 电路C被称为乘法器，如果满足 ∑ i = 0 2 n − 1 2 i s i − ( ∑ i = 0 n − 1 2 i a i ) ( ∑ i = 0 n − 1 2 i b i ) 是PCC。 本文针对于简单部分积生成的乘法器，其中部分积是指由两个电路输入通过与门产生的输出。为了从Gröbner基中消除带有部分积的这些多项式，把定义3.3中乘法器的规范改为推论3.1中规定的规范。 推论3.1 电路C是乘法器，如果满足 ∑ i = 0 2 n − 1 2 i s i − ∑ i , j = 0 n − 1 p i , j ∈ J ( C ) ，其中 p i , j = a i b i 。 通过展开定义3.3中的和式，并在推论3.1中用 a i b i 替代 p i , j ，很容易地验证推论3.1的正确性。 乘法器的结构包括多个全加器及半加器，下面就以简单的全加器为例，给出理想成员问题判定过程： 例1：实现图1所示功能 s i + 2 c i = a i + b i + c i − 1 的全加器电路。 图1. 全加器电路 根据(1)，得图1的代数模型是 g 1 : = − c i − x 4 x 3 + x 4 x 3 ,   g 2 : = − s i − 2 x 1 c i − 1 + x 1 + c i − 1 g 3 : = − x 4 + x 2 c i − 1 ,     g 4 : = − x 3 + a i b i , g 5 : = − x 2 − a i b i + a i + b i ,     g 6 : = − x 1 − 2 a i b i + a i + b i 其中规范多项式为 p s p e c = − 2 c i − s i + c i − 1 + b i + a i ，将多项式变量按电路的逆拓扑顺序 a i ≺ b i ≺ c i − 1 ≺ x 1 ≺ x 2 ≺ x 3 ≺ x 4 ≺ s i ≺ c i 排序，在此序下，用规范多项式 p s p e c 归约代数模型 g i ： p s p e c → g 1 − s i + 2 x 4 x 3 − 2 x 4 − 2 x 3 + c i − 1 + b i + a i → g 2 2 x 4 x 3 − 2 x 4 − 2 x 3 + 2 x 1 c i − 1 − x 1 + b i + a i → g 3 2 x 3 x 2 c i − 1 − 2 x 3 − 2 x 2 c i − 1 + 2 x 1 c i − 1 − x 1 + b i + a i → g 4 2 x 2 c i − 1 b i a i − 2 x 2 c i − 1 + 2 x 1 c i − 1 − x 1 − 2 b i a i + b i + a i → g 5 2 x 1 c i − 1 − x 1 + 4 c i − 1 b i a i − 2 c i − 1 a i − 2 c i − 1 b i − 2 b i a i + b i + a i → g 6 0 通过计算得余数为0，因此提取的代数模型为Gröbner基。为了更好的加快验证效率，下节将介绍Gröbner基的约化。"
"通常情况，关于生成的Gröbner基归约规范，会导致中间约化结果中单项式的数量急剧增加，而影响验证效率 [ 9 ] [ 15 ]。因此我们利用加法器重写，以便更有效约化Gröbner基 [ 12 ]。 首先在乘法器的门级表示中识别全加器和半加法器，并将它们视为独立电路。然后应用变量消去，即用相应的加法器规范来代替全加器和半加法器内部门的所有多项式。这会使表示整个乘法器的Gröbner基更小、更紧凑，从而加快了归约过程。 定义4.1 一个电路C被称为全加器，如果满足 − 2 c − s + a + b + i 是PCC；相应地，一个电路 被称为半加器，如果满足 − 2 c − s + a + b 是PCC。其中 c , s 表示输出， a , b , i 表示输入。 例2 给出简单全加器电路 相应的规范多项式： H = { − c + g 1 + g 2 − g 1 g 2 , − s + g 0 + i − 2 g 0 i , − g 2 + a b , − g 1 + g 0 i , − g 0 + a + b − 2 a b } 那么H是 J ( A ) = 〈 H 〉 关于序 a < b < i < g 0 < g 1 < g 2 < s < c 的Gröbner基。 为了消除内部变量 g 0 , g 1 , g 2 ，直接将输出 s , c 表示为加法器输入 a , b , i 的多项式。下面就给出相关定义和定理，其中R表示环 k [ a , b , i , s , c , g 0 , g 1 , g 2 ] 和 R e l i m 表示环 k [ a , b , i , s , c ] [ 9 ]。 定义4.2 给定 J ⊂ R ，消去理想 J e l i m 是 R e l i m 的理想，定义 J e l i m = J ∩ R e l i m [ 9 ]。 定理4.1 设 J ⊂ R 为理想， H ′ 是J关于序 a < b < i < s < c < g 0 < g 1 < g 2 的Gröbner基。那么集合 H e l i m = H ′ ∩ R e l i m 是消去理想 J e l i m 的Gröbner基 [ 9 ]。 例1 (续) 为了消除变量 g 0 , g 1 , g 2 ，从H中删除涉及这些变量的多项式是不可行的。因此我们根据定理4.1中给定的序，去计算第二个Gröbner基 H ′ 。再从 H ′ 中删除涉及 g 0 , g 1 , g 2 的多项式，得 H e l i m = { − 2 c − s + a + b + i , − s + a + b + i − 2 a b − 2 a i − 2 b i + 4 a b i } . 由定理4.1， H e l i m 是 J e l i m ( A ) 的Gröbner基，则Gröbner 基就通过加法器重写得以化简。值得一提的是，对于本文研究的能完全分为全加器和半加法器的乘法器，可以约化首项是全加器或半加法器的和输出多项式，如 H e l i m 中多项式 − 2 c − s + a + b + i 就可以被首项是 − s 的多项式约化。将其从Gröbner基中消除会带来进一步的改进，但Gröbner基消除该方法有失完备性。"
"本节引入了一种基于电路列式切片的增量验证将乘法器电路的整体Gröbner基划分为2n个更小的切片Gröbner基。将问题分解为更小的2n个子问题，逐个解决 [ 15 ] [ 16 ]。 定义5.1 设C和C'是两个电路，如果 s i − s ′ i 是一个PCC ( i = 0 , 1 , ⋯ , m − 1 )，那么电路C和C'是等价的，记为 C ≡ C ′ 。 引理5.1 C ≡ C ′ 当且仅当 ∑ i = 0 m − 1 2 i ( s i − s ′ i ) ∈ J ( C ∪ C ′ ) 。 引理5.2 设C和C'是 两个电路，G和 G ′ 是理想 J ( C ) 和 J ( C ′ ) 关于序 ≺ , ≺ ′ 的Gröbner基。设 ≺ ∪ ​ 是一个反向拓扑序，使得 ≺ , ≺ ′ 属于 ≺ ∪ ​ 中。那么 G ∪ G ′ 是理想 J ( C ∪ C ′ ) 关于 ≺ ∪ ​ 的Gröbner基。 本文中的增量式等价性验证技术，使用切片和切片Gröbner基的定义 [ 15 ]。对电路进行切片，进而进行增量式的等价性验证，由于电路 C ∪ C ′ 的和的规范可能是未知的，或者无法在Z上以规范和抽象形式表示，不能使用对给定规范执行理想成员的资格测试。因此将 C ∪ C ′ 和表示为多项式集，并将它们的Gröbner基组合成一个模型 G ∪ ​ = G ∪ G ′ 。然后将问题转化为测试 G 1 和 G 2 关于 G ∪ ​ 中变量之间的成员关系。 定义5.2 设是C和C'上述的两个电路 1) 对于每对输出位s和s'，我们确定其输入锥，即与门，其依赖于： I i = { 门   g | g   在 输 出   s   或   s ′   的 输 入 锥 } 2) 切片 S i 定义为连续锥 I i 的差： S 0 : = I 0 S i + 1 : = I i + 1 ∖ ∪ j = 0 i S j 若 G i 是切片 S i 中电路C和C'的门 的多项式集，则易证 G i 是切片 S i 的Gröbner基。 定义5.3 设C和C'是上述两个电路，在其变量上m个 Δ 0 , ⋯ , Δ m 的多项式序列称为切片多项式序列，如果 − Δ i + 2 Δ i + 1 + ( s i − s ′ i ) ∈ J ( C ∪ C ′ ) ， ( 0 ≤ i ≤ m ) 那么多项式 E i = − Δ i + 2 Δ i + 1 + ( s i − s ′ i ) 就称为 Δ 0 , ⋯ , Δ m 序列的切片关系。 定理5.4 设C和C'是上述两个电路， Δ 0 , ⋯ , Δ m 是定义4.3中定义的切片多项式序列。那么根据引理5.1，C和C'是等价的( C ≡ C ′ )当且仅当 2 m Δ m − Δ 0 ∈ J ( C ∪ C ′ ) 。 证明： 根据定义5.3，得 J ( C ∪ C ′ ) ∑ i = 0 m − 1 2 i ( s i − s ′ i ) = ∑ i = 0 m − 1 2 i ( 2 Δ i + 1 − Δ i ) = 2 m Δ m − Δ 0 设边界 2 m Δ m = 0 Δ m − 1 = [ 2 Δ m + ( s m − s ′ m ) ] % G m − 1 Δ m − 2 = [ 2 Δ m − 1 + ( s m − 1 − s ′ m − 1 ) ] % G m − 2 ⋮ Δ 0 = 0 这确保了所有的 E i 都在 J ( C ∪ C ′ ) 中。 J ( C ∪ C ′ ) 包含所有的域多项式F，因此将它们添加到 G ∪ G ′ 中。最后，计算是否 Δ 0 = 0 。下面给出算法： 根据定理5.4，我们能推导出增量等价性验证算法。先固定边界 2 m Δ m = 0 ，并通过计算切片Gröbner基的 2 Δ i + 1 + s i − s ′ i 模的余数递归地导出 Δ i ， E i ∈ J ( C ∪ C ′ ) 。通过计算最后 Δ 0 的结果。如果 Δ 0 = 0 ，则乘法器电路C和C'是等价的。"
"本文对两类整数乘法器进行等价性验证，分别是btor乘法器和sp-ar-rc乘法器。这两个乘法器都是根据推论3.2中的部分积作为两个输入位，然后由全加器和半加法器进行累加，如图2所示。 图2. 具有 p i j = a i b j 的 n = 4 的btor乘法器(左)和sp-ar-rc (右)乘法器的结构 图2是 n = 4 的4位两输入的实验验证的两类乘法器的结构。在btor乘法器中，全加法器和半加法器以网格状结构累积(图2左侧)；而在sp-ar-rc乘法器中，全加法器和半加法器是对角累积的(图2右侧)。我们使用工具aigmultopoloy [ 15 ]，该工具以电路的AIG表示作为输入，并返回一个包含计算指令的文件。由于Mathematica输入语言更灵活，支持更多变量，被用作计算机代数系统，因而本文将这些指令传递给Mathematica。 实验使用了一台带有Ubuntu18.04虚拟机的笔记本电脑，配备Intel i5-8250 1.60 GHz CPU和4 GB主内存。运行时间限制设置为1200秒，主内存使用限制为4 GB。实验中的时间均以秒为单位列出。我们测量从aigmultopoloy开始到Mathematica 完成的时间，包括该aigmultopoloy工具生成Mathematica文件所需的时间和计算机代数系统的启动时间。在实验数据中用TO表示达到时间限制、MO表示达到内存限制、EE表示状态错误。 如表1所示，无论是Lingeling还是ABC在n大于8位时，都超出实验设定的运行时间，而增量方法能验证达32位的这两类乘法器的等价性 [ 16 ]。在此基础上添加加法器重写(第六列)，不仅能计算高达128位的等价性，同时8~32位乘法器的等价性验证也有着明显的加快。表中最后一列，不仅采用增量验证方法，还利用第四节中提到的Gröbner基消去，实验数据显示，与第六列相比对各位数乘法器的验证时间均略具优势。 Table 1 乘法器 n Lingeling ABC 增量方法 +加法器重写 +Gröbner基消去 btor vs. sp-ar-rc 8 13 18 2 0 0 btor vs. sp-ar-rc 16 TO TO 8 1 1 btor vs. sp-ar-rc 32 TO TO 82 4 3 btor vs. sp-ar-rc 64 TO TO TO 21 17 btor vs. sp-ar-rc 128 TO TO TO 188 175 表1. 等价性验证"
"本文基于Gröbner基着眼于结构相似的乘法器，采用了增量式的等价性验证算法。在这个基础上，添加加法器重写和Gröbner基消去的算法相关实现，并已于Linux系统中成功编译。实验对比不同方法进行等价性验证的运行时间，由实验数据易见，增量等价性验证能提高验证效率，并在此基础上进一步进行优化，其验证时间略具优势。未来如何将这些技术扩展到浮点运算，甚至更具挑战性的乘法器结构和其他算术电路还有待进一步研究。"
