"语音控制在智能家居的应用为人民生活带来极大便利，但常规的非特定人语音控制会产生语音的误触发 [ 1 ] 。本文在非特定语音识别的基础上，通过改进相应算法设计了一种特定人语音识别家居控制系统。系统采用MFCC算法获取语音特征，通过DTW算法实现语音特征匹配。上位机基于安卓平台，利用Android Studio工具并结合NDK组件实现相应软件与算法开发。下位机基于Zigbee平台，利用IAR完成家居系统下位机的开发。系统可完成特定人的语音控制，具有较高的识别率，操作更加人性化。 关键词 :家居系统，特定语音，语音控制，安卓平台，Zigbee平台 Copyright © 2017 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"语音控制技术突破传统手动操作的局限，让人与机器之间的沟通交流更智能化 [ 2 ] 。语音控制发展迅速，出现了许多出色的语音控制系统。其中语音控制家居系统发展前景广阔，针对家居控制的各项要求中，控制的准确性及安全性极为重要。本文在传统的语音家居控制系统基础上增加特定人语音识别，在非特定语音识别的基础上，通过改进相应算法设计出一种特定人语音识别家居控制系统，可减少意外因素所带来的语音误触。"
"特定人语音家居控制系统主要由移动终端控制和家居下位机控制组成(如图1)。移动终端基于安卓平台，由用户发送语音指令至移动平台，然后利用MFCC(梅尔频率倒谱系数)算法获取语音特征，并利用DTW (动态时间规整)算法实现语音特征匹配，最后经Wi-Fi将指令送至下位机。下位机基于Zigbee平台，作为系统执行者，首先接收来自上位机的Wi-Fi指令信号，然后对信号识别，实现对家电的控制。"
"语音信号经过预处理之后，提取语音特征的目的是为了提取说话人的语音特征进而确定说话人身份 [ 3 ] 。常用的特征参数提取算法有：基于人耳听觉特性的MFCC(梅尔倒谱系数)、基于声道特性的LPCC (线性预测倒谱系数)。本文采用MFCC算法。MFCC算法在孤立词识别上，相比基于声道模型的LPCC算法具有更好的鲁棒性，更符合人的听觉特征，当信噪比降低时仍然具有较好的识别性 [ 4 ] 。图2为MFCC特征参数提取原理，获得MFCC特征参数方法如下： 1) 先对输入信号进行预处理(分帧、加窗、预加重)，然后作离散傅立叶变换得到语音信号的频谱值。通过以上方式达到提高初始语音稳定性的效果并且方便后续语音特征参数的提取与匹配，并规整语音信号的频谱。设语音信号的离散傅里叶变换为： (1) N表示傅立叶变换的点数，x(n)表示语音输入信号。 2) 利用频谱幅度的平方获得能量谱。 3) 利用三角形滤波器组分析上述步骤获得的能量谱。 定义一个有M个三角滤波器的滤波器组，中心频率为 f ( m , m = 1 , 2 , ⋯ , M ) ，本文取M = 24。m值的减小会致 f ( m ) 之间的间隔减小，反之亦然。三角滤波器的频率响应定义为： 图1. 特定人语音家居控制系统原理 图2. MFCC特征参数提取原理 H m ( k ) = { 0 , k < f ( m − 1 ) 2 ( k − f ( m − 1 ) ) ( f ( m + 1 ) − f ( m − 1 ) ) ( f ( m ) − f ( m − 1 ) ) ,   f ( m − 1 ) ≤ k ≤ f ( m ) 2 ( f ( m + 1 ) − k ) ( f ( m + 1 ) − f ( m − 1 ) ) ( f ( m + 1 ) − f ( m ) ) ,   f ( m ) ≤ k ≤ f ( m + 1 ) 0 , k ≥ f ( m + 1 ) (2) 其中 ∑ m = 0 M − 1 H m ( k ) = 1 4) 根据(1)与(2)的结果计算MFCC对数能量： s ( m ) = ln ( ∑ k = 0 N − 1 | X a ( k ) | 2 X m ( k ) ) ,   0 ≤ m ≤ M (3) 5) 经离散余弦变换得到MFCC参数： C ( n ) = ∑ m = 0 N − 1 S ( m ) cos ( π n ( m − 0.5 ) M ) ,   0 ≤ n ≤ M (4)  为解决说话人与模板语音的问题，本文采用特征参数匹配算法(如图3)。经过MFCC算法提取得到相应的参数即匹配中所使用的特征参数，再根据特征参数建立相应模板完成说话人语音匹配。在时间序列中，若语音信号波形长度相等则语音较容易匹配 [ 5 ] 。如图4所示，需要比较相似性的两段时间序列的长度可能并不相等，在语音识别领域，语音信号存在一定的随机性，比如a点会对应到b点。传统的欧几里得测距无法有效求出两个时间序列间的距离，利用DTW算法可找到a点实际应匹配的c点。 DTW利用非线性规整技术可有效完成孤立词的匹配，通过规划函数 i m = Ф ( i n ) ，将参考模板的时间轴m与测试信号的时间轴n实现非线性地映射，并使该函数满足： D = min Φ ( i n ) ∑ i n = 1 N d ( T ( i n ) ,   R ( Φ ( i n ) ) ) (5) D代表最优时间规整下两矢量间的长度。DTW算法利用局部最佳化的处理寻找最优路径。在最优路径中，信号特征变量的累积失真最小，有效减少时间不统一所带来的误差。 DTW算法原理如图5，横轴为测试模板的各个帧号 n = 1 ~ N ，纵轴为参考模板的各帧 m = 1 ~ M 。 图3. 特征参数匹配流程 图4. DTW算法原理 图5. DTW算法原理 DTW算法首先分析两个模板各帧之间的长度，接着在帧匹配距离矩阵中寻求最优路径。寻求最优路径方式描述为：从图5中(1,1) 点开始，到达点 ( i n , i m ) 有三种方式(如图6，分别为 ( i n − 1 , i m ) 、 ( i n − 1 , i m − 1 ) 和 ( i n − 1 , i m − 2 ) )。从这三种方式找到距离 ( i n , i m ) 最近的方式，获得累积距离： D ( i n , i m ) = d ( T ( i n ) ,   R ( i m ) ) + m i n { D ( i n − 1 , i m ) ,   D ( i n − 1 , i m − 1 ) , D ( i n − 1 , i m − 2 ) } (6) 这样从点(1,1)出发至(N,M)反复计算获得最优路径。待测语音和模板语音进行匹配，获得的最优路径距离为识别结果 [ 6 ] 。 常规的DTW匹配算法存在效率低下问题。论文利用放宽端点限制DTW算法(如图7)：利用先验知识估计点(i,j)，路径规划分为从(i,j)至点(N,M)以及从点(i,j)至点(1,1)，这样点(i,j)分段向(N,M)和(1,1)计算。由此解决DTW算法端点对齐上存在的不足，并可有效缩小搜索空间。 图6. 局部约束路径 图7. 放宽端点限制DTW算法原理"
"本文利用Android Studio 2.2.3 (JDK1.8, Gradle 2.2.3)完成上位机软件开发。在软件设计中，首先选择操作模式(手动模式和语音模式)，语音操作模式需录入5次语音命令以保证特征提取的精度，利用MFCC算法及DTW算法对语音的特征提取和语音匹配，最后将指令发送至下位机。上位机软件流程如图8。 上位机软件主程序包括：界面设定、语音输入、NDK语音处理以及Wi-Fi传输模块。具体完成步骤如下： 1) 界面设定 上位机界面主要包含模式切换界面以及语音控制界面。其中语音控制界面包含语音特征录入、语音特征删除及语音输入。 2) 语音输入 通过搭载Android移动设备的麦克风完成录音工作，语音录制须开启两个权限： 图8. 上位机软件设计流程 完成语音传输的步骤： ① 先调用setAudioSource( )完成初始化状态 ② 调用setOutputFormat( )设定输出格式，完成设定输出，完成数据源组态。 ③ 设定setAudioEncoder( )编码器，以及setOutFile( )输出文件。 ④ 调用prepare( )进入准备完成状态 ⑤ 调用start()进行录音 3) NDK语音处理 NDK利用C/C++等原生代码执行部分程序处理语音信号和图形图像识别等 [ 7 ] 。利用NDK开发有利于防止代码反编译且方便外部代码移植。NDK开发步骤： ① 打开Android Studio其中SDK Manager，勾选其中的CMake、NDK、LLDB。 ② 创建工程，选中Include C++ Support，然后点击Finish。若出现报错则检查上述步骤。 ③ 进入主界面后先在MainActivity定义相应的函数，然后进入cpp下完成C/C++的编写。 ④ 最后在Java框架下调用所定义的函数。 4) Wi-Fi传输 Wi-Fi传输类似于蓝牙一样在两个设备之间直接建立数据传输通道。Wi-Fi的有效距离较长，传输速率及穿墙性优于蓝牙传输。在Android SDK中提供了相应的API，通过这些API可以发现其他支持Wi-Fi Direct的设备，也可以接收其他支持Wi-Fi Direct的设备。Wi-Fi传输开发如下： ① 创建监听Wi-Fi Direct动作的广播接收器 public class WiFiDirectBroadcastReceiver extends BroadCastReceiver {public void onReceive(Context context,Intent intent){ } } ② 注册广播接收器 注册广播接收器需在AndroidManifest.xml中限制Android版本至少为4.0。且添加与Wi-Fi相关的权限。利用BroadCastReceiver相应组件完成注册。 ③ 发现并连接设备 使用Wi-Fi Direct进行通信。首先要搜索周围的Wi-Fi设备，调用Wi-FiP2pManager.discoverPeers方法完成这项工作。当搜索到Wi-Fi设备后，可以选择其中设备进行连接。每一个设备都是WiFiP2pDevice对象，然后利用WifiP2pDevice对象存储设备相关的信息。最后调用WifiP2pManager.connect方法连接设备。 ④ 数据传输 当设备之间建立连接后，可以调用WiFiP2PpManager.requestConnectionInfo方法获取作为服务端设备信息。根据主机信息，先创建ServerSocket对象，然后使用ServerSocket.accept方法等待另一端连接。"
"下位机负责与上位机进行数据通信和家电控制。下位机硬件机构如图9。下位机一部分是充当信号中转站，收到Wi-Fi数据，然后按照Zigbee的协议进行封包，在设置好通道参数的前提下，再通过Zigbee芯片发送至相应节点；另一部分用作终端节点，主要负责数据的采集及控制命令的执行 [ 8 ] 。  上位机和下位机间通信过程是由上位机发出请求通信，下位机完成执行 [ 9 ] 。终端节点与协调器的通信是通过终端节点将信息发送至协调器，再经串口送至上位机。下位机软件设计包括终端节点软件和协调器软件的设计。软件设计主要分为组网与联网、端点通信和节点间数据通信，程序流程如图10。"
"本文利用搭载Android7.0的安卓智机为测试工具，录音采用手机麦克风，提取语音MFCC参数储存 图9. 下位机硬件系统结构 图10. 下位机程序流程图 Table 1 测试语音 室内安静下语音识别成功率/% 人物一 人物二 人物三 打开台灯 89% 19% 18% 关闭窗帘 87% 21% 17% 表1. 特定人语音家居识别系统结果(室内安静状态) Table 2 测试语音 室内嘈杂下语音识别成功率/% 人物一 人物二 人物三 打开台灯 86% 23% 21% 关闭窗帘 84% 21% 22% 表2. 特定人语音家居识别系统结果(室内嘈杂状态) 在手机内存上。系统下位机采用Zigbee开发工具箱(CITE-T-ZA)完成对智能家居的模拟。采用语音预加重系数a = 0.9，汉明窗作为窗函数 [ 10 ] ，采样频率9 khz、18 big，帧移85，语音每帧28 ms。实验对于孤立词各训练5次，并在室内相对安静与嘈杂环境进行100次语音控制测试。测试不同人物的传输成功率以及不同指令的传输成功率 [ 11 ] (其中人物一为主说话人，其他为参照对象)，解锁成功率为说出四字短语到下位机执行操作的成功度，结果如下： 据表1与表2可观测出：特定人语音的识别正确率较参照对象有明显的区别；且室内识别成功率高于室外。根据本文的改进算法，针对特定人的语音识别能够准确识别特定人的语音，进而防止非特定人语音误触的发生，且在室内外均能准确的识别特定人的语音。"
"本文基于MFCC和DTW设计出一种特定人语音识别家居控制系统。相较于传统的语音控制模式，系统可完成特定人的语音控制，具有较高的识别率、安全性及稳定性，语音操作更加人性化。"
