"这篇文献改进了图像加密算法，提高了图像的嵌入容量。原文献中将图像按列分为256 * 1大小的块，嵌入的信息和块的多少有关。原文中分块太大而导致嵌入的信息相对较少，所以，本文将块尽可能地分小，并修改了嵌入方法并根据均值像素的相邻像素完全提取信息，使得嵌入的信息增加。本分主要讨论的是基于加密域的可逆信息隐藏的算法中的加密后腾出空间的方法。实验结果表明，修改后的算法嵌入的数据比原文多了十多倍，提出的方案同样简单易操作并具有安全性和可逆性、隐私保护性。 关键词 :图像加密，图像恢复，信息嵌入，可逆信息隐藏 Copyright © 2018 by authors and Hans Publishers Inc. This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/"
"随着人们对隐私保护也越来越重视，但是普遍的图像可逆信息隐藏算法存在着容量不足的问题。因此本文将致力于改进图像的嵌入容量，增加图片的嵌入信息，并且使得恢复出来的图像和原始图像的像素误差不大。 可逆信息隐藏按嵌入域分可以分为空域和变换域这两种类型。空域指的是直接图像的像素进行操作，而变换域指的是通过一系列可逆的变换方式(如DCT变换等)对图像进行操作。可逆信息隐藏也可以分为加密图像的可逆信息隐藏和未加密图像的可逆信息隐藏。通常，基于未加密图像的可逆信息隐藏中使用的是差值扩展和直方图平移的方法。而加密域的可逆信息隐藏又可以分为加密前腾出空间和加密后腾出空间的方法。接下来，我们主要讨论的是基于加密域的可逆信息隐藏的算法中的加密后腾出空间的方法。加密后腾出空间的算法又可以分为联合算法和可分离算法。联合算法必须是在解密后的图像中提取信息，然后再恢复图像。而可分离算法可以在含有隐藏信息的加密图像中提取信息，再根据加密密钥解密图像，并得到恢复的图像。"
"将图像按列进行分块，记分块后剩余的像素为Rest。计算每一个块的均值，将均值像素代替每一个块的第一个像素。再将计算过均值的块和剩余的块合并成图像J。分块取平均值(avg.m):[J,p] = avg(origin_img,x)传入：原始图像、分块大小，返回：计算均值后的图像及分块个数  产生与图像大小的伪随机数记为R，将图像中除均值像素外的所有像素用公式(3)计算加密像素值得到加密图像E。加密图像(encrypted.m)：E = encrypted (J, R, x)。传入：均值图像、加密密钥(伪随机数)、分块大小返回：加密图像 E ( i , j ) = ( J ( i , j ) + R ( i , j ) ) mod 256 (3)  对加密图像E中的像素嵌入信息。如果一个块的嵌入信息为1，则将加密图像中该块中除均值像素外的二进制加1010，如果嵌入信息为0，则不改变加密图像的像素值。1010即为十进制的10，如果我们相加的数太小了，那么在块分小了之后，如果嵌入为1，那么除均值像素外的像素累计加的数太小，导致在算均值位置的原始像素与我们嵌入0算出的结果相差不大，或者更平滑如果相加的数太大了，也有同样的问题。或者是如果原始图像中均值像素和周围像素相差太大，那么算出的结果可能是错误的值相关性更大。如果像素值为255，二进制为11111111，加上1010为1001。像素值大于245的计算方法如255。将嵌入信息后的加密图像记为C。  将图像C中每一个块中除均值以外的像素值用公式(4)进行解密，得到含有隐藏信息的解密图像D。 D ( i , j ) = ( C ( i , j ) − R ( i , j ) ) mod 256 (4) 其中，R (i, j)和加密时的伪随机数是一样的。解密图像(decrypted.m):D = decrypted (C, R, x)传入：嵌入信息后的加密图像、加密密钥、分块大小返回：解密图像。  对于含有隐藏信息的加密图像中的每一个块，我们并不知道嵌入的数据为0还是1，将原始的块记为B0作为嵌入为0的块，将除均值外像素二进制减去1010后的块记为B1作为嵌入为1的块。如果在像素值小于等于9，在减1010时，在最高位添一个1相减，例如：9的二进制为00001001，在最高位添一个1变成：100001001，再将这个数减去1010得到11111111，即255。其他小于9的数字也是同样的计算方式。 通过公式(5)计算两种情况下的均值像素记为first0和first1。 first = round ( s 1 j ∗ x − ∑ i = 2 x sij ) (5) 其中，s1j代表每一个块的均值像素值，x为分块大小，sij为块中的像素值。 在嵌入为0和嵌入为1的情况下，计算块中每一个像素的预测值，并将他们与对应的像素值求绝对值后相加。在嵌入为0的情况下，计算该像素相邻四个像素的均值记为A0。在嵌入为1的情况下，计算该像素相邻四个像素的均值记为A1。如图1所示，如果均值像素位于图像边缘，则取它上下左右在图像范围内的像素。通过公式(6)判断嵌入为0还是1。 f 0 = abs ( x 0 − A 0 ) (6) f1 = abs ( x1 − A1 ) (7) 其中x0为嵌入为0时对应的像素值，而x1为嵌入为1时对应的像素值。因为像素之间的相关性，未嵌入信息的像素要比嵌入信息后的像素更平滑，所以，若f0 > f1则嵌入为1，均值像素为x1，原始块为B1；若f0 < f1则嵌入为0，均值像素为x0，原始块为B0。正确提取信息后，图像得到完美恢复。"
"该算法测试的图像均为512 * 512大小，分块最小能分到20 * 1，嵌入数据为13,107比特，是文献 [ 1 ] 中的12倍左右。以Lena图像为例，该算法的仿真结果如图2所示。 图1. 像素预测 图2. 仿真结果 通过上述仿真结果我们可以看到加密后的图像看不见原始的内容，从而确保原始图像的隐私。对应的直方图如图3所示。 从上述的直方图的结果可以看出，嵌入的加密图像和数据的直方图与原始图像的直方图有很大的不同，加密后嵌入信息的直方图像素分布均匀，无法识别原始图像的内容。恢复图像的直方图与原始图像相同，说明了我们算法的可逆性。 选取了九张512 * 512图像进行测试，包括了lena，zelda，Man，airplane，couple，sailboat，baboon，goldhill，barbara图像。用文献 [ 1 ] 的算法块大小与信息提取错误的趋势如图4所示，采用本文的算法仿真分析改进后的错误趋势如图5所示。 图3. 直方图结果 图4. 块的大小与信息提取错误的趋势 图5. 块的大小与信息提取错误的趋势 分块出现错误的原因：放均值的像素与周围像素相差太大，导致预测的不准确。块分小了，剩余像素累计加1的值变小了，与未加1得出的均值位原始像素差距不大，可能会更接近预测的像素。"
"文献 [ 2 ] 提出了采用传统的RDH方案和统一嵌入置乱方案两种RDH方法在加密图像中嵌入信息。 [ 3 ] 在 [ 2 ] 的基础上该方案获得了最佳的视觉质量和增强的嵌入率。测试结果和相关性被展示，概述了提议的技术与传统技术的可行性和重点。文献 [ 4 ] 提出了一种基于加密JPEG位流的可逆数据隐藏框架，其次，嵌入的有效载荷比文献 [ 3 ] 还要大。文献 [ 5 ] 中的方法无需对原始图像进行预处理，即可将附加数据直接嵌入到加密图像中。文献 [ 6 ] 根据隐藏密钥选取部分加密像素，用LDPC码对选中像素的MSB进行Slepian-Wolf编码，为信息隐藏预留空间，该算法能无损重建原始图像，提高了嵌入率，不过，压缩像素MSB导致了解密图像质量不高的问题(例如嵌入率为0.05 bpp时，Baboon图像的解密图像PSNR不到25 dB)。文献 [ 7 ] 根据相邻像素间的位置关系，将加密像素分为三个集合，压缩每个集合中像素的3 LSB，为信息隐藏预留空间，此外，该算法中提出的渐进图像解密机制提供了更好的率失真性能，i.e.，在相同解密图像PSNR值下，更大的信息嵌入率。此外，文献 [ 8 ] [ 9 ] 基于位替换(替换加密像素的某些比特为秘密比特)的方法也实现了信息隐藏。其中，文献 [ 8 ] 将密文图像LSBs位平面中的部分比特替换为秘密信息，用经被替换比特和嵌入秘密比特调制生成的伪随机序列修改LSBs位平面中余下比特，该算法虽然实现了信息提取与图像解密恢复的可分离，但信息提取会出现错误；文献 [ 9 ] 提出一种基于预测误差的可分离RDH-EI算法，用XOR加密原始图像，通过替换加密像素的最高位(或次高位)隐藏信息，基于预测误差的方法重建原始图像，该可分离RDH-EI算法具有较高信息隐藏容量，能以一定概率无损重建原始图像。不过，文献 [ 9 ] 的可分离算法解密图像质量较低，即使嵌入率低至约0.016 bpp，平滑图像(如Lena)和纹理图像(如Baboon)的解密图像与原始图像的PSNR分别仅为35 dB和24 dB左右。 [ 1 ] 是将图像按列分块，并计算每一个块的均值，将均值放在每一个块的第一个像素的位置，采用mod256对图像进行加密，嵌入信息为1时则将每一个块除均值像素外的像素加1，嵌入为0则保持不变，在提取信息恢复图像时，根据数学公式对整个块进行判断嵌入的信息为1还是0，提取信息后便能完全恢复图像。综合以上文献的的处理方法和嵌入信息量的算法综合考虑提出了本文的算法，主要在提升信息的嵌入率。 在文献 [ 1 ] 中，嵌入的信息的大小与分块的个数有关，即分多少个块嵌入多少比特的信息。文献 [ 1 ] 中分块大小为256 * 1，那么512 * 512大小的图像只能嵌入1024比特的数据。相比于其他算法来说，嵌入的容量太少了。经过实验仿真分析发现文献 [ 1 ] 中分块最小为229左右，最多能嵌入1144比特的数据，如果块小于229，则提取的信息错误率会上升，导致我们恢复出来的图像和原始图像的PSNR降低。经过对像素的分析，我们发现，块分小了之后，通过原算法的提取方式算出的区间不准确。 [ 1 ] 的提取公式如下公式(1) (2)所示： B ∈ ( ( x + 1 ) A x − 255 x , ( x + 1 ) A x ) 提取为0 (1) B ∈ ( ( x + 1 ) A x , ( x + 1 ) A x + 255 x ) 提取为1 (2) 其中B为含有隐藏信息的解密图像中每一个块的均值，x为分块的大小，A为块中第一像素值，也就是该块中所有原像素的均值。从公式中，我们得知，如果x过于小，那么255/x偏大，该区间可能存在重合部分或者B不在该区间上等情况，所以，如果块分小了之后用该方法提取信息是不准确的。"
"本文的加密方法和文献 [ 1 ] 是一样的。在嵌入信息时将加密图像除均值外的像素改变大一点，在提取信息时，通过均值像素的相邻像素对均值像素的预测从而正确提取信息并且恢复原始图像。但是文献 [ 1 ] 中的算法提取信息，则块分小了(分母变大了)，区间的值不准确(X为块的大小)。 在这篇文献中，基于文献 [ 1 ] 改进的算法被提出了。修改了嵌入方法并且通过相邻像素的相关性提取信息完美恢复了图像，通过此操作提高了它的嵌入容量，降低了信息提取的错误率。该方法的实验结果表明嵌入容量比文献 [ 1 ] 大得多，并且致我们恢复出来的图像和原始图像的PSNR值变化不大，这说明在加密和解密的过程中图像的画质得到了很好的保护。此外在直方图中可以直观的看出加密和嵌入信息后的直方图均匀。并且通过本文的算法，在仿真分析结果可以看出块的大小与信息提取错误的趋势明显下降且更加稳定。因此在文献 [ 1 ] 的基础上，提出了一种基于相邻像素的预测来判断均值像素的值，并且恢复原始图像。本文的算法改进过程为计算均值、加密图像、嵌入信息、解密图像、提取信息恢复图像，成功的实现了增大嵌入容量，提取正确信息的效果。"
