"本文在Nikas的含区间参数非线性方程的拓展区间牛顿法的基础上，结合多步区间迭代，提出了求解含区间参数非线性方程的一个拓展的多步区间迭代算法，证明新算法至少具有三阶收敛的性质，同时给出了12个数值算例，算例结果验证了新提出的多步区间迭代算法相比Nikas提出的拓展区间牛顿法在计算效率上有所提高，是有效和可靠的。"
"非线性问题在现实生活中有着极其广泛地应用，国内外许多学者提炼出诸多科学领域(如航天航空 [ 1 ]、气象 [ 2 ]、化学、生物 [ 3 ]、流体力学、建筑 [ 4 ] )的重要非线性方程，这些方程亟待解决。大部分情况下非线性方程很难获得精确解，通常运用数值解法求其数值解，并保证数值解与真解的误差要控制在实际问题可以接受的范围内，区间方法就是其中一种新颖的数值方法。 Moore首次将牛顿迭代法拓展成区间牛顿迭代形式，得到区间牛顿迭代法 [ 5 ]，虽然此方法适用于大部分方程，但是在导数区间扩张包含零的情况下却无法使用；1979年，Hansen对区间牛顿法进行了改进使其能在所有情况下适用，并能够收敛到方程的零解 [ 6 ]；2007年，Nikas将区间牛顿法推广到含参数的区间方程中，形成了拓展的区间牛顿法，通过逐步隔离零解区间(零解所在的区间)的端点来获得零解区间的近似，最终能准确收敛到零解区间，并用一系列例子进行数值模拟，验证了其方法的正确性 [ 6 ]。 在实际工程问题中，由于参数的测量不可能完全精确，我们经常会遇到如下形式的方程 f ( x ; p ) = 0 (1.1) 其中， p ∈ [ p ] , [ p ] ∈ I R ，IR为由实数表示的所有区间数全体。 为方便引入如下定义： 定义1.1设 f : R × I R → I R 是一个连续可微的函数， [ x ] 0 是初始搜索区间， [ p ] 是包含f中所有参数的区间向量。则形如 f ( x ; [ p ] ) = 0 (1.2) 的非线性区间方程称为含参数的非线性区间方程。 (1.2)中所有零解区间包含了所有方程(1.1)中的所有零点，(1.2)的零解区间有三种情况：零区间(没有零点)、退化区间(只有一个零点或多个间断的零点)、非退化区间。显然，对于最后一种情况，零解区间包含的零点无穷多个零点，但因为(1.2)中的参数是连续变化的， f ( x ; [ p ] ) = 0 的零点也应该是连续变化的，且零解区间的个数是有限的。因此我们不是去搜索单独的零点而是去确定所有零点所组成的区间。 根据上述解释，我们可以得到如下定义： 定义1.2 ∀ p ∈ [ p ] ∈ I R , f ( x , p ) = 0 都有零点，所有参数遍历参数区间后形成的零点集合构成了 f ( x ; [ p ] ) = 0 的解集，称为零解区间。  为了后继表述的方便，我们给出如下区间分析的相关定义和规定，详细的信息可参考 [ 5 ]。 实数区间是有界闭集，且具有如下形式： [ x ] = [ x _ , x ¯ ] = { x ∈ R | x _ ≤ x ≤ x ¯ } 其中， x _ , x ¯ ∈ R 且 x _ ≤ x ¯ ， x _ 表示区间下界， x ¯ 为区间上界。有界闭区间通常用IR表示。 下面介绍关于区间的四个简单概念：区间中点 m ( [ x ] ) 、区间半径 r ( [ x ] ) 、区间宽度 w ( [ x ] ) 、区间并 ⊔ m ( [ x ] ) = x _ + x ¯ 2 r ( [ x ] ) = x ¯ − x _ 2 w ( [ x ] ) = x ¯ − x _ = 2 r ( [ x ] ) [ x ] ⊔ [ y ] = [ min { x _ , y _ } , max { x ¯ , y ¯ } ] 以及区间的四则运算： [ x ] + [ y ] = [ x _ + y _ , x ¯ + y ¯ ] [ x ] − [ y ] = [ x _ − y ¯ , x ¯ − y _ ] [ x ] ⋅ [ y ] = [ min { x _   y _ , x ¯   y ¯ , x _   y ¯ , x ¯ y _ } , max { x _   y _ , x ¯   y ¯ , x _   y ¯ , x ¯ y _ } ] [ x ] [ y ] = [ min { x ¯ y ¯ , x _ y ¯ , x ¯ y ¯ , x _ y ¯ } , max { x ¯ y ¯ , x _ y ¯ , x ¯ y ¯ , x _ y ¯ } ] , 0 ∉ [ y ] 由区间并的概念可将区间四则运算转换为如下形式： [ x ] + [ y ] = { x _ + [ y ] } ⊔ { x ¯ + [ y ] } [ x ] − [ y ] = { x _ − [ y ] } ⊔ { x ¯ − [ y ] } [ x ] ⋅ [ y ] = { x _ ⋅ [ y ] } ⊔ { x ¯ ⋅ [ y ] } [ x ] [ y ] = { x _ [ y ] } ⊔ { x ¯ [ y ] } (1.3)"
"解决参数固定的情况下的非线性区间方程 f ( x ; p ) = 0 ，通常采用普通的区间牛顿法，即 { m k = m ( [ x ] k ) N ( [ x ] k ) = m k − F ( m k ) F ′ ( [ x ] k ) [ x ] k + 1 = [ x ] k ∩ N ( [ x ] k ) (2.1) 但对含参数的非线性区间方程(1.2)，普通的区间牛顿法应用会出现一些缺陷。例如，对于非退化的零解区间，该算法并不能收敛到(1.2)的解区间。Nikas详细论述了其在迭代过程中由于收敛到点造成的不精确问题、不能保证所求零解区间的连续性、以及其他一些病态情况 [ 7 ]。 为此Nikas提出了拓展的区间牛顿法(EIN) [ 7 ]，以下加以介绍： 对于含参数的非线性区间方程 f ( x , [ p ] ) = 0 ，令 F ( m ( [ x ] ) , [ p ] ) = [ F m _ , F m ¯ ] ， F ′ ( m ( [ x ] ) , [ p ] ) = [ d _ , d ¯ ] ，则(2.1)中 N ( [ x ] k ) 可改写为 N ( [ x ] k ) = m k − F ( m k , [ p ] ) F ′ ( [ x ] k , [ p ] ) = m k − [ F m _ , F m ¯ ] [ d _ , d ¯ ] = m k − F m _ [ d _ , d ¯ ] ⊔ F m ¯ [ d _ , d ¯ ] = ( m − F m _ [ d _ , d ¯ ] ) ⊔ ( m − F m ¯ [ d _ , d ¯ ] ) 令 N L = m − F m _ [ d _ , d ¯ ] ， N U = m − F m ¯ [ d _ , d ¯ ] ，则普通区间牛顿迭代可变为拓展的区间牛顿迭代，即 { m k = m ( [ x ] k ) H ( [ x ] k ) = N L ⊔ N U [ x ] k + 1 = [ x ] k ∩ H ( [ x ] k ) (2.2) 下面给出 [ 7 ] 中证明 H ( [ x ] k ) = N L ⊔ N U 内部的部分零解区间 [ r ] 的存在性的三个定理： 定理2.1 [ 7 ] 假设f是定义1.1中定义含参数的非线性连续可微区间函数，设区间方程 f ( x , [ p ] ) = 0 的初始区间为 [ x ] 和零解区间为 [ x ] * ⊆ [ x ] 。如果 0 ∈ F ( m , [ p ] ) ，则内部区间 [ r ] = [ min { N L ¯ , N U ¯ } , max { N L _ , N U _ } ] 必定存在且 [ r ] ⊆ [ x ] * (情况分为四种，见图1)。 定理2.2 [ 7 ] 假设f是定义1.1中定义含参数的非线性连续可微区间函数，设区间方程 f ( x , [ p ] ) = 0 的初始区间为 [ x ] 及零解区间为 [ x ] * ⊆ [ x ] 。如果 0 ∉ F ( m , [ p ] ) 且 0 ∉ F ′ ( m , [ p ] ) ，且内部区间 [ r ] 存在则 [ r ] ⊆ [ x ] * (情况为两种，见图2)。 图1. 定理2.1的四种情况 图2. 定理2.2的两种情况(第二种中 [ r ] 情况不存在) 定理2.3 [ 7 ] 假设f是定义1.1中定义含参数的非线性连续可微区间函数，设区间方程 f ( x , [ p ] ) = 0 的初始区间为 [ x ] 及零解区间为 [ x ] * ⊆ [ x ] 。如果 0 ∉ F ( m , [ p ] ) 且 0 ∈ F ′ ( m , [ p ] ) ，此时 [ r ] 存在，但是 [ r ] ∉ [ x ] * ，由此可以将此区间排除(情况为两种，见图3)。 除了以上情况之外还有一种特殊情况，即当 0 ∈ F ′ ( m , [ p ] ) 和 F m _ = 0 或 F m ¯ = 0 时，由H算子所得的新搜索区间为实数轴上的一条直线，与原搜索区间的交依然是原搜索区间，搜索区间没有减小。对于这种情况，采用启发式技术，即采用二分法对搜索区间进行人工分割，旨在避免导致这种特殊情况的产生。"
"Nikas算法实质上是对含参数的非线性区间函数的上界函数 f U 与上界函数 f U 应用了点迭代的牛顿算子，容易证明，Nikas的算法收敛速度一般是有限的，只有在处理单调区间上的问题才具有二阶敛速。这启发我们将点迭代中加速牛顿算子的方法应用到Nikas算法中。下面我们介绍多步区间迭代法 [ 8 ]： 3.1. 二步区间牛顿迭代 [ 8 ] 对传统的二步牛顿迭代进行区间扩张，可以得到二步区间牛顿迭代： 图3. 定理2.3的两种情况 [ x ] k + 1 = [ x ] k ∩ P ( [ x ] k , [ y ] k ) 其中， P ( [ x ] k , [ y ] k ) = m ( [ y ] k ) − f ( m ( [ y ] k ) ) F ′ ( [ x ] k ) [ y ] k = [ x ] k ∩ N ( [ x ] k ) N ( [ x ] k ) = m ( [ x ] k ) − f ( m ( [ x ] k ) ) F ′ ( [ x ] k ) 3.2. 区间Ostrowski迭代 [ 8 ] [ x ] k + 1 = [ x ] k ∩ O ( [ x ] k , [ y ] k ) 其中， O ( [ x ] k , [ y ] k ) = m ( [ y ] k ) − f ( m ( [ x ] k ) ) ( f ( m ( [ x ] k ) ) − 2 f ( m ( [ y ] k ) ) ) F ′ ( [ x ] k ) f ( m ( [ y ] k ) ) [ y ] k = [ x ] k ∩ N ( [ x ] k ) N ( [ x ] k ) = m ( [ x ] k ) − f ( m ( [ x ] k ) ) F ′ ( [ x ] k ) 3.3. 区间King迭代 [ 8 ] 对King迭代法坐区间扩张也可得到如下形式： [ x ] k + 1 = [ x ] k ∩ K ( [ x ] k , [ y ] k ) 其中， K ( [ x ] k , [ y ] k ) = m ( [ y ] k ) − θ k f ( m ( [ y ] k ) ) F ′ ( [ x ] k ) [ y ] k = [ x ] k ∩ N ( [ x ] k ) N ( [ x ] k ) = m ( [ x ] k ) − f ( m ( [ x ] k ) ) F ′ ( [ x ] k ) θ k = f ( m ( [ x ] k ) ) − 1 2 f ( m ( [ y ] k ) ) f ( m ( [ x ] k ) ) − 5 2 f ( m ( [ y ] k ) ) 由文献 [ 8 ] 可知以上区间迭代法都是至少三阶收敛的，我们将其运用到拓展的区间牛顿法的零解区间端点的逼近上，可以将拓展的区间牛顿法的收敛阶予以提高，使其以更快的速度收敛到零解区间。"
"拓展的区间牛顿算法为： { m k = m ( [ x ] k ) H ( [ x ] k ) = N L ⊔ N U [ x ] k + 1 = [ x ] k ∩ H ( [ x ] k ) 其中 N L = m − F m _ [ d _ , d ¯ ] ， N U = m − F m ¯ [ d _ , d ¯ ] 。 运用二步区间牛顿迭代修改 N L , N U 算子为 P L , P U 算子： P L ( [ x ] k , [ y ] k ) = m ( [ y ] k ) − inf ( F ( m ( [ y ] k ) ) ) F ′ ( [ x ] k ) [ y ] k = [ x ] k ∩ N L ( [ x ] k ) N L ( [ x ] k ) = m ( [ x ] k ) − inf ( F ( m ( [ x ] k ) ) ) F ′ ( [ x ] k ) 以及 P U ( [ x ] k , [ y ] k ) = m ( [ y ] k ) − sup ( F ( m ( [ y ] k ) ) ) F ′ ( [ x ] k ) [ y ] k = [ x ] k ∩ N U ( [ x ] k ) N U ( [ x ] k ) = m ( [ x ] k ) − sup ( F ( m ( [ x ] k ) ) ) F ′ ( [ x ] k ) 由此可以得到拓展的二步区间牛顿迭代(EIN_Multi)： { m k = m ( [ x ] k ) P ( [ x ] k ) = P L ⊔ P U [ x ] k + 1 = [ x ] k ∩ P ( [ x ] k ) 其中， P L = P L ( [ x ] k , N L ( [ x ] k ) ) ， P U = P U ( [ x ] k , N U [ [ x ] k ] ) 。 相似的，我们也同样能得到拓展的区间Ostrowski迭代与拓展的区间King迭代： 拓展的区间Ostrowski迭代(EIN_Ostrowski)： { m k = m ( [ x ] k ) O ( [ x ] k ) = O L ⊔ O U [ x ] k + 1 = [ x ] k ∩ O ( [ x ] k ) 其中， O L = O L ( [ x ] k , N L ( [ x ] k ) ) ， O U = O U ( [ x ] k , N U ( [ x ] k ) ) 。 拓展的区间King迭代(EIN_King)： { m k = m ( [ x ] k ) K ( [ x ] k ) = K L ⊔ K U [ x ] k + 1 = [ x ] k ∩ K ( [ x ] k ) 其中， K L = K L ( [ x ] k , N L ( [ x ] k ) ) ， K U = K U ( [ x ] k , N U ( [ x ] k ) ) 。 引理4.1 [ 5 ] 设 F ′ ( [ x ] ) 为Lipschitz区间函数， x * 为非线性方程的实根，则存在常数 0 < c < 1 ，使得： F ′ ( [ x ] ) ⊆ f ′ ( x * ) + c w ( [ x ] ) ⋅ [ − 1 , 1 ] 因此，存在常数 K > 0 ，使得： w ( 1 F ′ ( [ x ] ) ) ≤ K w ( [ x ] ) 引理4.2 [ 7 ] 零解区间 [ x ] * ⊆ [ x ] 的端点可以被 N L 与 N U 封闭到任意精度，零解区间可以被拓展的牛顿区间迭代封闭到任意精度，且在单调区间的收敛速度至少是二阶的。 定理4.1 零解区间 [ x ] * ⊆ [ x ] 的端点可以被 P L 与 P U 封闭到任意精度，也由此可知零解区间可以被拓展的二步区间牛顿迭代封闭到任意精度，且在单调区间上拓展的二步区间牛顿收敛速度至少是三阶的。 证明：由引理4.2可知 N L 算子与 N U 算子在求解非线性函数时是收敛的，且对于单调函数零点求解时具备二阶敛速，即存在 k 1 > 0 ，使得： w ( N L ( [ x ] k ) ) ≤ k 1 w ( [ x ] k ) 2 由中值定理可知，存在 ξ ∈ N L ( [ x ] k ) ，使得： w ( P L ) ≤ | f L ( m ( [ y ] k ) ) F ′ ( [ x ] k ) | ≤ | f ′ L ( ξ ) | ⋅ | m ( [ y ] k ) − x * | ⋅ w ( 1 F ′ ( [ x ] k ) ) ≤ | f ′ L ( ξ ) | ⋅ w ( [ y ] k ) ⋅ w ( 1 F ′ ( [ x ] k ) ) ≤ | f ′ L ( ξ ) | ⋅ w ( N L ( [ x ] k ) ) ⋅ w ( 1 F ′ ( [ x ] k ) ) ≤ k 1 ⋅ | f ′ L ( ξ ) | ⋅ w ( 1 F ′ ( [ x ] k ) ) ⋅ w ( [ x ] k ) 2 其中 x * 为零解区间的一个端点。 因为 f ′ L 在区间 N L ( [ x ] k ) 上连续可微，所以存在 k 2 > 0 ，使得 | f ′ L ( ξ ) | ≤ k 2 。 由引理4.1可知，存在 k 3 > 0 ，使得 w ( 1 F ′ ( [ x ] k ) ) ≤ k 3 w ( [ x ] k ) 即存在 k 0 > 0 有 w ( P L ) ≤ k 1 k 2 k 3 w ( [ x ] k ) 3 ≤ 1 2 k 0 w ( [ x ] k ) 3 同理可以得到 w ( P U ) ≤ 1 2 k 0 w ( [ x ] k ) 3 所以 w ( [ x ] k + 1 ) ≤ w ( P L ∪ P U ) ≤ w ( P L ) + w ( P U ) ≤ k 0 w ( [ x ] k ) 3 上式表明拓展的二步区间牛顿在单调区间上至少具备三阶敛速，定理得证。 注：拓展的区间Ostrowski迭代和拓展的区间King迭代与拓展的区间二步牛顿迭代具有相同的收敛速度，证明方法相同，不再重复。 下面以EIN_Multi为例，给出求解含区间参数非线性方程零解区间的EIN_Multi算法，其中，S表示搜索区间(初始值为初始区间X 0 )，Z为零解区间(初始值为空集)，X为迭代过程中的搜索区间，K为迭代次数，B为搜索区间采用二分的次数。 注：第1步为初始化，第2~28步为函数主体，第二步判断搜索区间是否为空集，若非空则继续搜索，第4步判断区间宽度，若小于给定精度则归入Z (零解区间)，第7~9步计算P L 与P U ，形成虚拟的零解区间r (可能为空集)，若遇到特殊情况则将搜索区间采用二分法形成两个子区间，二分次数 相应增加一个单位，之后判断r是否为空，再将其传输到Z中，相应的将非空子区间X 1 与X 2 传输到S中，重复迭代，每迭代一次，K增加一个单位，直至所有零解区间传输到Z中。"
"本节通过对比文献 [ 7 ] 的12个带区间参数的非线性方程(见表1)来检验新算法的有效性，并给出了相应的函数图像(见图4)。计算精度 取为10 −14 ，其中SI为初始区间，IT为迭代次数，B为二分次数，T为程序运行时间，I为区间解个数。下面我们通过数值实例来比较原始的HIN算法与新提出三种改进算法的差别。 Table 1 函数编号 函数形式 1 x 3 + [ p ] 2 ⋅ x 2 + [ p ] 1 ⋅ x + [ p ] 0 , [ p ] 0 = [ 1 , 1.8907 ] , [ p ] 1 = [ 2.8749 , 4.2501 ] , [ p ] 2 = [ 1.2499 , 2.2501 ] 2 x 2 − [ p ] , [ p ] = [ − 2 , 2 ] 3 sin ( [ p ] 2 + 2 ⋅ x 2 ) e − [ p ] 2 − x 2 , [ p ] = [ − 0.5 , 0.5 ] 4 x 6 − p 5 ⋅ x 5 + p 4 ⋅ x 4 + [ p ] 3 ⋅ x 3 − p 2 ⋅ x 2 + [ p ] 1 ⋅ x + [ p ] 0 , [ p ] 0 = 16.1024 , [ p ] 1 = [ 15.8448 , 16.52 ] , p 2 = 7.872 , [ p ] 3 = [ − 4.0388 , − 3.875 ] , p 4 = 1.0256 , p 5 = 2 5 x 4 + [ p ] 1 3 ⋅ [ p ] 2 ⋅ x 3 + [ p ] 1 2 ⋅ [ p ] 2 2 ⋅ [ p ] 3 ⋅ x 2 + [ p ] 1 ⋅ [ p ] 2 3 ⋅ [ p ] 3 2 ⋅ x 2 + [ p ] 3 , [ p ] 1 = [ 1.15 , 1.65 ] , [ p ] 2 = [ 1.3 , 1.7 ] , [ p ] 3 = [ 0.6 , 1.0 ] 6 [ ( x + 10 ⋅ [ p ] 0 ) 2 − 5 ⋅ ( x − [ p ] 1 ) 2 − ( x − 2 [ p ] 2 ) 4 ] ⋅ e − x 2 + 2 , [ p ] 0 = [ − 1 , 0 ] , [ p ] 1 = [ 0 , 0.5 ] , [ p ] 2 = [ − 0.25 , 0.25 ] 7 y = ( 5 π ⋅ x − ( 5.1 4 ⋅ π 2 ) ⋅ x 2 + a − 6 ) 2 + 10 ⋅ 1 1 − 1 8 π ⋅ cos ( x ) , [ p ] = [ − 2 , 0 ] 8 ∑ j = 1 5 { j ⋅ sin ( ( j + 1 ) ⋅ [ p ] + j ) } ⋅ ∑ i = 1 5 { i ⋅ sin ( ( i + 1 ) ⋅ x + i ) } − 10 , [ p ] = [ − 0.1 , 0.2 ] 9 ∑ j = 1 5     j ⋅ [ sin ( ( j + 1 ) ⋅ x + j ) + x ⋅ sin ( ( j + 1 ) ⋅ [ p ] + j ) ] , p = [ − 0.1 , 0.2 ] 10 100 ⋅ ( [ p ] − x 2 ) 2 + ( x − 1 ) 2 , p = [ − 5 , 5 ] 11 ∑ i = 1 i ≠ 4 7 [ p ] i 2 4000 + x 2 4000 − ( ∏ i = 1 i ≠ 4 7 cos ( [ p ] i i ) + x 2 ) , [ p ] i = 1 , ⋯ , 7 = [ 1 , 2 ] 12 ∑ i = 1 8 { Y i ( 1 + 10 ⋅ Z i + 1 ) } + Y 9 ⋅ ( 1 + 10 ⋅ sin 2 ( π ⋅ x ) ) + Z 1 + ( x − 1 4 ) 2 − c , Y i = ( [ p ] i − 1 ) 2 , Z i = sin 2 ( π ⋅ [ p ] i ) , [ p ] i = 1 , ⋯ , 9 = [ 0.9 , 1.1 ] , c = 05341615278415 表1. 测试函数 图4. 测试函数图像 由于四种方法所求零解区间一致，数值结果表明四种方法确实有效地收敛到了零解区间，差异主要存在于迭代次数，程序运行时间，二分次数三个部分，下面我们仅展示EIN_Multi所得到的具体数值结果(见表2)，其余结果汇总至对比表(表3)。表3中T1表示EIN程序所运行的时间，T2表示EIN_Multi程序所运行的时间，T3表示EIN_Ostrowski程序所运行的时间，T4表示EIN_King程序所运行的时间;IT1表示EIN方法所用的迭代次数，IT2表示EIN_Multi方法所用的迭代次数，IT3表示EIN_Ostrowski方法所用的迭代次数，IT4表示EIN_King方法所用的迭代次数，B1，B2，B3，B4所对应的方法同上。 Table 2 NO. SI. IT. T. B. I. 零解区间 1 [ − 3 , 2 ] 36 0.274717 4 1 R = [ − 1.17326412409134 , − 0.24999180360996 ] 2 [ − 2 , 3 ] 11 0.04699 0 1 R = [ − 1.41421356237310 , 1.41421356237310 ] 3 [ − 2.5 , 2.5 ] 247 2.090558 8 9 R 1 = [ − 2.50000000000000 , − 2.48156912198301 ] R 2 = [ − 2.17080376367482 , − 2.14181908208529 ] R 3 = [ − 1.77245385090553 , − 1.73683408925256 ] R 4 = [ − 1.25331413731552 , − 1.20241271067587 ] R 5 = [ 1.20241271067587 , 1.25331413731552 ] R 6 = [ 1.73683408925256 , 1.77245385090553 ] R 7 = [ 2.14181908208529 , 2.17080376367482 ] R 8 = [ 2.48156912198301 , 2.50000000000000 ] R 9 = [ − 0.00000000000000 , 0.00000000000000 ] 4 [ − 1.5 , 2.5 ] 56 0.687295 6 1 R = [ − 1.09407604482697 , − 0.90864276306268 ] 5 [ − 10 , 5 ] 57 0.719202 2 1 R = [ − 7.59915460917110 , − 0.07454800183027 ] 6 [ − 2 , 2 ] 302 3.329902 0 2 R 1 = [ − 1.25104523267424 , − 0.11197875777009 ] R 2 = [ 0.48452219866311 , 1.19533443162485 ] 7 [ 1 , 11 ] 41 0.322251 1 2 R 1 = [ 2.52814125034009 , 4.48890951702297 ] R 2 = [ 8.12229473437508 , 9.90982400896169 ] 8 [ − 2.5 , 2.5 ] 224 3.649435 0 7 R 1 = [ − 2.46715298055336 , − 2.08746025441081 ] R 2 = [ − 1.95892289962050 , − 1.51934276869069 ] R 3 = [ − 1.43694943975762 , − 0.80225735033705 ] R 4 = [ − 0.72978696702962 , − 0.22574758594195 ] R 5 = [ − 0.12074796475217 , 0.31358054472210 ] R 6 = [ 0.87171438824452 , 1.28070410572677 ] R 7 = [ 1.85830151425555 , 2.24466631398474 ] 9 [ − 2.5 , 2.5 ] 112 2.569604 0 6 R 1 = [ − 2.50000000000000 , − 1.92087574283388 ] R 2 = [ − 1.52723438255972 , − 1.25833986275812 ] R 3 = [ − 0.91204299203149 , − 0.75571311847233 ] R 4 = [ − 0.15616336985750 , − 0.12081187930700 ] R 5 = [ 0.32172903378594 , 0.95147407919507 ] R 6 = [ 1.15013654741199 , 2.50000000000000 ] 10 [ − 5 , 5 ] 99 0.430902 0 1 R = [ 0.99999999999998 , 1.00000000000001 ] 11 [ − 20 , 20 ] 5 0.072306 0 1 R = [ − 0.52631341531172 , 0.41987789619851 ] 12 [ − 3 , 4 ] 47 0.788452 0 2 R 1 = [ − 1.92345419759984 , − 1.06926475849962 ] R 2 = [ 3.06926475849960 , 3.92345419759984 ] 表2. EIN_Multi得出的数值结果 Table 3 NO. T1. T2. T3. T4. IT1. IT2. IT3. IT4. B1 B2 B3 B4. 1 0.846536 0.274717 0.288354 0.363102 143 36 33 37 51 4 4 4 2 0.083297 0.04699 0.050179 0.051712 26 11 11 11 7 0 0 0 3 3.993194 2.090558 1.377687 1.624863 675 247 173 185 242 8 8 8 4 3.533208 0.687295 0.798292 0.853034 356 56 57 57 153 6 6 6 5 1.273925 0.719202 0.6883 0.645072 125 57 51 48 29 2 2 2 6 3.309211 3.329902 3.353682 3.34104 302 302 302 302 0 0 0 0 7 1.133234 0.322251 0.376305 0.402133 213 41 41 40 80 1 1 1 8 3.65481 3.649435 3.631559 3.6014 224 224 224 224 0 0 0 0 9 8.799273 2.569604 3.054859 3.61761 585 112 109 111 230 0 0 0 10 0.42601 0.430902 0.424643 0.42413 99 99 99 99 0 0 0 0 11 0.118825 0.072306 0.089766 0.10952 13 5 5 5 3 0 0 0 12 2.984364 0.788452 1.086119 1.878941 284 47 52 67 122 0 0 0 表3. 四种方法关键数据对比表 由上述对比可知在12个算例中，9个算例的收敛速度都有明显提升，对于大部分函数基于普通的二步迭代、区间Ostrowski以及区间king迭代改进的EIN相较于原有的EIN而言迭代次数以及二分步数显著减少，由于单调区间并不是贯穿整个初始区间，收敛速度在二阶与三阶之间，若求解单调函数的零解区间，则收敛速度可达三阶！第6、8、10个函数上的时间相差较小，这是由于非单调区间过多，迭代次数几乎不变，时间几乎相等。综上所述，改进的三种方法对于大多数函数都明显加快了收敛，收敛阶由二阶最高可提升至三阶速度。"
"本文提出了以多步区间迭代法为基础的HIN加速算法，在理论上证明了改进的新算法相比于HIN算法具有高一阶的收敛速度，并通过几个典型的数值算例对改进算法的性能进行了测试，数值结果表明新的算法具有较好的稳健性，这为求解各种不定参数非线性方程的工程问题提供了一种更为完善的解决办法。如何对以区间牛顿算子为基础的其他区间算法进行有效加速改进，还需要进一步的研究与探索。"
