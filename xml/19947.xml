<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2017.73023</article-id><article-id pub-id-type="publisher-id">CSA-19947</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20170300000_78963538.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  云存储中基于可信硬件的数据存储位置保障方法研究
  Research on Using Trusted Hardware for Data Location Assurance in Cloud Storage
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>王</surname><given-names>冠</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>许</surname><given-names>瑞雪</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><addr-line>北京工业大学，北京</addr-line></aff><aff id="aff2"><addr-line>null</addr-line></aff><author-notes><corresp id="cor1">* E-mail:<email>timelysnow@emails.bjut.edu.cn(王冠)</email>;</corresp></author-notes><pub-date pub-type="epub"><day>23</day><month>03</month><year>2017</year></pub-date><volume>07</volume><issue>03</issue><fpage>183</fpage><lpage>191</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   在云存储中，一些处理敏感数据(如政府文件、资产数据、健康数据等)的用户需要限制数据存储的地理位置，而目前大多数云存储供应商并没有向用户提供验证数据存储位置的方法。针对这个问题，采用可信硬件来标识物理机器并利用可信第三方来验证数据实际存储位置。此外，还可以验证云存储供应商提供的物理机器的可信性。分析结果表明，本文提出的方法具有很高的安全性，通过采用TCM芯片及额外的位置审计，能够可靠地验证数据存储的实际位置。 Recently, the lack of geo-location assurance of data stored in cloud storage has become a main reason which restricts organizations that deal with sensitive data (e.g., financial data, health data) to adopt cloud storage. This paper proposed a mechanism for verifying the geographic location of the stored data. We use Trusted Cryptographic Module (TCM) to identify physical machines and use a trusted third party to verify the actual location. In addition, our approach enables the verification of the trustworthiness of the physical machines which the cloud storage operators provide. The discussion shows that the approach of this paper has an adequate level of security, and by the usage of TCM and additional location audits, can enable a reliable location verification of the stored data. 
    
  
 
</p></abstract><kwd-group><kwd>云存储安全，可信计算，数据存储位置，可信密码模块, Cloud Storage Security</kwd><kwd> Trusted Computing</kwd><kwd> Data Geo-Location</kwd><kwd> TCM</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>云存储中基于可信硬件的数据存储位置 保障方法研究<sup> </sup></title><p>王冠，许瑞雪</p><p>北京工业大学，北京</p><p>收稿日期：2017年3月3日；录用日期：2017年3月20日；发布日期：2017年3月23日</p><disp-formula id="hanspub.19947-formula1"><graphic xlink:href="http://html.hanspub.org/file/1-1540725x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>在云存储中，一些处理敏感数据(如政府文件、资产数据、健康数据等)的用户需要限制数据存储的地理位置，而目前大多数云存储供应商并没有向用户提供验证数据存储位置的方法。针对这个问题，采用可信硬件来标识物理机器并利用可信第三方来验证数据实际存储位置。此外，还可以验证云存储供应商提供的物理机器的可信性。分析结果表明，本文提出的方法具有很高的安全性，通过采用TCM芯片及额外的位置审计，能够可靠地验证数据存储的实际位置。</p><p>关键词 :云存储安全，可信计算，数据存储位置，可信密码模块</p><disp-formula id="hanspub.19947-formula2"><graphic xlink:href="http://html.hanspub.org/file/1-1540725x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2017 by authors and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="http://image.hanspub.org:8080\Html/htmlimages\1-2890033x\e70a10f1-7c93-45ea-9603-062237856e4b.png" /><img src="http://image.hanspub.org:8080\Html\htmlimages\1-2890033x\e898c85e-ffc4-45c9-b817-14224a4d6960.png" /></p></sec><sec id="s3"><title>1. 背景</title><p>基于云的存储服务越来越流行，用户可以采用云存储服务远程备份自己的数据、从任何连接设备上访问数据并且能够通过访问共享数据与其他用户合作。例如，Amazon S3和Google Storage可以为用户、企业和其他云存储服务供应商提供可扩展的存储服务。Dropbox，Apple iCloud和Google Drive可以在多用户和多设备的环境下为用户提供文件共享和文件同步服务 [<xref ref-type="bibr" rid="hanspub.19947-ref1">1</xref>] 。云存储服务使用户在较低成本下便利地存储和访问数据，并且减轻了用户维护巨大的本地数据存储的成本。</p><p>除了云存储服务的安全和隐私问题，一些处理敏感数据(如财务数据、健康数据以及个人身份数据)的用户对数据存储的地理位置有要求，如何对要存储的数据提供有效的地理位置保障和检测机制，也成为云存储供应商和用户面临的一个比较重要的问题。</p><p>目前，一些云存储服务提供商(如Amazon S3)允许用户在服务协定中选择数据存储的地理位置，但是作为用户，并没有途径去检测提供商是否履行了协议，而当你发现他们违反协定时(无意地或偶然地)，损害却已经造成了。近年来，发生了几起出租的商业服务中断运行的情况，导致用户在相当长的一段时间无法访问自己的数据。例如，2012年12月24日，部署在AWS上的Netflix服务，对用户中断服务长达12小时 [<xref ref-type="bibr" rid="hanspub.19947-ref2">2</xref>] 。类似的情况还在Dropbox用户 [<xref ref-type="bibr" rid="hanspub.19947-ref2">2</xref>] [<xref ref-type="bibr" rid="hanspub.19947-ref3">3</xref>] 以及Xbox用户中也发生过 [<xref ref-type="bibr" rid="hanspub.19947-ref3">3</xref>] 。为了解决这个问题，云存储服务商可能会把这些数据转移到其他地方，那么如何确定云存储服务商是否遵守了服务协议中的位置条款就成了用户关心的一个重要问题。并且，为了提高数据的可用性，一些云存储提供商可能在多个数据中心存储数据的复制版本，比如Microsoft Azure，这使情况变得更糟，用户需要能够验证云存储中数据的实际存储位置的要求就更加强烈。</p><p>目前，也已经有一些研究者提出采用可信硬件来保障虚拟资源(数据或者程序)的存放位置。NIST做了第一个尝试 [<xref ref-type="bibr" rid="hanspub.19947-ref4">4</xref>] ，他们提出了将服务器的地理位置信息写入可信平台模块TPM (Trusted Platform Module)的PCR中并提出了一个应用原型，当服务器收到存储请求后，它首先检查它的位置请求，然后根据自身的位置决策返回响应，但是此方案仅适用于云存储服务商内部使用，并不对用户提供位置保障和检测机制。Hsin-Jung Yang等人基于TPM提出了通过验证虚拟资源(数据或程序)的位置信息来提供一个可信授权机制 [<xref ref-type="bibr" rid="hanspub.19947-ref5">5</xref>] 。Ali Noman等人采用TPM与数据持有性证明协议PDP (Provable Data Possession)设计了一个可供用户验证的保障数据存储位置的方法 [<xref ref-type="bibr" rid="hanspub.19947-ref6">6</xref>] 。</p><p>本文提出一个检测数据存储地理位置的方法，防止云存储供应商在用户不知情的情况下将数据移动到用户不愿存储的地方。本文将绑定在云存储设施中物理机器上的可信硬件作为唯一身份识别符，每一个物理机器都含有唯一的可信硬件。可信硬件的地理位置由可信第三方来保证。用户可以利用可信硬件可靠地定位他们的数据存储位置并且验证他们正在使用的云存储设施的可信性，检测是否存在云存储提供商或者其他人的恶意操作。</p><p>本文的组织结构如下：第一部分介绍了本文的研究背景；第二部分介绍了可信密码模块相关研究；第三部分介绍了基于可信硬件的数据存储位置验证方法；第四部分分析了方法的安全性；第五部分对本文的研究做出了总结。</p></sec><sec id="s4"><title>2. 可信密码模块TCM</title><p>硬件系统的安全和操作系统的安全是信息系统安全的基础，密码、网络安全等技术是关键技术。只有从信息系统硬件和软件的底层采取安全措施，才能有效地保障信息系统的安全，这促进了可信计算的迅速发展。</p><p>为了解决个人计算机结构上的安全问题，并从底层入手提高其可信性，Intel、Microsoft、IBM、HP、Compaq等著名的信息技术企业在1999年10月共同发起并成立了可信计算平台联盟(Trusted Computing Platform Alliance, TCPA)。TCPA定义了具有安全存储和密码功能的可信平台模块(Trusted Platform Module, TPM)，并于2001年1月发布了基于硬件系统的“可信计算平台规范”(V1.0)。TCPA的成立标志着可信计算高潮阶段的出现。2003年3月，TCPA更名为可信计算组织(Trusted Computing Group, TCG) [<xref ref-type="bibr" rid="hanspub.19947-ref7">7</xref>] ，其目的是在计算和通信系统中广泛使用基于硬件安全模块的可信计算平台，以提高整体的安全性，扩展可信范围。</p><p>可信计算的基本思想是在计算机系统中首先建立一个信任根，再建立一条信任链，从信任根到硬件平台到操作系统再到应用，一级测量认证一级，一级信任一级，把信任关系扩大到整个计算机系统，从而确保计算机系统的可信。</p><p>可信密码模块(Trusted Cryptography Module, TCM)是我国借鉴国际可信计算框架与技术理念，结合我们信息安全管理国情，在可信计算领域自主研制的安全芯片。可信密码模块的主要核心功能是提供基于硬件的国产密码算法和密钥保护；唯一地标识平台身份；度量平台完整性。</p><p>TCM芯片 [<xref ref-type="bibr" rid="hanspub.19947-ref8">8</xref>] 可以为加密密钥提供安全存储并且为随机数发生器、密钥发生器、哈希计算提供硬件加速计算引擎。TCM提供的密钥类型包括采用SM2-3和SMS4算法的存储密钥、采用SM2-3和SMS4算法的绑定密钥、采用SM2-1算法的签名密钥、采用SM2-1算法的身份密钥和采用SM2-3算法的平台加密密钥。</p><p>当一个用户第一次激活一个平台时，TCM使用TCM_TakeOwnership命令进行初始化，此时访问TCM的用户密码被设置。这个过程不能远程执行，并且一个新的初始化需要TCM的实体存在以及一系列的重置命令。</p><p>每个TCM拥有唯一的背书密钥(Endorsement Key, EK)，TCM出厂时都会由TCM厂商签发背书证书来唯一标识可信平台的身份。EK的私钥部分EK<sub>priv</sub>受TCM保护，永久存储在TCM内部。由于安全与隐私问题，EK<sub>priv</sub>不能用于签名操作，它只能被用来解密用EK<sub>pub</sub>加密过的敏感数据。背书证书(Endorsement Credentials, EC)包含EK<sub>pub</sub>，TCM厂商使用私钥对背书证书进行签名，以便于验证TCM和EK的有效性。</p><p>除了背书证书，TCM还含有一致性证书(Conformance Credentials，CC)和平台证书(Platform Credential, PC)来证明TCM的组件符合《可信密码模块规范》的要求。一致性证书由评估机构(如平台制造商、供应商或者独立实验室)颁发，确保可信构造基(Trusted Building Blocks, TBB)与TCM说明相一致。平台一致性证书由平台制造商、供应商或者其他独立实体颁发，保证平台包含背书证书中的TCM芯片。</p><p>平台身份密钥(Platform Identity Key, PIK)用于对完整性值和其他密钥的数字签名。平台身份密钥是一个SM2密钥对，必须在所有者授权的情况下才能够生成。TCM采用TCM_MakeIdentity命令生成PIK。平台身份证书(Platform Identity Credential, PIC)用来证明此PIK与有效的背书证书、平台证书以及一致性证书绑定。PIK证书的构建需要认证机构(Certification authority, CA)的参与。</p><p>CA是证书的签发机构，它是公钥基础设施的核心。证书是公钥体制的一种密钥管理媒介。它是一种权威的电子文档，形同网络计算环境中的一种身份证，用于证明某一主体的身份及其公开密钥的合法性。因此，公钥体制环境必须有一个可信的机构CA来对任何一个个体的公钥进行公证，证明主体的身份及它与公钥的匹配关系。</p><p>TCM向CA发送一个包含PIK<sub>pub</sub>、背书证书EC、一致性证书CC、平台证书PC的请求，并使用PIK<sub>priv</sub>对请求进行签名。如果证书是有效的，CA产生平台身份证书，使用背书证书中的EK<sub>pub</sub>加密PIC，将其发送回TCM。</p><p>由于密钥的数量可能非常庞大，而TCM内部的存储空间有限，那么一些密钥(如PIK)，可以选择存储在外部如硬盘上。每一个存储在外部的密钥都需要被存储根密钥(Storage Root Key, SRK)加密。SRK是一个不可迁移密钥对，它建立了密钥存储的可信根。SRK以非易失的方式存储在TCM内部，并且永远不在TCM外部使用。当一个新用户被授权时，SRK可以被重置。</p><p>为了安全存储度量结果，TCM在内部开辟了专门的完整性值存储空间—平台配置寄存器(Platform Configuration Registers, PCRs)。平台启动时，PCR值会被重置为默认值。平台启动之后，以扩展的方式更改PCR值。软件组件(BIOS，bootloader，操作系统，应用程序)在执行前被度量，通过扩展之前的哈希值得到新的哈希值被写入到特定的PCR中：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x9_hanspub.png" xlink:type="simple"/></inline-formula>。SHA1代表TCM使用的哈希密码函数，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x10_hanspub.png" xlink:type="simple"/></inline-formula>代表连接操作。这条信任链的信任根是可信度量根(Core Root of Trust Measurement, CRTM)，它在BIOS中，并且在平台加电时被第一个执行。接着，CRTM度量它自身以及BIOS，然后将控制权交给信任链中的下一个软件组件。对每一个被度量的组件，一个事件被创建并存储在存储度量日志(Stored Measurement Log, SML)中。这样，采用 [<xref ref-type="bibr" rid="hanspub.19947-ref9">9</xref>] 中提出的完整性度量框架(Integrity Measurement Architecture, IMA)，一个远程实体就可以通过PCR和SML来证明平台状态。为开始一个证明，挑战者创建一个随机数并发送给证明系统，证明系统的TCM使用PIK对随机数和PCR签名并将此签名、随机数以及SML发送回挑战者。挑战者检验签名与SML中对应的值是否一致来判断系统的完整性。</p></sec><sec id="s5"><title>3. 基于TCM的数据存储位置保障方法</title><p>本文采用物理机器中的TCM芯片作为验证数据存储位置的可信根。绑定有地理位置信息的TCM芯片在认证机构(Certification Authority, CA)中注册。用户运行虚拟机中的客户端软件来初始化一个证明协议，通过这个协议清楚地识别TCM的身份并且在CA的协助下验证位置。此外，此证明协议可以保证虚拟机上运行的软件组件(BIOS、bootloader、hypervisor等)没有受到任何损害。</p><sec id="s5_1"><title>3.1. 整体框架</title><p>图1展示了基于TCM的数据存储位置保障整体框架。虚拟机VM<sub>1</sub>运行在云存储提供商提供的位于某个特定地理位置的一台机器上，此台机器含有TCM芯片并安装了云存储服务。某用户的数据通过使用云存储服务存储在 上。虚拟机监视器运行在硬件之上并负责执行所有的虚拟机。LICT模块提供了位置验证、完整性检查以及TCM驱动的功能。LICT位于虚拟机监视器中，它管理位置验证请求对TCM的访问并实现上文中提出的IMA的必要部分，来保证虚拟机监视器以及LICT模块没有受到损害。运行在虚拟机监视器上的所有虚拟机通过LICT模块访问TCM芯片。虚拟机中的LocCheck模块通过LICT</p><p>图1. 整体框架</p><p>模块获取TCM身份。绑定物理机器位置信息的TCM芯片在CA中注册。我们假设可信服务提供商或者CA执行定期系统检查来验证物理机器的位置。例如，依据标准ISO/IEC 27001，位置验证是一个需要定期执行的安全审计。简单起见，我们还需假设CA维护了一个IMA要求的可信软件组件的指纹数据库。可以通过与CA通信来验证TCM以及机器的地理位置。在本文中，我们还假定用户、云存储提供商以及CA之间的通信是安全的。</p></sec><sec id="s5_2"><title>3.2. 详细设计</title><p>本文的原型分为两个部分：初始化阶段和验证阶段。初始化阶段只执行一次，当云存储提供商提供一个新的绑定有TCM芯片的机器，并将此机器以及其位置信息在CA中注册时，执行初始化协议。平台身份证书在此阶段生成。在初始化阶段，CA通过证明协议验证机器的可信性。当CA验证了机器位置信息的正确性并且系统是可信的，此机器的用户就可以通过执行验证阶段来验证位置了。</p><p>初始化阶段：当云存储供应商提供一台新的机器M时，需执行下面几步进行初始化，如表1所示。</p><p>首先，LICT模块执行TCM_TakeOwnership命令来初始化TCM，设置访问TCM的用户密码，并将此密码存储在LICT模块中。然后，执行TCM_MakeIdentity命令使TCM生成PIK密钥对(PIK<sub>priv</sub>, PIK<sub>pub</sub>)。每一个这样的SM2密钥对都与一个健柄h<sub>PIK</sub>绑定，因为在一个TCM内部可以生成多个不同的PIK。在生成PIK的同时，用来访问EK<sub>priv</sub>的密码pass<sub>PIK</sub>也被设置。</p><p>TCM生成一个PIK请求(PIK-Request, PR)并使用PIK<sub>priv</sub>对PR进行签名，此请求包含PIK<sub>pub</sub>，背书证书EC，平台证书PC，一致性证书CC。TCM使用PIK<sub>priv</sub>对PR进行签名并将此签名与PR发送到LICT模块，由LICT模块发送到CA。由于背书证书包含背书公钥EK<sub>pub</sub>，PIK密钥对唯一地绑定到特定TCM，因此，LICT模块存储访问TCM的用户密码、h<sub>PIK</sub>、pass<sub>PIK</sub>、PIK<sub>pub</sub>以及所有的证书，以便使用。</p><p>收到消息之后，CA验证证书和签名的有效性。若验证通过，CA生成一个平台身份证书(Platform IdentityCredential, PIC)并且使用CA的私钥对PIK<sub>pub</sub>签名。采用对称加密方案Sym_Enc用生成的会话密钥K对PIC加密。会话密钥K本身采用SM2算法用EK<sub>pub</sub>加密后与PIC一起被发送到LICT模块。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Initialization phase step</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >步骤</th><th align="center" valign="middle" >执行模块</th><th align="center" valign="middle" >命令</th></tr></thead><tr><td align="center" valign="middle" >1a.</td><td align="center" valign="middle" >LICT→TCM:</td><td align="center" valign="middle" >TCM_TakeOwnership</td></tr><tr><td align="center" valign="middle" >1b.</td><td align="center" valign="middle" >LICT→TCM:</td><td align="center" valign="middle" >TCM_MakeIdentity</td></tr><tr><td align="center" valign="middle" >1c.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >Generate (PIK<sub>priv</sub>, PIK<sub>pub</sub>)</td></tr><tr><td align="center" valign="middle" >1d.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >PR = PIK<sub>pub</sub>, EC, PC, CC</td></tr><tr><td align="center" valign="middle" >1d.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >SM2_Sign (PR|PIK<sub>priv</sub>) = Sig</td></tr><tr><td align="center" valign="middle" >2.</td><td align="center" valign="middle" >LICT→CA:</td><td align="center" valign="middle" >PR, Sig</td></tr><tr><td align="center" valign="middle" >3a.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify Credentials</td></tr><tr><td align="center" valign="middle" >3b.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify SM2_Verify(Sig|EK<sub>pub</sub>) = PR</td></tr><tr><td align="center" valign="middle" >3c.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Generate PIC</td></tr><tr><td align="center" valign="middle" >3d.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Generate K</td></tr><tr><td align="center" valign="middle" >3e.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >SM2_Enc(K|EK<sub>pub</sub>)</td></tr><tr><td align="center" valign="middle" >3f.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Sym_Enc(PIC|K)</td></tr><tr><td align="center" valign="middle" >4.</td><td align="center" valign="middle" >CA→LICT:</td><td align="center" valign="middle" >SM2(K|EK<sub>pub</sub>), Enc(PIC|K)</td></tr><tr><td align="center" valign="middle" >5a.</td><td align="center" valign="middle" >LICT→TCM:</td><td align="center" valign="middle" >TCM_ActivateIdentity</td></tr><tr><td align="center" valign="middle" >5b.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >Decrypt K</td></tr><tr><td align="center" valign="middle" >5c.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >Decrypt PIC</td></tr><tr><td align="center" valign="middle" >6a.</td><td align="center" valign="middle" >LICT→TCM:</td><td align="center" valign="middle" >TCM_Quote(h<sub>PIK</sub>, pass<sub>PIK</sub>, loc<sub>M</sub>, S<sub>PCR</sub>)</td></tr><tr><td align="center" valign="middle" >6b.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >SM2_Sign(loc<sub>M</sub>, S<sub>PCR</sub>|PIK<sub>priv</sub>) = SigL</td></tr><tr><td align="center" valign="middle" >6c.</td><td align="center" valign="middle" >LICT→CA:</td><td align="center" valign="middle" >loc<sub>M</sub>, PCR[S<sub>PCR</sub>], SML, SigL</td></tr><tr><td align="center" valign="middle" >7a.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify SigL</td></tr><tr><td align="center" valign="middle" >7b.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify platform integrity</td></tr><tr><td align="center" valign="middle" >7c.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify loc<sub>M</sub></td></tr><tr><td align="center" valign="middle" >7d.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Mark loc<sub>M</sub> of M as verified</td></tr></tbody></table></table-wrap><p>表1. 初始化阶段步骤</p><p>LICT模块调用TCM_ActivateIdentity命令使用EK<sub>priv</sub>解密会话密钥K。这个操作保证了在后续步骤中只有TCM可以解密PIC。</p><p>此时，LICT模块开始在CA注册物理机器M的地理位置loc<sub>M</sub>。如上文3.1中所说，我们将位置注册与平台完整性验证、CA验证机器M没有收到任何损害，BIOS、Bootloader、Hypervisor、LICT模块是可信的结合起来。TCM激活TCM_Quote命令，使用PIK<sub>priv</sub>对loc<sub>M</sub>以及相应的用于启动过程完整性验证的PCR值S<sub>PCR</sub>进行签名。参数h<sub>PIK</sub>用来指定正确的PIK，pass<sub>PIK</sub>用来获取此PIK密钥的使用权。发送到CA的消息包括位置loc<sub>M</sub>、设置的PCR的值PCR[S<sub>PCR</sub>]、存储度量日志SML以及签名SigL。</p><p>当CA收到消息之后，它首先使用PIK<sub>pub</sub>验证签名的有效性。然后比较PCR值与SML的一致性来验证平台可信性。当位置信息被某外部机构(任何形式的审计)验证之后，CA认为这台机器(包括它所绑定的TCM)及其位置是可信的。</p><p>当初始化阶段结束之后，绑定到云存储供应商提供的机器上的TCM的身份标识密钥PIK以及它目前的位置就成功在CA中注册了并可以被下文的验证阶段所使用。</p><p>验证阶段：验证阶段的协议步骤如表2所示。</p><p>当用户U想要验证他的数据存储实际位置是否与供应商声称的位置信息一致时，用户向存储数据的虚拟机VM<sub>1</sub>发出验证请求。位于虚拟机VM<sub>1</sub>中的LocCheck模块选择几块随机的内存区域<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x12_hanspub.png" xlink:type="simple"/></inline-formula>，并将指针MA指向此内存区域。将这些随机内存区域应用在验证阶段，可防止供应商的重放攻击。</p><p>接下来，LocCheck模块向LICT模块请求TCM的身份标识公钥PIK<sub>pub</sub>并将PIK<sub>pub</sub>以及内存区域的哈希<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x13_hanspub.png" xlink:type="simple"/></inline-formula>发送到CA来请求确认位置。其中，PIK<sub>pub</sub>用来标识TCM身份。</p><p>当CA接收到PIK<sub>pub</sub>后，从数据库中查找验证机器M平台完整性的PCR值并将S<sub>PCR</sub>返回LocCheck模块。LocCheck模块将S<sub>PCR</sub>以及内存区域指针MA发送到LICT模块。</p><p>LICT模块计算<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x14_hanspub.png" xlink:type="simple"/></inline-formula>并请求TCM使用TCM_Quote命令用PIK<sub>priv</sub>对 和S<sub>PCR</sub>签名。同样，参数h<sub>PIK</sub>用来指定正确的PIK，pass<sub>PIK</sub>用来获取此PIK密钥的使用权。TCM将签名SigMA、PCR值PCR[S<sub>PCR</sub>]发送到CA。</p><p>CA验证签名的有效性、平台完整性、验证的loc<sub>M</sub>与注册的一致性以及LocCheck模块计算出的所选内存区块的哈希与LICT模块签名的一致性。如果所有的验证均通过，CA使用自身的私钥对loc<sub>M</sub>的确认信息进行签名并将其发送到LocCheck模块，由LocCheck模块将此信息发送给用户。最后，用户使用CA</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Validation phase ste</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >步骤</th><th align="center" valign="middle" >执行模块</th><th align="center" valign="middle" >命令</th></tr></thead><tr><td align="center" valign="middle" >0.</td><td align="center" valign="middle" >User→LocCheck:</td><td align="center" valign="middle" >Memory areas MA</td></tr><tr><td align="center" valign="middle" >1a.</td><td align="center" valign="middle" >LocCheck→LICT:</td><td align="center" valign="middle" >Request PIK</td></tr><tr><td align="center" valign="middle" >1b.</td><td align="center" valign="middle" >LICT→LocCheck:</td><td align="center" valign="middle" >PIK<sub>pub</sub></td></tr><tr><td align="center" valign="middle" >1c.</td><td align="center" valign="middle" >LocCheck</td><td align="center" valign="middle" >Generate hash (MA)</td></tr><tr><td align="center" valign="middle" >1d.</td><td align="center" valign="middle" >LocCheck→CA:</td><td align="center" valign="middle" >Hash (MA), PIK<sub>pub</sub></td></tr><tr><td align="center" valign="middle" >2a.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Select S<sub>PCR</sub></td></tr><tr><td align="center" valign="middle" >2b.</td><td align="center" valign="middle" >CA→LocCheck:</td><td align="center" valign="middle" >S<sub>PCR</sub></td></tr><tr><td align="center" valign="middle" >2c.</td><td align="center" valign="middle" >LocCheck→LICT:</td><td align="center" valign="middle" >MA, S<sub>PCR</sub></td></tr><tr><td align="center" valign="middle" >3a.</td><td align="center" valign="middle" >LICT</td><td align="center" valign="middle" >Generate hash (MA)</td></tr><tr><td align="center" valign="middle" >3a.</td><td align="center" valign="middle" >LICT→TCM:</td><td align="center" valign="middle" >TCM_Quote(h<sub>PIK</sub>, pass<sub>PIK</sub>, hash(MA), S<sub>PCR</sub>)</td></tr><tr><td align="center" valign="middle" >3b.</td><td align="center" valign="middle" >TCM</td><td align="center" valign="middle" >SM2(hash(MA), S<sub>PCR</sub>|PIK<sub>priv</sub>) = SigMA</td></tr><tr><td align="center" valign="middle" >3c.</td><td align="center" valign="middle" >TCM→LICT</td><td align="center" valign="middle" >PCR[S<sub>PCR</sub>]</td></tr><tr><td align="center" valign="middle" >4a.</td><td align="center" valign="middle" >LICT→LocCheck:</td><td align="center" valign="middle" >PCR[S<sub>PCR</sub>], SML, SigMA</td></tr><tr><td align="center" valign="middle" >4b.</td><td align="center" valign="middle" >LocCheck→CA:</td><td align="center" valign="middle" >PCR[S<sub>PCR</sub>], SML, SigMA</td></tr><tr><td align="center" valign="middle" >5a.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify SigMA</td></tr><tr><td align="center" valign="middle" >5b.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify platform integrity</td></tr><tr><td align="center" valign="middle" >5c.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify loc<sub>M</sub> marked as verified</td></tr><tr><td align="center" valign="middle" >5d.</td><td align="center" valign="middle" >CA</td><td align="center" valign="middle" >Verify hash(MA)</td></tr><tr><td align="center" valign="middle" >6a.</td><td align="center" valign="middle" >CA→LocCheck:</td><td align="center" valign="middle" >Location loc<sub>M</sub> confirmed</td></tr><tr><td align="center" valign="middle" >6b.</td><td align="center" valign="middle" >LocCheck→User:</td><td align="center" valign="middle" >Location loc<sub>M</sub> confirmed</td></tr></tbody></table></table-wrap><p>表2. 验证阶段步骤</p><p>的公钥验证确认信息的签名并验证位置loc<sub>M</sub>是否正确。</p></sec></sec><sec id="s6"><title>4. 安全性分析</title><p>本节主要分析上文提出的原型的安全性。我们假设云存储提供商试图将用户的数据移动到更便宜的地方来节约成本。</p><p>对我们的原型而言，我们假设TCM的位置是被检测过的并且它们的实际位置与它们在CA中注册的位置一致。我们假设敌手无法破坏TCM的抗损坏机制来读取密钥或者损坏任何密码机制，例如，敌手无法在不知道私钥的情况下伪造签名或者破解哈希函数。</p><p>对本文而言，敌手可以采用两个方法攻击我们的原型：伪造机器位置或者进行重放攻击。</p><p>对于第一种情况，敌手试图伪造机器位置来满足用户要求。由于初始化阶段是在审计期间被验证的，敌手只能在验证阶段进行攻击。敌手需要通过步骤5a到5d (表2)的验证，直接访问安全存储在TCM中的PIK<sub>priv</sub>来产生签名SigMA。为了获得PIK<sub>priv</sub>，敌手必须破坏TCM的抗损坏机制，这与上文的假设相冲突。或者，敌手可以将绑定到某机器上的TCM芯片移动到其他位置的机器上。然而，这会在下一次审计的最后一步被检测出来。所以，审计操作需要以一个合理的频率定期执行，这样，敌手这种卸载、转移、重装TCM芯片的经济成本就会很大。</p><p>对于第二种情况，敌手需要两台机器来执行一个重放攻击。机器M<sub>A</sub>对于用户的要求而言，位于一个正确的位置，没有被修改过并且正确运行。这台机器同时运行着恶意供应商的虚拟机VM<sub>x</sub>。敌手的另外一台机器M<sub>B</sub>位于一个不符合用户要求的位置。在M<sub>B</sub>上，虚拟机监视器以及LICT<sub>B</sub>被修改，被修改过的模块将消息传送到机器M<sub>A</sub>上的虚拟机VM<sub>x</sub>中的修改过的LocCheck<sub>x</sub>模块。基于这种方式，敌手可以将虚拟机VM<sub>1</sub>从M<sub>A</sub>移动到M<sub>B</sub>上并且可以转发所有的协议消息，验证依然会通过。为了解决这个问题，我们通过扩展对虚拟机VM<sub>1</sub>的验证将基于软件的证明应用到我们的协议原型中。绑定在机器上的TCM对特定虚拟机的内存区块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-1540725x15_hanspub.png" xlink:type="simple"/></inline-formula>的哈希值产生签名SigMA。为了通过机器M<sub>A</sub>的验证，敌手的虚拟机VM<sub>x</sub>必须与运行在机器M<sub>B</sub>上的虚拟机VM<sub>1</sub>完全相同。这样，敌手的重放攻击就不存在任何意义了，因为他必须在机器M<sub>A</sub>上保存一个VM<sub>1</sub>的副本，也就是浪费了机器M<sub>B</sub>上一倍的存储空间。</p><p>远程证明中存在的一个普遍的问题是，在验证和使用的间隙，敌手可能会改变机器的状态。所以，我们建议有规律地进行重复验证。</p></sec><sec id="s7"><title>5. 总结</title><p>随着云存储的应用越来越广泛，云存储中的数据安全问题也越来越重要。用户可能需要自定义安全策略来保障自身数据安全，其中一个重要的方面便是数据存储和处理的地理位置，例如，有些用户要求数据存储在国内而不能存储到国外的服务器上。本文提出的方法基于可信密码模块及可信第三方使用户能够验证数据存储的实际位置以及云存储供应商提供的机器的可信性。我们提出的证明协议能够验证云存储供应商提供的机器的平台配置的完整性，并且能够唯一地标识绑定在机器上的TCM的身份。TCM的实际位置以及用于检测云存储供应商提供的机器平台完整性的数据存储在可信第三方上。数据的实际存储位置以及平台完整性可以通过与第三方通信来证明。本文的安全性分析说明了我们的原型具有很高的安全性。与前人的研究相比，我们的方法通过采用TCM芯片及额外的位置审计，能够可靠地验证数据存储的实际位置。</p></sec><sec id="s8"><title>文章引用</title><p>王 冠,许瑞雪. 云存储中基于可信硬件的数据存储位置保障方法研究 Research on Using Trusted Hardware for Data Location Assurance in Cloud Storage[J]. 计算机科学与应用, 2017, 07(03): 183-191. http://dx.doi.org/10.12677/CSA.2017.73023</p></sec><sec id="s9"><title>参考文献 (References)</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.19947-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Tate, S.R. and Vishwanathan, R. (2013) Multi-User Dynamic Proofs of Data Possession Using Trusted Hardware. ACM, San Antonio, 353-364.</mixed-citation></ref><ref id="hanspub.19947-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Shetty, S. and Rogers, T. (2014) Classification Based IP Geolocation Approach to Locate Data in the Cloud Data Centers. ACM, USA.</mixed-citation></ref><ref id="hanspub.19947-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">http://www.zdnet.com</mixed-citation></ref><ref id="hanspub.19947-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Christoph, K. (2013) Using Trusted Platform Modules for Location Assurance in Cloud Networking. Network and System Security, Springer, Berlin Heidelberg, 109-121.</mixed-citation></ref><ref id="hanspub.19947-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Yang, H.-J. (2013) Victor Costan. Authenticated Storage Using Small Tusted Hardware. ACM, 35-46.</mixed-citation></ref><ref id="hanspub.19947-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Noman, A. and Adams, C. (2014) Hardware-Based DLAS: Achieving Geo-Location Guarantees for Cloud Data Using TPM and Provable Data Possession. ACM, Crown, 280-285.</mixed-citation></ref><ref id="hanspub.19947-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Trusted Computing Group (2004) TCG Specification Architecture Overview Revision 1.2.  
&lt;br&gt;http://www.trustedcomputinggroup.org</mixed-citation></ref><ref id="hanspub.19947-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">冯登国, 等. 可信计算-理论与实践[M]. 北京: 清华大学出版社, 2013: 18-46.</mixed-citation></ref><ref id="hanspub.19947-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Zhang, S.R. (2004) Design and Implementation of a TCG-Based Integrity Measurement Architecture. Proceedings of the 13th Usenix Security Symposium, USA, 1-20.</mixed-citation></ref></ref-list></back></article>