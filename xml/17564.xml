<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">MOS</journal-id><journal-title-group><journal-title>Modeling and Simulation</journal-title></journal-title-group><issn pub-type="epub">2324-8696</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/MOS.2016.52002</article-id><article-id pub-id-type="publisher-id">MOS-17564</article-id><article-categories><subj-group subj-group-type="heading"><subject>MOS20160200000_77190961.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject><subject> 工程技术</subject></subj-group></article-categories><title-group><article-title>
 
 
  多目标无等待流水线调度的离散果蝇算法
  Discrete Fruit Fly Algorithm for Multi-Objective No-Wait Flow Shop Scheduling Problem
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>潘</surname><given-names>玉霞</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>贾</surname><given-names>保先</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><addr-line>三亚学院，公共计算机教学部，海南 三亚 </addr-line></aff><aff id="aff3"><addr-line>聊城大学计算机学院，山东 聊城 </addr-line></aff><aff id="aff2"><addr-line>null</addr-line></aff><author-notes><corresp id="cor1">* E-mail:<email>panyuxia2008@163.com(潘玉)</email>;</corresp></author-notes><pub-date pub-type="epub"><day>17</day><month>05</month><year>2016</year></pub-date><volume>05</volume><issue>02</issue><fpage>9</fpage><lpage>15</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
  本文提出了一种离散多目标果蝇优化算法，求解以最大完工时间和机床空闲时间最小化为目标的无等待流水线调度问题。与传统的果蝇算法不同，首先，该算法采用基于工序的编码方式，其次，利用GLOVE发生器进行初始化，提高初始解的分散度；最后，利用简单但有效的插入方法在邻域内进化精细搜索，增强算法的全局开发能力。仿真试验表明了所提果蝇算法的有效性和高效性。
   This paper presents a Fruit Fly Optimization Algorithm (FOA) for solving the multi-objective no- wait flow shop scheduling problem (MNFSP) with makespan and idle time criteria. Firstly, unlike the traditional FOA, the proposed algorithm applies the job-permutation-based representation. Secondly, initialization method based on the Glove generator has a uniform distribution of the so-lutions. Finally, a simple but effective insert search algorithm is made to improve global exploration. Computational results show that the FOA presented in this paper is very effective and efficient for the MNFSP.
 
</p></abstract><kwd-group><kwd>果蝇优化算法，无等待流水线调度问题，多目标, Fruit Fly Optimization Algorithm</kwd><kwd> No-Wait Flow Shop Scheduling Problem</kwd><kwd> Multi-Objective</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>多目标无等待流水线调度的离散果蝇算法<sup> </sup></title><p>潘玉霞<sup>1</sup>，贾保先<sup>2</sup></p><p><sup>1</sup>三亚学院，公共计算机教学部，海南 三亚</p><p><sup>2</sup>聊城大学计算机学院，山东 聊城</p><disp-formula id="hanspub.17564-formula20"><graphic xlink:href="http://html.hanspub.org/file/1-2570088x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>收稿日期：2016年4月20日；录用日期：2016年5月14日；发布日期：2016年5月17日</p><disp-formula id="hanspub.17564-formula21"><graphic xlink:href="http://html.hanspub.org/file/1-2570088x7_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>本文提出了一种离散多目标果蝇优化算法，求解以最大完工时间和机床空闲时间最小化为目标的无等待流水线调度问题。与传统的果蝇算法不同，首先，该算法采用基于工序的编码方式，其次，利用GLOVE发生器进行初始化，提高初始解的分散度；最后，利用简单但有效的插入方法在邻域内进化精细搜索，增强算法的全局开发能力。仿真试验表明了所提果蝇算法的有效性和高效性。</p><p>关键词 :果蝇优化算法，无等待流水线调度问题，多目标</p><disp-formula id="hanspub.17564-formula22"><graphic xlink:href="http://html.hanspub.org/file/1-2570088x8_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s3"><title>1. 引言</title><p>多目标优化问题是需要同时处理多个相互冲突和相互影响的目标，一个子目标的改善有可能会引起另一个或者另几个子目标的性能降低，需要在他们中间进行协调处理。起初，多目标优化问题往往通过加权等方式转化为单目标问题，但此方法效率较低且对权值和次序较为敏感。因此，后来发展了基于Pareto最优解集(Pareto-optimal set)或非支配解集(Nondominated Set)的群体智能算法解决多目标问题。文 [<xref ref-type="bibr" rid="hanspub.17564-ref1">1</xref>] 根据无等待多目标优化问题和粒子群算法的特征，采用近似Pareto前端的分布熵及其变化来估计种群进化状态，并依据这些进化过程反馈信息设计具有动态平衡开发能力的进化策略。文 [<xref ref-type="bibr" rid="hanspub.17564-ref2">2</xref>] 为了解决无等待柔性车间调度的多目标优化问题，结合灰色失联分析和熵理论，提出灰互信息适应度分配策略，以评价Pareto解的优劣。</p><p>果蝇优化算法(Fruit Fly Optimization Algorithm, FOA)是由台湾博士潘文超于2011年提出的一类全局进化优化算法。该算法源于对果蝇觅食行为的模拟，已在自动化仓库拣选作业调度问题 [<xref ref-type="bibr" rid="hanspub.17564-ref3">3</xref>] ，边坡稳定预测问题 [<xref ref-type="bibr" rid="hanspub.17564-ref4">4</xref>] ，船舶操纵响应模型的辨识问题 [<xref ref-type="bibr" rid="hanspub.17564-ref5">5</xref>] 等方面得到成功的应用。进化算法通过在代与代之间维持由潜在解组成的种群来实现全局搜索，这种从种群到种群的方法对于搜索多目标优化问题的pareto最优集是很有用的 [<xref ref-type="bibr" rid="hanspub.17564-ref6">6</xref>] 。</p></sec><sec id="s4"><title>2. 多目标无等待流水线调度问题 (Multi-Objective No-Wait Flow Shop Scheduling Problem, MNFSP)</title><sec id="s4_1"><title>2.1. 无等待流水线问题描述</title><p>无等待流水线调度问题要求加工的任务从开始到结束必须连续进行，即同一工件的两个相邻工序之间没有间隔。此类调度广泛存在于食品加工、炼钢、制药等生产领域。该问题可以描述为：有<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x9_hanspub.png" xlink:type="simple"/></inline-formula>个工件</p><p><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x10_hanspub.png" xlink:type="simple"/></inline-formula>在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x11_hanspub.png" xlink:type="simple"/></inline-formula>台机床<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x12_hanspub.png" xlink:type="simple"/></inline-formula>上加工<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x13_hanspub.png" xlink:type="simple"/></inline-formula>，工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x14_hanspub.png" xlink:type="simple"/></inline-formula>在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x15_hanspub.png" xlink:type="simple"/></inline-formula>台机床上的加工操</p><p>作为。同时需要满足如下条件：所有工件启动和运输时间包含在工件的加工时间内，均可在零时刻进行加工，每个工件在各机床上的加工顺序相同。为了满足无等待的条件，推迟工件在第一台机床上的加工</p><p>时间，使得工件在每台机床上的完成时间必须等于其在下一台机床上的开始加工时间，即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x16_hanspub.png" xlink:type="simple"/></inline-formula>的完成时间必须等于<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x18_hanspub.png" xlink:type="simple"/></inline-formula><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x17_hanspub.png" xlink:type="simple"/></inline-formula>的开始时间。目的是得到一个可行调度<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x19_hanspub.png" xlink:type="simple"/></inline-formula>，求其Pareto最优解集。该问题的模型如图1所示。</p><p>图1. 无等待流水线调度问题</p></sec><sec id="s4_2"><title>2.2. 调度优化目标计算</title><p>提出以最大完工时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x21_hanspub.png" xlink:type="simple"/></inline-formula>、机床最大空闲时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x22_hanspub.png" xlink:type="simple"/></inline-formula>为指标对无等待调度问题进行研究。其中最大完工时间是从第一个工件开始加工计时到最后一个工件完成时间，机床空闲时间为各工件加工的空隙时间和。优化最大完工时间有利于提高生产率，降低工件的生产周期，优化机床空闲时间可以提高机床的利用率。</p><p>假设工序<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x23_hanspub.png" xlink:type="simple"/></inline-formula>按机床1到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x24_hanspub.png" xlink:type="simple"/></inline-formula>的顺序进行加工，其中<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x25_hanspub.png" xlink:type="simple"/></inline-formula>为工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x26_hanspub.png" xlink:type="simple"/></inline-formula>在机床<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x27_hanspub.png" xlink:type="simple"/></inline-formula>上的加工时间，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x28_hanspub.png" xlink:type="simple"/></inline-formula>代表工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x29_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x30_hanspub.png" xlink:type="simple"/></inline-formula>在第一台机床上的开始时间差。各工序的加工时间已知，工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x31_hanspub.png" xlink:type="simple"/></inline-formula>在机床<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x32_hanspub.png" xlink:type="simple"/></inline-formula>上的完成时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x33_hanspub.png" xlink:type="simple"/></inline-formula>的计算公式为：</p><disp-formula id="hanspub.17564-formula23"><label>(1)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x34_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.17564-formula24"><label>(2)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x35_hanspub.png"  xlink:type="simple"/></disp-formula><p>其中<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x36_hanspub.png" xlink:type="simple"/></inline-formula>的计算公式如下：</p><disp-formula id="hanspub.17564-formula25"><label>(3)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x38_hanspub.png"  xlink:type="simple"/></disp-formula><p>那么工序的最小化最大完成时间计算公式如下：</p><disp-formula id="hanspub.17564-formula26"><label>(4)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x39_hanspub.png"  xlink:type="simple"/></disp-formula><p>最小化最大机器空闲时间的计算公式如下：</p><disp-formula id="hanspub.17564-formula27"><label>(5)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x40_hanspub.png"  xlink:type="simple"/></disp-formula><p>两个目标值算法的时间复杂度分别为是O(n)，O(mn)。为了降低算法复杂度，提前定义变量<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x41_hanspub.png" xlink:type="simple"/></inline-formula>代表第一个工件与第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x42_hanspub.png" xlink:type="simple"/></inline-formula>个工件在第一台机床的开工时间差</p><disp-formula id="hanspub.17564-formula28"><label>(6)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x43_hanspub.png"  xlink:type="simple"/></disp-formula><p><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x44_hanspub.png" xlink:type="simple"/></inline-formula>为工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x45_hanspub.png" xlink:type="simple"/></inline-formula>在第一台机床到第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x46_hanspub.png" xlink:type="simple"/></inline-formula>台机床上的加工时间和</p><disp-formula id="hanspub.17564-formula29"><label>(7)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x47_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.17564-formula30"><label>(8)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x48_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.17564-formula31"><label>(9)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x49_hanspub.png"  xlink:type="simple"/></disp-formula><p>通过公式(8)，(9)所示算法的时间复杂度降低为O(1)，O(n)。</p></sec><sec id="s4_3"><title>2.3. Pareto最优解集</title><p>不同于单目标优化问题需要求得一个最优解，而多目标问题的优化就是寻找Pareto最优解集。在有限集合<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x50_hanspub.png" xlink:type="simple"/></inline-formula>上，给出两个目标的调度优化问题，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x51_hanspub.png" xlink:type="simple"/></inline-formula>，若<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x52_hanspub.png" xlink:type="simple"/></inline-formula>，假定<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x53_hanspub.png" xlink:type="simple"/></inline-formula>支配<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x54_hanspub.png" xlink:type="simple"/></inline-formula>，则<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x55_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x56_hanspub.png" xlink:type="simple"/></inline-formula>。在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x57_hanspub.png" xlink:type="simple"/></inline-formula>中如果有一个没有被任何其他解所支配，则称它为Pareto最优解或非支配解。所有非支配解或Pareto最优解的集合成为Pareto最优解集。</p></sec></sec><sec id="s5"><title>3. 基于MNFSP的离散果蝇算法</title><p>果蝇优化算法的基本原理是初始化种群的中心位置，利用敏锐的嗅觉进行搜索，即根据中心位置随机产生多个邻域解。计算各可行解的味道浓度，即评价值，然后利用视觉从中选择较好的解，更新替换中心位置，然后进行迭代寻优，以更好的进靠近食物源。FOA在整个迭代寻优过程中，在连续空间中产生新个体的方法不适合解决MNFSP。故运用FOA算法的主体流程，对其优化过程进行离散化是算法成功应用于MNFSP的关键。基于以上分析，提出了离散果蝇算法(Discrete Fruit Fly Optimization Algorithm DFOA)。</p><sec id="s5_1"><title>3.1. 算法编码和初始化</title><p>种群中每个果蝇个体对应问题中的一个解，即工件的完整加工序列<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x58_hanspub.png" xlink:type="simple"/></inline-formula>，如<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x59_hanspub.png" xlink:type="simple"/></inline-formula>为4个工件的调度实例解。</p><p>果蝇初始个体产生采用GLOVE [<xref ref-type="bibr" rid="hanspub.17564-ref7">7</xref>] 发生器产生一组分布均匀的工件排列。对于一个给定排序<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x60_hanspub.png" xlink:type="simple"/></inline-formula>，GLOVE发生器可得到n/2个分散均匀的排列。随机变化给定排列，即可得到足够多的初始果蝇个体，即可构成一个分散性较好的初始种群。</p></sec><sec id="s5_2"><title>3.2. 嗅觉和视觉搜索</title><p>影响FOA算法性能的核心是如何生成嗅觉阶段的邻域个体 [<xref ref-type="bibr" rid="hanspub.17564-ref8">8</xref>] 。一般全局Pareto最优解集中在局部Pareto最优解附近；因此利用Pareto最优解集中的解产生新解的质量较高。</p><p>对于MNFSP来讲，插入操作是最有效的邻域解生成方法 [<xref ref-type="bibr" rid="hanspub.17564-ref8">8</xref>] 。因为子代可以很好的继承父代个体的优良基因，可以充分利用非支配解信息优势，引导算法向Pareto最优前沿进化。嗅觉阶段在Pareto最优解集中随机选取一个果蝇个体，对其执行插入邻域操作步骤如下：</p><p>步骤1：当前个体记为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x61_hanspub.png" xlink:type="simple"/></inline-formula>，通过对<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x62_hanspub.png" xlink:type="simple"/></inline-formula>进行三次插入操作得到调度<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x63_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>步骤2：从<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x64_hanspub.png" xlink:type="simple"/></inline-formula>中随机选取一个工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x65_hanspub.png" xlink:type="simple"/></inline-formula>得到调度<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x66_hanspub.png" xlink:type="simple"/></inline-formula>用公式(8)(9)分别计算<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x67_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x68_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>将工件<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x69_hanspub.png" xlink:type="simple"/></inline-formula>插入到所有可能的位置<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x70_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x71_hanspub.png" xlink:type="simple"/></inline-formula>得到调度<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x72_hanspub.png" xlink:type="simple"/></inline-formula>，如图2所示。</p><p>指标计算公式如下：</p><disp-formula id="hanspub.17564-formula32"><label>(10)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x73_hanspub.png"  xlink:type="simple"/></disp-formula><p>图2. 插入邻域完工时间和空闲时间快速计算方法</p><disp-formula id="hanspub.17564-formula33"><label>(11)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/1-2570088x82_hanspub.png"  xlink:type="simple"/></disp-formula><p>步骤3：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x83_hanspub.png" xlink:type="simple"/></inline-formula>代表临时非支配解集，保存插入过程中得到的非支配解。</p><p>步骤4：若<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x84_hanspub.png" xlink:type="simple"/></inline-formula>中有解没有被AS中的解支配，则更新AS。</p><p>步骤5：若<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x85_hanspub.png" xlink:type="simple"/></inline-formula>中有解支配<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x86_hanspub.png" xlink:type="simple"/></inline-formula>，则替换之；若互不支配，则随机选择一个替换<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x87_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>确定新解是否为非支配解，若为非支配解，则更新AS，同时选择较好的解替换当前解。</p></sec></sec><sec id="s6"><title>4. DFOA算法流程</title><p>基于上述设计，DFOA算法的流程步骤如下所示：</p><p>步骤1：设置参数，初始化种群。</p><p>步骤2：评价果蝇个体，并判断是否为非支配解，更新AS。</p><p>步骤3：在AS中随机选择一个非支配解，利用算法的嗅觉和视觉部分产生新的个体，并更新AS。</p><p>步骤4：判断终止条件是否满足，是则转到步骤5，否则转到步骤3。</p><p>步骤5：算法终止。</p></sec><sec id="s7"><title>5. 仿真实验</title><sec id="s7_1"><title>5.1. 实验设置</title><p>将本文所提算法DFOA与文献 [<xref ref-type="bibr" rid="hanspub.17564-ref9">9</xref>] ESFLA进行比较，通过不同规模的解决6个标准问题进行有效性验证。几种算法都在处理器为Intel(R)Core i3 2.13 GHZ、内存为2G的PC机上，采用C++编码进行测试。对于每个算例，两种算法分别独立运行20次，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x88_hanspub.png" xlink:type="simple"/></inline-formula>为第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x89_hanspub.png" xlink:type="simple"/></inline-formula>个算法得到的非支配解集，从中选出非支配解集作为参考非支配解集<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x90_hanspub.png" xlink:type="simple"/></inline-formula>。算法最大运行时间为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x91_hanspub.png" xlink:type="simple"/></inline-formula>微秒。采用两个性能指标来评价算法所得到的非支配解集：距Pareto边界的平均距离<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x92_hanspub.png" xlink:type="simple"/></inline-formula>、非支配解的比率<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x93_hanspub.png" xlink:type="simple"/></inline-formula>。</p></sec><sec id="s7_2"><title>5.2. 仿真结果对比</title><p>对文献 [<xref ref-type="bibr" rid="hanspub.17564-ref9">9</xref>] 提出的ESFLA算法进行修改，按文中规定的参数进行设置，并将其应用于求解基于最大</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> The comparation of between DFOA and ESFL</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >算例</th><th align="center" valign="middle"  colspan="3"  >DFOA</th><th align="center" valign="middle"  colspan="3"  >ESFLA</th></tr></thead><tr><td align="center" valign="middle" >名称</td><td align="center" valign="middle" >n &#215; m</td><td align="center" valign="middle" >AVG</td><td align="center" valign="middle" >MIN</td><td align="center" valign="middle" >MAX</td><td align="center" valign="middle" >AVG</td><td align="center" valign="middle" >MIN</td><td align="center" valign="middle" >MAX</td></tr><tr><td align="center" valign="middle" >Car01</td><td align="center" valign="middle" >11 &#215; 5</td><td align="center" valign="middle" >0.15</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >2.94</td><td align="center" valign="middle" >1.51</td><td align="center" valign="middle" >2.24</td><td align="center" valign="middle" >5.14</td></tr><tr><td align="center" valign="middle" >Car07</td><td align="center" valign="middle" >7 &#215; 7</td><td align="center" valign="middle" >0.04</td><td align="center" valign="middle" >0.03</td><td align="center" valign="middle" >0.79</td><td align="center" valign="middle" >0.05</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >1.03</td></tr><tr><td align="center" valign="middle" >Hel1</td><td align="center" valign="middle" >100 &#215; 10</td><td align="center" valign="middle" >0.10</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >1.96</td><td align="center" valign="middle" >0.79</td><td align="center" valign="middle" >0.66</td><td align="center" valign="middle" >2.07</td></tr><tr><td align="center" valign="middle" >Hel2</td><td align="center" valign="middle" >20 &#215; 10</td><td align="center" valign="middle" >0.07</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >1.47</td><td align="center" valign="middle" >0.99</td><td align="center" valign="middle" >0.49</td><td align="center" valign="middle" >3.14</td></tr><tr><td align="center" valign="middle" >Rec35</td><td align="center" valign="middle" >50 &#215; 10</td><td align="center" valign="middle" >0.02</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >0.43</td><td align="center" valign="middle" >0.35</td><td align="center" valign="middle" >0.17</td><td align="center" valign="middle" >3.42</td></tr><tr><td align="center" valign="middle" >Rec37</td><td align="center" valign="middle" >75 &#215; 20</td><td align="center" valign="middle" >0.04</td><td align="center" valign="middle" >0.00</td><td align="center" valign="middle" >0.72</td><td align="center" valign="middle" >0.12</td><td align="center" valign="middle" >0.03</td><td align="center" valign="middle" >2.35</td></tr><tr><td align="center" valign="middle" >Mean</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >0.07</td><td align="center" valign="middle" >0.01</td><td align="center" valign="middle" >1.39</td><td align="center" valign="middle" >0.64</td><td align="center" valign="middle" >0.60</td><td align="center" valign="middle" >2.86</td></tr></tbody></table></table-wrap><p>表1. DFOA、ESFLA算法的<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x95_hanspub.png" xlink:type="simple"/></inline-formula>比较</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> The comparation of between DFOA and ESFL</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >算例</th><th align="center" valign="middle"  colspan="3"  >DFOA</th><th align="center" valign="middle"  colspan="3"  >ESFLA</th></tr></thead><tr><td align="center" valign="middle" >名称</td><td align="center" valign="middle" >n &#215; m</td><td align="center" valign="middle" >AVG</td><td align="center" valign="middle" >MIN</td><td align="center" valign="middle" >MAX</td><td align="center" valign="middle" >AVG</td><td align="center" valign="middle" >MIN</td><td align="center" valign="middle" >MAX</td></tr><tr><td align="center" valign="middle" >Car01</td><td align="center" valign="middle" >11 &#215; 5</td><td align="center" valign="middle" >0.99</td><td align="center" valign="middle" >0.97</td><td align="center" valign="middle" >1.00</td><td align="center" valign="middle" >0.68</td><td align="center" valign="middle" >0.56</td><td align="center" valign="middle" >0.94</td></tr><tr><td align="center" valign="middle" >Car07</td><td align="center" valign="middle" >7 &#215; 7</td><td align="center" valign="middle" >0.96</td><td align="center" valign="middle" >0.92</td><td align="center" valign="middle" >1.00</td><td align="center" valign="middle" >0.89</td><td align="center" valign="middle" >0.68</td><td align="center" valign="middle" >1.00</td></tr><tr><td align="center" valign="middle" >Hel1</td><td align="center" valign="middle" >100 &#215; 10</td><td align="center" valign="middle" >0.85</td><td align="center" valign="middle" >0.59</td><td align="center" valign="middle" >0.98</td><td align="center" valign="middle" >0.78</td><td align="center" valign="middle" >0.32</td><td align="center" valign="middle" >0.89</td></tr><tr><td align="center" valign="middle" >Hel2</td><td align="center" valign="middle" >20 &#215; 10</td><td align="center" valign="middle" >0.78</td><td align="center" valign="middle" >0.51</td><td align="center" valign="middle" >1.00</td><td align="center" valign="middle" >0.66</td><td align="center" valign="middle" >0.54</td><td align="center" valign="middle" >0.78</td></tr><tr><td align="center" valign="middle" >Rec35</td><td align="center" valign="middle" >50 &#215; 10</td><td align="center" valign="middle" >0.71</td><td align="center" valign="middle" >0.19</td><td align="center" valign="middle" >0.92</td><td align="center" valign="middle" >0.65</td><td align="center" valign="middle" >0.40</td><td align="center" valign="middle" >0.82</td></tr><tr><td align="center" valign="middle" >Rec37</td><td align="center" valign="middle" >75 &#215; 20</td><td align="center" valign="middle" >0.79</td><td align="center" valign="middle" >0.13</td><td align="center" valign="middle" >0.98</td><td align="center" valign="middle" >0.78</td><td align="center" valign="middle" >0.31</td><td align="center" valign="middle" >0.89</td></tr><tr><td align="center" valign="middle" >Mean</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >0.85</td><td align="center" valign="middle" >0.58</td><td align="center" valign="middle" >0.97</td><td align="center" valign="middle" >0.76</td><td align="center" valign="middle" >0.52</td><td align="center" valign="middle" >0.87</td></tr></tbody></table></table-wrap><p>表2. DFOA和ESFLA 算法的<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x97_hanspub.png" xlink:type="simple"/></inline-formula>比较</p><p>完工时间和最大机床空闲时间的多目标无等待流水线调度问题。两种算法采用相同的终止条件。AVG、MIN和MAX分别代表20次仿真实验目标值的平均值、最小值和最大值。结果如表1，表2所示。</p><p>由于真正的非支配解很难搜索到，有必要对所得解集计算<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x98_hanspub.png" xlink:type="simple"/></inline-formula>，距离越近，得到的解质量就越高。由表1可知，DFOA算法的平均<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x99_hanspub.png" xlink:type="simple"/></inline-formula>，最小<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x100_hanspub.png" xlink:type="simple"/></inline-formula>，以及最大<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x101_hanspub.png" xlink:type="simple"/></inline-formula>的值分别是0.07，0.01，1.39，均小于ESFLA算法的0.64，0.60，2.86。因此，相对于平均距离而言，DFOA算法性能优于ESFLA。</p><p>算法DFOA优于ESFLA的另一个方面表现在非支配解的比率上。由表2可以看出，DFOA算法中平均有85%没有被<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/1-2570088x102_hanspub.png" xlink:type="simple"/></inline-formula>中的其他解所支配，而ESFLA算法中只有76%。</p></sec></sec><sec id="s8"><title>6. 结论</title><p>综上所述，DFOA算法之所以优于ESFLA，因为DFOA算法在算法中执行过程中保留了所以的非支配解，并充分利用了非支配解的优势，在其基础上用插入方法产生邻域解，更好的指导了算法的进化方向，增强算法全局搜索的能力。</p></sec><sec id="s9"><title>基金项目</title><p>海南省教育厅科研项目(Hnky2015-51, Hnky2015-55)；三亚市院地科技合作项目(2015YD57, 2015YD11)。</p></sec><sec id="s10"><title>文章引用</title><p>潘玉霞,贾保先. 多目标无等待流水线调度的离散果蝇算法 Discrete Fruit Fly Algorithm for Multi-Objective No-Wait Flow Shop Scheduling Problem[J]. 建模与仿真, 2016, 05(02): 9-15. http://dx.doi.org/10.12677/MOS.2016.52002</p></sec><sec id="s11"><title>参考文献 (References)</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.17564-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">胡旺, Gary YEN, 张鑫. 基于Pareto熵的多目标粒子群优化算法[J]. 软件学报, 2014, 24(5): 1025-1050.</mixed-citation></ref><ref id="hanspub.17564-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">毕孝儒, 张黎黎, 贺拴, 等. 面向无等待多目标柔性车间调度问题的遗传蜂群优化算法[J]. 研究与开发, 2015(8): 11-16.</mixed-citation></ref><ref id="hanspub.17564-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">刘志雄, 王雅芬, 张煜. 多种群果蝇优化算法求解自动化仓库拣选作业调度问题[J]. 武汉理工大学学报, 2014, 36(3): 71-77.</mixed-citation></ref><ref id="hanspub.17564-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">王海军, 涂凯, 闫晓荣. 基于果蝇优化算法的GRNN模型在边坡稳定预测中的应用[J]. 水电能源科学, 2015, 33(1): 124-126.</mixed-citation></ref><ref id="hanspub.17564-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">王雪刚, 邹早建. 基于果蝇优化算法的船舶操纵响应模型的辨识[J]. 大连海事大学学报, 2012, 38(3): 1-4.</mixed-citation></ref><ref id="hanspub.17564-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">公茂果, 焦李成, 杨咚咚, 等. 进化多目标优化算法研究[J]. 软件学报, 2009, 20(2): 271-289.</mixed-citation></ref><ref id="hanspub.17564-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Glover, F. (1998) A Template for Scatter Search and Path Reclinking. Artificial Evolution. Lecture Notes in Computer Science, 1363, 1-51.</mixed-citation></ref><ref id="hanspub.17564-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">郑晓龙, 王凌, 王圣尧. 求解置换流水线调度问题的混合离散果蝇算法[J]. 控制理论与应用, 2014, 31(2): 159- 164.</mixed-citation></ref><ref id="hanspub.17564-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">潘玉霞, 潘全科, 李俊青. 蛙跳优化算法求解多目标无等待流水线调度[J]. 控制理论与应用, 2011, 28(10): 1363- 1370.</mixed-citation></ref></ref-list></back></article>