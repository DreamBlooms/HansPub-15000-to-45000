<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">SEA</journal-id><journal-title-group><journal-title>Software Engineering and Applications</journal-title></journal-title-group><issn pub-type="epub">2325-2286</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/SEA.2020.91003</article-id><article-id pub-id-type="publisher-id">SEA-33919</article-id><article-categories><subj-group subj-group-type="heading"><subject>SEA20200100000_63928763.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>工程技术</subject></subj-group></article-categories><title-group><article-title>
 
 
  分离逻辑断言的Coq证明策略
  Tactics for Proving Separation Logic Assertions in Coq
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>雷</surname><given-names>斯然</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>程</surname><given-names>梦奇</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>江</surname><given-names>建国</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>辽宁师范大学数学学院，辽宁 大连</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>06</day><month>01</month><year>2020</year></pub-date><volume>09</volume><issue>01</issue><fpage>14</fpage><lpage>21</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
  大型程序的验证是一项十分复杂但又极其重要的工作。本文以使用Hoare风格的分离逻辑验证C程序为目的，在基于Coq的现有的验证系统中，添加分离蕴含以扩展其分离逻辑断言语法，使得分离逻辑断言可以更灵活的描述程序状态。此外，我们开发了一些相关的自动证明策略，尽可能的通过减少人工证明来提高验证效率。
   The verification of the correctness of large programs is an unmanageable but important endeavor. We are interested in verifying C programs with formal methods; the logic is separation logic, a Hoare-style program logic. In this paper, we present a simple extension of the syntax of separation logic assertion on existing verification system in Coq proof assistant to make assertions more ver-satile and flexible to describe the state of programs. Moreover, we develop several tactics for prov-ing some related assertions to reduce manual proof as much as possible and improve the efficiency of verification.
 
</p></abstract><kwd-group><kwd>形式化方法，程序验证，分离逻辑，Coq，交互式定理证明, Formal Method</kwd><kwd> Program Verification</kwd><kwd> Automated Reasoning</kwd><kwd> Coq</kwd><kwd> Interactive Theorem Proving</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>分离逻辑断言的Coq证明策略<sup> </sup></title><p>雷斯然，程梦奇，江建国<sup>*</sup></p><p>辽宁师范大学数学学院，辽宁 大连</p><disp-formula id="hanspub.33919-formula18"><graphic xlink:href="//html.hanspub.org/file/3-2690409x5_hanspub.png"  xlink:type="simple"/></disp-formula><p>收稿日期：2019年12月23日；录用日期：2020年1月6日；发布日期：2020年1月13日</p><disp-formula id="hanspub.33919-formula19"><graphic xlink:href="//html.hanspub.org/file/3-2690409x6_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>大型程序的验证是一项十分复杂但又极其重要的工作。本文以使用Hoare风格的分离逻辑验证C程序为目的，在基于Coq的现有的验证系统中，添加分离蕴含以扩展其分离逻辑断言语法，使得分离逻辑断言可以更灵活的描述程序状态。此外，我们开发了一些相关的自动证明策略，尽可能的通过减少人工证明来提高验证效率。</p><p>关键词 :形式化方法，程序验证，分离逻辑，Coq，交互式定理证明</p><disp-formula id="hanspub.33919-formula20"><graphic xlink:href="//html.hanspub.org/file/3-2690409x7_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2020 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/3-2690409x8_hanspub.png" /> <img src="//html.hanspub.org/file/3-2690409x9_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>随着科技的发展，软件系统的应用日益广泛，其正确性也越来越重要，尤其是安全攸关 [<xref ref-type="bibr" rid="hanspub.33919-ref1">1</xref>]，商业攸关以及任务攸关等系统。由于C语言具有编译效率高、可移植性好等特点，大多数软件系统较底层的开发是由它实现的。验证C程序的正确性可采用形式化方法，该方法是通过使用数学方法，对软件或硬件系统进行描述、开发和验证的一种技术。然而，大型C程序的验证是一个十分巨大且困难的工作，并且该问题已被证明是一个不可判定性问题，即不可以完全自动化验证。因此，交互式的证明C程序的正确性是一个很好的选择。</p><p>自20世纪60年代以来，Hoare提出的Hoare逻辑是一直被广泛应用的程序验证逻辑系统 [<xref ref-type="bibr" rid="hanspub.33919-ref2">2</xref>]，用于对命令式程序进行推理验证，是程序逻辑研究领域的一个重大进展。但是Hoare逻辑对于带有指针的程序的验证仍然十分繁琐。</p><p>2002年，Reynolds和O’Hearn将Hoare逻辑拓展为可推理验证操作动态分配内存程序的分离逻辑 [<xref ref-type="bibr" rid="hanspub.33919-ref3">3</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref4">4</xref>]，进一步发展了程序逻辑理论。近二十年以来，分离逻辑已被拓展至多种版本，其使用范围更加广泛，在程序验证中占据着越来越重要的地位。分离逻辑具有更强的表达力和验证能力，例如并发程序的验证等。然而表达力越强的程序逻辑，其验证过程越复杂。分离逻辑已被证明是一个不可判定的程序逻辑，因此使用分离逻辑验证C程序的过程无法达到完全自动化。然而大型的C程序证明十分复杂，手动证明不但需要大量的人力物力，可信度也不是很高，因此人机交互式的证明C程序是不可避免的。</p><p>在过去的几十年中，有关交互式定理证明器实现与应用分离逻辑的进展有很多，例如 [<xref ref-type="bibr" rid="hanspub.33919-ref5">5</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref6">6</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref7">7</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref9">9</xref>]。Coq [<xref ref-type="bibr" rid="hanspub.33919-ref10">10</xref>] 是一个被广泛应用的人机交互式的定理证明器，其基本理论是归纳结构的演算。一些由 [<xref ref-type="bibr" rid="hanspub.33919-ref11">11</xref>] 提供的Coq实用策略也是用于基于分离逻辑的C程序验证，这些高度自动化的策略可以仅使用单行证明脚本完成对特定C程序的验证，例如，该系统只需使用1行仅有4个单词的证明脚本来证明经典的就地反转链表算法，而McCreight的Coq策略 [<xref ref-type="bibr" rid="hanspub.33919-ref12">12</xref>] 需要68行400个单词，Charge的策略 [<xref ref-type="bibr" rid="hanspub.33919-ref13">13</xref>] 需要25行105个单词。本文将分离逻辑中的分离蕴含运算符添加到该系统的分离逻辑断言语法中，并提供一些相关的自动证明策略。</p></sec><sec id="s4"><title>2. 程序逻辑和证明助手</title><sec id="s4_1"><title>2.1. Hoare逻辑</title><p>Hoare逻辑是使用严格的数理逻辑推理来验证命令式程序正确性的逻辑系统，它使用逻辑断言来描述程序的状态。</p><p>Hoare使用霍尔三元组来描述程序的行为，是Hoare逻辑的中心特征，其形式如下：</p><p>{ P }   c   { Q } ,</p><p>其中断言P是前置条件，断言Q是后置条件，c是程序。前置条件和后置条件是分别描述执行程序c前后的程序状态的断言。一个有效的霍尔三元组表示：如果程序c执行前，内存状态满足断言P，那么程序执行后，内存状态满足断言Q。考虑以下霍尔三元组：</p><p>{ x = 3 }   x : = x ∗ 2   { x &gt; 4 } ,</p><p>它显然是有效的，由于程序 x : = x ∗ 2 执行前x的值为3，执行后可得出x的值为6，因此 x &gt; 3 为真。然而上述霍尔三元组并不够精准，如果更换其后置条件为 x &gt; 5 ∧ x &lt; 10 ，则霍尔三元组为 { x = 3 }   x : = x ∗ 2   { x &gt; 5 ∧ x &lt; 10 } ，因为 x = 6 蕴含 x &gt; 5 ∧ x &lt; 10 ，所以该霍尔三元组也是有效的。显然 x &gt; 5 ∧ x &lt; 10 相比于 x &gt; 3 更加精准，但是相对于 x = 6 还是要弱一些，像 x = 6 这样的后置条件通常被称之为最强后置条件。一般的，对于给定的霍尔三元组{P} c {Q}，对于所有的Q'，如果有{P} c {Q'}，且Q ⇒ Q'，则称Q为对应的P和c的最强后置条件。与最强后置条件类似，如果对于所有的P'，有t {P'} c {Q}，且P' ⇒ P，那么称P为最弱前置条件。在霍尔逻辑中，下面的规则可以根据对应的语句与后置条件生成最弱前置条件：</p><p>{ Q [ a/x ] }     x   : = a     { Q }                           ( 赋 值 规 则 ) { P }   c 1   { Q }     { Q }   c 2   { R } { P }       c 1   ;   c 2   { R }                                 ( 顺 序 规 则 )   { P }   c 1   { Q }     { P }   c 2   { Q } { P }   I F     b     T H E N     c 1     E L S E     c 2   { Q }             ( 条 件 规 则 ) { P   ∧   b }   c   { P } { P }   W H I L E     b     D O     c     E N D   { P ∧ &#172; b }             ( 循 环 规 则 )</p><p>其中Q[a/x]表示使用a替换Q中x的每次自由出现。此外，推论规则(如下)可以加强前置条件或者减弱后置条件：</p><p>P ′ ⇒ P   { P }   c   { Q }   Q ⇒ Q ′ { P ′ }   c   { Q ′ }</p><p>自1960年起，Hoare逻辑被广泛的应用于命令式程序语言的验证中，然而，在验证带有指针的程序时，其证明过程仍然十分复杂，极具挑战性。2002年，分离逻辑作为霍尔逻辑的拓展，简化了此类证明过程。</p></sec><sec id="s4_2"><title>2.2. 分离逻辑</title><p>分离逻辑是Hoare霍尔逻辑的拓展，它引入了两个重要的运算符分别是分离合取(∗)和分离蕴涵(−∗)，它们的形式语义如下：</p><p>s , h | ​ = p 0 ∗ p 1     iff     ∃ h 0 , h 1 h 0 ⊥ h 1   and h 0 ⋅ h 1 = h   and   s , h 0 | ​ = p 0   and   s , h 1 | ​ = p 1</p><p>其中s表示栈，h表示堆， h 0 ⊥ h 1 表示堆 h 0 和 h 1 不相交， h 0 ⋅ h 1 表示堆 h 0 和 h 1 的并集。[P * Q] s h断言整个堆h分为两个不相交的部分 h 0 和 h 1 ，对于子堆 h 0 ，断言P为真，对于子堆 h 1 ，断言Q为真。</p><p>s , h | ​ = p 0 − ​ ​ ​ ∗ p 1 iff ∀ h ′ ( h ′ ⊥ h   and   s ,   h ′   | ​ = p 0 )   implies   s ,   h ⋅ h ′   | ​ = p 1</p><p>也就是说，如果堆的扩展h'满足断言 p 0 ，并且断言 p 0 对h'是正确的，则对于扩展后的堆 h ⋅ h ′ 满足断言 p 1 。</p><p>分离逻辑通过表达显示分离的逻辑连接词以及相应的规则消除了共享的可能，具有较强的表达能力。分离逻辑用于程序验证，简化了程序的验证工作，例如带有数组和指针的程序，并支持局部推理，其分离思想和对应的框架规则使得局部推理可以很好地应用到程序验证中。较比Hoare逻辑，分离逻辑具有更强的表达能力与验证能力，因此继Hoare逻辑之后，分离逻辑成为程序验证的一种重要方法。</p></sec><sec id="s4_3"><title>2.3. Coq证明助手</title><p>交互式定理证明工具Coq，为交互式形式化验证提供了一个丰富的环境。Coq的规范语言是Galina，它支持开发数学定理以及证明程序规范，其命令语言为vernacular。</p><p>通常，Coq是一个开发数学证明的环境，其应用包括法伊特–汤普森(Feit-Thompson)定理的证明，实现了CompCert编译器 [<xref ref-type="bibr" rid="hanspub.33919-ref14">14</xref>] 以及VST [<xref ref-type="bibr" rid="hanspub.33919-ref11">11</xref>] [<xref ref-type="bibr" rid="hanspub.33919-ref15">15</xref>] 等。它虽然是交互式的定理证明器，不能达到完全自动化，但是它拥有着强大的判定过程以及自动化证明策略库，还有一种编写自动证明策略的语言，称为Ltac [<xref ref-type="bibr" rid="hanspub.33919-ref16">16</xref>]。本文旨在使用Coq证明助手验证C程序的正确性，其中的证明策略使用Ltac语言实现。</p></sec></sec><sec id="s5"><title>3. 分离逻辑断言</title><p>分离逻辑引入分离合取和分离蕴涵等运算符扩展断言语法，从而可以对堆进行更简洁而灵活的描述。本节将添加分离蕴含到原有系统中，扩展系统的断言语法 [<xref ref-type="bibr" rid="hanspub.33919-ref17">17</xref>]。</p><p>下面阐述如何逐步将分离蕴含添加到原有系统中，首先，扩充原有断言语法如下：</p><p>扩 充 前 : ( A s r t )     p   : : =         e m p | t r u e     |     f a l s e | a ↦ v | e = v | x @ a               |       p * p     | E x   x . p | p ∧ p | p ∨ q | 〈 p 〉                 ⇓ 扩 充 后 : ( A s r t )     p   : : =         e m p | t r u e     |     f a l s e | a ↦ v | e = v | x @ a               |       p * p     | p - ​ - ​ * p | E x   x . p | p ∧ p | p ∨ q | 〈 p 〉</p><p>在Coq中，添加构造子Awand，这意味着将分离蕴含加入到Asrt的归纳定义中：</p><p>|     A w a n d     (   P : a s r t     )     (   Q : a s r t   )</p><p>随后定义</p><p>I n f i x     ' '     - ​ - ​ *     ' '   : = A w a n d .</p><p>意味着P −∗ Q代表 (Awand P Q)。下一步，在Coq中描述s |= P −∗ Q的含义如下：</p><p>e x i s t s     M 1     M 2     M ,     M = g e t _ m e m   s   ∧   M e m M o d   .   j o i n     M 1     M 2     M   ∧   ( s a t   (   s u b s t m e m   s   M 1   )   p → s a t   (   s u b s t m e m   s   M   )   q )</p><p>其中 (sat s P) 表示s| = P，即内存s满足断言P。显然，M，M1和M2代表堆，并且参照章节2.2中[P −∗ Q] s h的定义，(MemMod.join M1 M2 M)表示 M 1 ⊥ M 2 并且 M 1 ⋅ M 2 = M 。</p><p>当然，仍有一些关于添加分离蕴含到系统中的细节，我们在这里不关注。</p></sec><sec id="s6"><title>4. 策略</title><p>从本节开始，我们将在Coq中证明工作中使用的部分推理规则的可靠性并介绍证明带有分离蕴含的分离逻辑断言的策略。</p><sec id="s6_1"><title>4.1. 推理规则</title><p>以下是两个重要的推理规则，分别称为柯灵规则和柯灵逆反：</p><p>P ∗ Q ⇒ R P ⇒ ( Q - ​ - ​ ∗ R ) ( 柯 灵 规 则 )   P ⇒ ( Q - ​ - ​ ∗ R ) P ∗ Q ⇒ R ( 柯 灵 逆 反 规 则 )</p><p>柯灵规则及其逆反规则表述了分离合取和分离蕴涵之间的关系，并且由此可以推导出一系列推理规则。我们从几个基本示例开始阐述如何在Coq中证明它们是正确的。考虑下面的推断规则，它可由柯灵规则推出：</p><p>emp ⇒ ( P − ​ ∗ P )</p><p>证明过程如下：</p><p>T h e o r e m     a w a n d _ e m p     :     f o r a l l   P ,   e m p ⇒   P - ​ - ​ * P .</p><p>Theorem是一个命令，它表示正确性证明的开始，其证明过程从以下状态开始：</p><p>1   s u b g o a l ================= f o r a l l P : a s r t , e m p ⇒   P - ​ - ​ *   P</p><p>P r o o f .       i n t r o   P . P :   a s r t ================= e m p ⇒   P - ​ - ​ *   P</p><p>proof是指启动证明脚本，而intro P将P转变为自由变量。这里，我们可以应用柯灵规则如下：</p><p>a p p l y   C U R R Y I N G   w i t h     (   Q : = P   )     (   R : = P   )   . P :   a s r t ================= e m p   *   P ⇒   P a p p l y a s t a r _ e l i m .</p><p>astar_elim是一个证明定理，其内容是：对所有P，emp ∗ P⇒P成立。应用astar_elim后，则不再有子目标，这意味着证明已完成。</p><p>Q e d .</p><p>最后，Qed检查证明是否完成。</p><p>注意到上面证明的规则可以被用来消去一些分离蕴含，那么以这样一个简单的设想为例，实现一个简单的策略，以展示如何使用交互式的机器证明代替手动证明。该策略称为sclearwand：</p><p>L t a c   s c l e a r w a n d   : = 1       m a t c h   g o a l   w i t h 2   |   |   −   ? s |=     ? ​ A ⇒   m a t c h   f i n d _ a w a n d   A   w i t h 3                       |     s o m e ? n ⇒ s e p _ l i f t   n ; 4                   m a t c h   g o a l   w i t h 5                         | H : _ |= _ |   −   _   |= ( ? B - ​ - ​ * ? B ) * ? C ⇒   6                           ​ ​   a p p l y   a s t a r _ l _ a e m p _ i n t r o   i n   H ; 7                             e a p p l y   a s t a r _ m o n o ; [ e a p p l y   a w a n d _ e m p     |   8                             i n t r o s   s '   H ' ;   e x a c t   H '     |     a u t o ] ;   s c l e a r w a n d 9                           |   _ ⇒ i d t a c 10                     e n d 1 1                       |     _ ⇒ i d t a c 12                     e n d 13     ​ |     _ ⇒ f a i l   14       e n d .  </p><p>首先匹配目标的模式，如果目标是类似于第2行的模式，则在第3行中，调用find_awand以查找A中分离蕴涵的位置。在第3行中，sep_lift将其移至A的左侧，随后证明目标将在第5~11行中解决，其中astar_l_aemp_intro和astar_mono分别是如下规则：</p><p>P ⇒ emp ∗ P   P ⇒ P ′     Q ⇒ Q ′ P ∗ Q ⇒ P ′ ∗ Q ′</p><p>sclearwand可以消除(P −∗ P)，之后“emp”将在证明目标中取代它，例如：</p><p>G o a l ​   f o r a l l   (   A   B :   a s r t   ) ,   A ⇒ A * ( B - ​ * B ) . P r o o f .     i n t r o s .     s c l e a r w a n d .     Q e d .</p><p>现在，考虑下面的推理规则并在Coq中证明其整确定性</p><p>P ′ ⇒ P   Q ⇒ Q ′ P - ​ - ​ ∗ Q ⇒ P ′ - ​ - ​ ∗ Q ′</p><p>T h e o r e m   a w a n d _ p r o : f o r a l l   P     P '     Q     Q ' , P ' ⇒ P → Q ⇒ Q ' → P - ​ - ​ * Q ⇒ P ' - ​ - ​ * Q ' . P r o o f .   i n t r o s . s i m p l   i n   *   ;     m y t a c .   d o   3   e e x i s t s ;   m y t a c ; e a u t o . Q e d .</p><p>mytac是原有系统中用于断言的自动证明策略，而上面的规则可以使用mytac证明，说明分离蕴含已被很好的添加到系统中。</p><p>仍然有很多关于分离蕴含的推理规则如下，在这里省略对他们的可靠性证明：</p><p>Q ∗ ( Q - ​ - ​ ∗ P ) ⇒ P   P ⇒ Q ∗ ( Q - ​ - ​ ∗ P )     ( P ∗ R ) ⇒ ( P ∗ ( Q - ​ - ​ ∗ ( Q ∗ R ) ) )       P 0 ⇒ ( Q - ​ - ​ ∗ R )   P 1 ⇒ ( R - ​ - ​ ∗ S ) P 0 ∗ P 1 ⇒ ( Q - ​ - ​ ∗ S )         P ⇒ P ′ P ∗ ( P ′ - ​ - ​ ∗ Q ) ⇒ Q</p></sec><sec id="s6_2"><title>4.2. 资源检测</title><p>在 [<xref ref-type="bibr" rid="hanspub.33919-ref5">5</xref>] 提供的实用策略可以仅使用一行证明脚本证明整个程序，即“repeat hoare forward; sep pure”，其中repeat表示重复执行某项策略，这里指重复执行“hoare forward; sep pure”，sep pure是证明关于纯断言的策略，而hoare forward可以证明霍尔三元组⊢{P} c {Q}，是验证程序的的关键。</p><p>hoare forward的第一步是资源检测(check_resource)，它检测前置条件是否具有语句执行所需的信息。例如：</p><p>{ y &gt; ​ ​ ​ → __} y : = x {       x &gt; ​ ​ ​ → __ ∗     y &gt; ​ ​ ​ → __}</p><p>其中 x ↣ v 表示变量x的值为v。显然，如果将x的值赋给y我们首先需要x的值。这里，resource_check在前置条件中没有找到有关x的信息，它将返回一条用户友好的消息，用户可以根据将相应的信息添加前置条件中，如下：</p><p>{ x &gt; ​ ​ ​ → __ ∗ y &gt; ​ ​ ​ → __} y : = x     {     x &gt; ​ ​ ​ → __ ∗ y &gt; ​ ​ ​ → _}</p><p>这就像开始验证前的预处理一样。然而，尽管如上一节所述分离蕴含已经被添加到系统中，并且前置条件中具有足够的信息，resource_check也无法检测到有关分离蕴含的信息，例如：</p><p>{   x   &gt; ​ ​ ​ →   __   ∗   ( x   &gt; ​ ​ ​ →   v 1     - ​ - ​ ∗     y   &gt; ​ ​ ​ →   _ )   }   x : = v 1   ;   y : =   v 2   {   y   &gt; ​ ​ ​ →   v 2   }</p><p>前置条件中虽然存在 y ↣ _ ，但无法被识别。因此，我们需要调整resource_check的组件使得分离蕴含可以被识别并可以从中检测到需要的信息。</p><p>考虑resource_check的组件find_match_retV，它可以识别“∗”，但无法识别“−∗”，如下：</p><p>L t a c   f i n d _ m a t c h _ r e t V     H p     x : =     1   m a t c h     H p     w i t h     2     |     ? A     *   ? B ⇒ m a t c h     f i n d _ m a t c h _ r e t V     A     x     w i t h     3                 |     s o m e   ? v ⇒   c o n s t r :   ( s o m e   v )       4                 |     _ ⇒ m a t c h     f i n d _ m a t c h _ r e t V     B     x     w i t h     5                       |     s o m e   ? v ⇒     c o n s t r :   ( s o m e   v )     6                                   |     _ ⇒   c o n s t r :   ( @ N o n e )     7                             e n d     8                             e n d     9         |     ? A     ⇒   ( *   h o a r e _ t a c t i c s . v   *   )     10   e n d .</p><p>将其更改如下：</p><p>L t a c   f i n d _ m a t c h _ r e t V '     H p     x : =     1   m a t c h     H p     w i t h     2     |     ? A     *     ? B ⇒ m a t c h     f i n d _ m a t c h _ r e t V     A     x     w i t h     3                           |     s o m e   ? v ⇒   c o n s t r :   ( s o m e   v )     4                             |     _ ⇒ m a t c h     f i n d _ m a t c h _ r e t V     B     x     w i t h     5                                       |     s o m e   ? v ⇒     c o n s t r :   ( s o m e   v )     6                                           |     _ ⇒   c o n s t r :   ( @ N o n e )     7                                 e n d     8                         e n d     9         |     ? C     - ​ - ​ *   ? D ⇒ m a t c h     f i n d _ m a t c h _ r e t V     C     x     w i t h     10                             |     s o m e   ? v ⇒     c o n s t r :   ( s o m e   v )     11                               |     _ ⇒   ( *     h o a r e _ t a c t i c s . v   * )     12                                 m a t c h     f i n d _ m a t c h _ r e t V     D     x     w i t h     13                                   |   s o m e   ? v ⇒   c o n s t r :   ( s o m e   v )     14                                     |     _ ⇒   c o n s t r :   ( @ N o n e )     15                             e n d     16                   e n d     17       |     ? A ⇒ ( *   h o a r e _ t a c t i c s . v   *   )     18     e n d .</p><p>将resource_check中的find_match_retV替换为find_match_retV'之后，上述 ，因此hoare forward可以正常开始运行。</p></sec></sec><sec id="s7"><title>5. 一个简单的例子</title><p>本节将给出一个简单的示例来表明，我们可以证明程序状态由含有分离蕴含的断言描述的程序规范。</p><p>sclearwand in是可以证明含有分离蕴含的断言的策略，例如，sclearwand in策略可以证明下面的证明目标：</p><p>G o a l ​   f o r a l l   (   A     B   D   E     :     a s r t   ) ,     (   A     *     D     *     B   )     *     (     (     D   *   A   *     B   )     - ​ - ​ *         E   )     ⇒       E . P r o o f .       i n t r o s .       s c l e a r w a n d _ i n H .       Q e d .</p><p>我们以一个简单的例子来说明它在程序验证中的作用，如下：</p><p>{   x   &gt; ​ ​ ​ →   v 1 ∗     ( x   &gt; ​ ​ ​ →   n u l l - ​ - ​ ∗ y   &gt; ​ ​ ​ →   v 2 )   } x : = n u l l ; { y &gt; ​ ​ ​ → v 2 }</p><p>这里，运行“repeat hoare forward; sep pure”后得到一个子目标：</p><p>( x &gt; ​ ​ ​ → n u l l   ∗     ( x &gt; ​ ​ ​ → n u l l - ​ - ​ ∗ y &gt; ​ ​ ​ → v 2 ) )   ⇒   ( y &gt; ​ ​ ​ → v 2 )</p><p>运行“sclearwand in H”，该子目标被解决，证明完成。</p></sec><sec id="s8"><title>6. 总结</title><p>我们通过添加分离蕴含操作符到已有系统的分离逻辑断言语法中，拓展了该验证系统，并提供了一些相关的自动证明策略。但是由于分离逻辑断言的复杂多样性，我们现有的策略不足以解决包含分离蕴涵的断言的所有证明。将来，我们将扩展自动证明策略以提高程序验证的效率。</p></sec><sec id="s9"><title>文章引用</title><p>雷斯然,程梦奇,江建国. 分离逻辑断言的Coq证明策略Tactics for Proving Separation Logic Assertions in Coq[J]. 软件工程与应用, 2020, 09(01): 14-21. https://doi.org/10.12677/SEA.2020.91003</p></sec><sec id="s10"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.33919-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Hill, J. and Tilley, S. (2010) Creating Safety Requirement Traceability for Assuring and Recertifying Legacy Safe-ty-Critical Systems. 2010 18th IEEE International Requirements Engineering Conference, Sydney, 27 September-1 October 2010, 297-302. &lt;br&gt;https://doi.org/10.1109/RE.2010.42</mixed-citation></ref><ref id="hanspub.33919-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Hoare, C.A.R. (1969) An Axiomatic Basis for Computer Programming. Communications of the ACM, 12, 576-580.</mixed-citation></ref><ref id="hanspub.33919-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">O’Hearn, P.W., Reynolds, J.C. and Yang, H. (2001) Local Reasoning about Programs that Alter Data Structures. In: Fribourg, L., Ed., Computer Science Logic. CSL 2001. Lecture Notes in Computer Science, Springer, Berlin, Heidelberg, 1-19. &lt;br&gt;https://doi.org/10.1007/3-540-44802-0_1</mixed-citation></ref><ref id="hanspub.33919-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Reynolds, J.C. (2002) Separation Logic: A Logic for Shared Mu-table Data Structures. Proceedings of the 17th Annual IEEE Symposium on Logic in Computer Science, Copenhagen, 22-25 July 2002, 55-74. &lt;br&gt;https://doi.org/10.1109/LICS.2002.1029817</mixed-citation></ref><ref id="hanspub.33919-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Chlipala, A. (2013) The Bedrock Structured Programming System: Combining Generative Metaprogramming and Hoare Logic in an Extensible Program Verifier. Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming, September 2013, 391-402. &lt;br&gt;https://doi.org/10.1145/2500365.2500592</mixed-citation></ref><ref id="hanspub.33919-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Jensen, J.B., Benton, N. and Kennedy, A. (2013) High-Level Separation Logic for Low-Level Code. ACM SIGPLAN Notices, 48, 301-314. &lt;br&gt;https://doi.org/10.1145/2429069.2429105</mixed-citation></ref><ref id="hanspub.33919-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Krebbers, R. (2015) The C Standard Formalized in Coq. Ph.D. Dissertation, Radboud University, Gelderland.</mixed-citation></ref><ref id="hanspub.33919-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Sergey, I., Nanevski, A. and Banerjee, A. (2015) Mechanized Verification of Fine-Grained Concurrent Programs. ACM SIGPLAN Notices, 50, 77-87.</mixed-citation></ref><ref id="hanspub.33919-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Tuch, H., Klein, G. and Norrish, M. (2007) Types, Bytes, and Separation Logic. ACM SIGPLAN Notices, 42, 97-108.&lt;br&gt;https://doi.org/10.1145/1190215.1190234</mixed-citation></ref><ref id="hanspub.33919-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">The Coq Development Team: The Coq Proof Assistant. &lt;br&gt;http://coq.inria.fr</mixed-citation></ref><ref id="hanspub.33919-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">Cao, Q., Beringer, L., Gruetter, S., Dodds, J. and Appel, A.W. (2018) VST-Floyd: A Sep-aration Logic Tool to Verify Correctness of C Programs. Journal of Automated Reasoning, 61, 367-422. &lt;br&gt;https://doi.org/10.1007/s10817-018-9457-5</mixed-citation></ref><ref id="hanspub.33919-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">McCreigh, A. (2009) Practical Tactics for Separation Logic. In: Berghofer, S., Nipkow, T., Urban, C. and Wenzel, M., Eds., Theorem Proving in Higher Order Logics. TPHOLs 2009. Lecture Notes in Computer Science, Springer, Berlin, Heidelberg, 343-358. &lt;br&gt; https://doi.org/10.1007/978-3-642-03359-9_24</mixed-citation></ref><ref id="hanspub.33919-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">Bengtson, J., Jensen, J.B. and Birkedal, L. (2012) Charge-A Framework for Higher-Order Separation Logic in Coq. In: Beringer, L. and Felty, A., Eds., Interactive Theorem Proving. ITP 2012. Lecture Notes in Computer Science, Springer, Berlin, Heidelberg, 315-331. &lt;br&gt; https://doi.org/10.1007/978-3-642-32347-8_21</mixed-citation></ref><ref id="hanspub.33919-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">Leroy, X. (2006) Formal Certification of a Complier Back-End, or: Programming a Complier with a Proof Assistant. Proceedings of the 33th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, SC, 11-13 January 2006, 42-54. &lt;br&gt;https://doi.org/10.1145/1111320.1111042</mixed-citation></ref><ref id="hanspub.33919-ref15"><label>15</label><mixed-citation publication-type="other" xlink:type="simple">Appel, A.W., Dockins, R., Hobor, A., Beringer, L., Dodds, J., Stewart, G., Blazy, S. and Leroy, X. (2014) Program Logics for Certified Compilers. University of Cambridge Press, New York.</mixed-citation></ref><ref id="hanspub.33919-ref16"><label>16</label><mixed-citation publication-type="other" xlink:type="simple">Delahaye, D. (2000) A Tactic Language for the System Coq. In: Parigot, M. and Voronkov, A., Eds., Logic for Programming and Automated Reasoning. LPAR 2000. Lecture Notes in Artificial Intelligence, Springer, Berlin, Heidelberg, 85-95. &lt;br&gt; https://doi.org/10.1007/3-540-44404-1_7</mixed-citation></ref><ref id="hanspub.33919-ref17"><label>17</label><mixed-citation publication-type="other" xlink:type="simple">Cao, J., Fu, M. and Feng, X. (2015) Practical Tactics for Verifying C Programs in Coq. Proceedings of the 2015 Conference on Certified Programs and Proofs, Mumbai, India, 15-17 January 2015, 97-108. &lt;br&gt;https://doi.org/10.1145/2676724.2693162</mixed-citation></ref></ref-list></back></article>