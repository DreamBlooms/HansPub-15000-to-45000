<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2016.611086</article-id><article-id pub-id-type="publisher-id">CSA-19030</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20161100000_14887424.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  基于Spark的动态聚类算法研究
  Research on Dynamic Clustering Algorithm Based on Spark Framework
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>张</surname><given-names>伯涛</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>李</surname><given-names>建华</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>范</surname><given-names>磊</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><addr-line>上海交通大学信息安全工程学院，上海</addr-line></aff><aff id="aff2"><addr-line>null</addr-line></aff><author-notes><corresp id="cor1">* E-mail:<email>retropoktan@sjtu.edu.cn(张伯)</email>;</corresp></author-notes><pub-date pub-type="epub"><day>09</day><month>11</month><year>2016</year></pub-date><volume>06</volume><issue>11</issue><fpage>715</fpage><lpage>727</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   针对数据流的聚类算法，近年来取得了有效的进展，出现了许多卓有成效的算法。随着信息采集技术的进步，需要处理的数据量越来越大，需要研究针对数据流的并行聚类算法。本文基于串行的数据流聚类算法D-Stream作出并行化改进，用通用的大数据处理框架Spark设计了一个基于分布式架构运行的动态数据聚类算法PDStream。实验结果表明，该算法具有更高的效率和良好的扩展性，能够实现分布式架构下的流数据动态聚类。 In the era of big data, with the rapid growth of data size, the requirements of data processing in-crease constantly. It has put forward many effective algorithms for data stream clustering these years. However, with the continuous development of social technology, single machine environ-ment has been difficult to meet the needs of data mining. Cluster environment is used more for information collection and data processing, the traditional clustering algorithm does not adapt well to the new processing requirements. This paper made some improvements from the data stream clustering algorithm D-Stream, used the big data processing framework Spark and designed a dynamic data clustering algorithm PDStream based on distributed architecture. The new algorithm is proved to be more efficient and able to perform dynamic clustering tasks under distributed architecture from the results of experiment.
    
  
 
</p></abstract><kwd-group><kwd>D-Stream，PDStream，Spark，动态聚类算法, D-Stream</kwd><kwd> PDStream</kwd><kwd> Spark</kwd><kwd> Dynamic Clustering Algorithm</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>基于Spark的动态聚类算法研究<sup> </sup></title><p>张伯涛，李建华，范磊</p><p>上海交通大学信息安全工程学院，上海</p><disp-formula id="hanspub.19030-formula1"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>收稿日期：2016年11月4日；录用日期：2016年11月21日；发布日期：2016年11月24日</p><disp-formula id="hanspub.19030-formula2"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x7_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>针对数据流的聚类算法，近年来取得了有效的进展，出现了许多卓有成效的算法。随着信息采集技术的进步，需要处理的数据量越来越大，需要研究针对数据流的并行聚类算法。本文基于串行的数据流聚类算法D-Stream作出并行化改进，用通用的大数据处理框架Spark设计了一个基于分布式架构运行的动态数据聚类算法PDStream。实验结果表明，该算法具有更高的效率和良好的扩展性，能够实现分布式架构下的流数据动态聚类。</p><p>关键词 :D-Stream，PDStream，Spark，动态聚类算法</p><disp-formula id="hanspub.19030-formula3"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x8_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s3"><title>1. 引言</title><p>当今社会信息化的发展，在生物工程、新能源、企业医疗等新领域出现了海量的数据。由于这些数据持续不断产生，随着时间动态无限增长，近似呈现一种“流”的形态，因此此类数据被称为流数据。针对流数据进行数据挖掘是当前的热门课题。聚类作为数据挖掘领域的一个重要分支，一直以来倍受关注并得到了学者们广泛、深入的研究。它作为一种无监督的学习方式，在数据挖掘过程中能根据数据间的相似性将待处理对象划分为一个或若干个簇，在网络入侵检测、挖掘潜在客户和分析市场情况等方面具有重要应用。</p><p>针对流数据的聚类分析因其诸多特点变得相对困难，主要体现在三个方面：1) 低时空复杂度。数据流源源不断地产生且高速到达，它的海量、无限性要求算法不能够存储全部数据，每个数据项的处理也不能花费过长时间，算法在线处理速度应尽量和数据流的流速相匹配。2) 增量的处理新数据。由于流数据数量巨大，数据量未知，因此近乎不可能重复计算原有数据，算法必须能够在已有结果基础上增量处理新的数据。3) 正确、快速的处理离群点。数据流具有不断演化的特性，随着时间的推移数据流可能会不断地改变趋势，算法应能够清晰、快速地识别离群点，且对离群点做出正确的处理。</p><p>近年来，已经有许多优秀的流数据聚类算法诞生，他们有各自的处理要求和特点。CluStream [<xref ref-type="bibr" rid="hanspub.19030-ref1">1</xref>] 算法是一个基于层次的流数据聚类算法，它首次将数据流的处理框架分为在线层和离线层，并引入聚类特征向量来表示聚簇，且采用预先定义的距离阈值来衡量数据项是否属于已知类。DenStream [<xref ref-type="bibr" rid="hanspub.19030-ref2">2</xref>] 是一个基于密度的流数据聚类算法，该算法将满足一定密度阈值的数据点划分为一个簇，且能够发现球状簇，但该算法对输入参数敏感，参数的变化将严重影响聚类结果，且聚类过程中需要对每个数据对象进行邻域检查，因而计算时间复杂度较大。D-Stream [<xref ref-type="bibr" rid="hanspub.19030-ref3">3</xref>] 是一个基于网格密度的算法，它将空间划分成一个个离散的网格，将进入系统中的数据映射到对应的网格中，然后操纵这些网格的信息，并将密度较大的相邻网格合并为一个聚簇。DENGRIS-Stream [<xref ref-type="bibr" rid="hanspub.19030-ref4">4</xref>] 同样是一个基于网格密度的流数据聚类算法，但是它额外加入了滑动窗口，使得聚簇结果消除了历史数据的影响。ExCC [<xref ref-type="bibr" rid="hanspub.19030-ref5">5</xref>] 是一个针对混合属性设计的算法，属性中包含数字和非数字，它对相邻网格的概念进行了重新定义，使得它适应非数字属性，并且依据数据流速的不同来决定消除历史数据的规模。FlockStream [<xref ref-type="bibr" rid="hanspub.19030-ref6">6</xref>] 是一个基于密度的算法，它基于群体智能 [<xref ref-type="bibr" rid="hanspub.19030-ref7">7</xref>] ，给每个输入数据指定一个代理，代理在一个提前定义好的虚拟空间中移动，当两个代理相遇则将他们合并为一个聚簇，该算法合并了在线层和离线层，在任何时间都可能生成新的聚簇。以上这些流聚类算法有各自适用的环境，在实际运用中需要针对业务的特点合理进行选择。</p><p>随着集群技术、并行计算与分布式计算的发展，Hadoop [<xref ref-type="bibr" rid="hanspub.19030-ref8">8</xref>] 分布式计算框架和Spark [<xref ref-type="bibr" rid="hanspub.19030-ref9">9</xref>] 内存计算框架等的广泛应用，为解决大规模流数据的实时挖掘带来了曙光。由于传统流聚类算法大都不适用分布式环境，本文提出了一种PDStream算法，它基于Spark中的Spark Streaming [<xref ref-type="bibr" rid="hanspub.19030-ref10">10</xref>] 模块，对传统的数据流聚类算法D-Stream做出了相关改进，它保持了D-Stream算法的优越性，并在此基础上能够适应分布式环境。</p></sec><sec id="s4"><title>2. 相关工作</title><sec id="s4_1"><title>2.1. 基于网格的流式聚类算法</title><p>假定数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x9_hanspub.png" xlink:type="simple"/></inline-formula>包含<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x10_hanspub.png" xlink:type="simple"/></inline-formula>个维度，则<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x11_hanspub.png" xlink:type="simple"/></inline-formula>，其中<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x12_hanspub.png" xlink:type="simple"/></inline-formula>表示第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x13_hanspub.png" xlink:type="simple"/></inline-formula>维子空间。在D-Stream算法中，数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x14_hanspub.png" xlink:type="simple"/></inline-formula>划分为一个个网格，假定每个子空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x15_hanspub.png" xlink:type="simple"/></inline-formula>被划分为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x16_hanspub.png" xlink:type="simple"/></inline-formula>个部分，即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x17_hanspub.png" xlink:type="simple"/></inline-formula>，则整个数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x18_hanspub.png" xlink:type="simple"/></inline-formula>可以划分的网格数为：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x19_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>其中，网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x20_hanspub.png" xlink:type="simple"/></inline-formula>由<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x21_hanspub.png" xlink:type="simple"/></inline-formula>组成，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x22_hanspub.png" xlink:type="simple"/></inline-formula>，网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x23_hanspub.png" xlink:type="simple"/></inline-formula>坐标定义为：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x24_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>数据流中的数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x25_hanspub.png" xlink:type="simple"/></inline-formula>分别在时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x26_hanspub.png" xlink:type="simple"/></inline-formula>进入系统，数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x27_hanspub.png" xlink:type="simple"/></inline-formula>的时间戳为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x28_hanspub.png" xlink:type="simple"/></inline-formula>。其中每一个数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x29_hanspub.png" xlink:type="simple"/></inline-formula>包含<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x30_hanspub.png" xlink:type="simple"/></inline-formula>维数据，则数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x31_hanspub.png" xlink:type="simple"/></inline-formula>可以映射到网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x32_hanspub.png" xlink:type="simple"/></inline-formula>中，即</p><disp-formula id="hanspub.19030-formula4"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x33_hanspub.png"  xlink:type="simple"/></disp-formula><p>随着时间的推进，数据流输入的数据规模将非常庞大，历史数据的影响力依然存在。假定新数据的聚类更需要关心，历史数据的影响力需要逐渐变小，则有如下定义。</p><p>定义2.1：定义衰减系数<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x34_hanspub.png" xlink:type="simple"/></inline-formula>，对于数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x35_hanspub.png" xlink:type="simple"/></inline-formula>，它在时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x36_hanspub.png" xlink:type="simple"/></inline-formula>进入系统，则它在时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x37_hanspub.png" xlink:type="simple"/></inline-formula>的密度系数为</p><disp-formula id="hanspub.19030-formula5"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x38_hanspub.png"  xlink:type="simple"/></disp-formula><p>每个网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x39_hanspub.png" xlink:type="simple"/></inline-formula>在时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x40_hanspub.png" xlink:type="simple"/></inline-formula>对应的密度系数为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x41_hanspub.png" xlink:type="simple"/></inline-formula>包含的所有数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x42_hanspub.png" xlink:type="simple"/></inline-formula>的密度系数之和，即</p><disp-formula id="hanspub.19030-formula6"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x43_hanspub.png"  xlink:type="simple"/></disp-formula><p>定义2.1定义了网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x44_hanspub.png" xlink:type="simple"/></inline-formula>关于时间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x45_hanspub.png" xlink:type="simple"/></inline-formula>的密度系数。对于每个时刻<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x46_hanspub.png" xlink:type="simple"/></inline-formula>，如果网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x47_hanspub.png" xlink:type="simple"/></inline-formula>没有接受新的数据，则它的密度系数会进行衰减。如果网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x48_hanspub.png" xlink:type="simple"/></inline-formula>最后一次在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x49_hanspub.png" xlink:type="simple"/></inline-formula>时刻接收了数据并更新了密度系数，在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x50_hanspub.png" xlink:type="simple"/></inline-formula>时刻<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x51_hanspub.png" xlink:type="simple"/></inline-formula>再次接收了一个数据，则密度系数<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x52_hanspub.png" xlink:type="simple"/></inline-formula>可被更新为</p><disp-formula id="hanspub.19030-formula7"><graphic xlink:href="http://html.hanspub.org/file/10-1540665x53_hanspub.png"  xlink:type="simple"/></disp-formula><p>这样仅在网格接收新数据的时刻更新网格密度系数，节省了大量的计算时间，提高了效率。有了密度系数，对网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x54_hanspub.png" xlink:type="simple"/></inline-formula>的密度进行划分是基于以下的观察：</p><p>命题2.1让从0时刻到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x55_hanspub.png" xlink:type="simple"/></inline-formula>时刻到达的所有数据记录成为一个集合，则：</p><p>1) <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x56_hanspub.png" xlink:type="simple"/></inline-formula></p><p>2) <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x57_hanspub.png" xlink:type="simple"/></inline-formula></p><p>命题2.1表明系统中所有数据记录的密度总和永远不会超过<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x58_hanspub.png" xlink:type="simple"/></inline-formula>。由于存在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x59_hanspub.png" xlink:type="simple"/></inline-formula>个网格，因此每个网格的平均密度不会超过<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x60_hanspub.png" xlink:type="simple"/></inline-formula>。基于这个观察，有以下定义：</p><p>定义2.2在时刻<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x61_hanspub.png" xlink:type="simple"/></inline-formula>，如果网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x62_hanspub.png" xlink:type="simple"/></inline-formula>的密度系数满足：</p><p>1)<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x63_hanspub.png" xlink:type="simple"/></inline-formula>，则网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x64_hanspub.png" xlink:type="simple"/></inline-formula>为稠密网格，它的status标签设为dense。其中，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x65_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>2)<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x66_hanspub.png" xlink:type="simple"/></inline-formula>，则网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x67_hanspub.png" xlink:type="simple"/></inline-formula>为稀疏网格，它的status标签设为sparse。其中，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x68_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>3)<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x69_hanspub.png" xlink:type="simple"/></inline-formula>，则网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x70_hanspub.png" xlink:type="simple"/></inline-formula>为过渡网格，它的status标签设为transitional。</p><p>对网格的密度进行定义后，相邻的密度较大的网格将被合并到一个聚簇中，对于相邻网格有如下定义：</p><p>定义2.3考虑两个网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x71_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x72_hanspub.png" xlink:type="simple"/></inline-formula>，如果存在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x73_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x74_hanspub.png" xlink:type="simple"/></inline-formula>，使得：</p><p>1)<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x75_hanspub.png" xlink:type="simple"/></inline-formula>，</p><p>2) <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x76_hanspub.png" xlink:type="simple"/></inline-formula></p><p>那么<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x77_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x78_hanspub.png" xlink:type="simple"/></inline-formula>被称为相邻网格，他们在第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x79_hanspub.png" xlink:type="simple"/></inline-formula>维上相邻。</p></sec><sec id="s4_2"><title>2.2. D-Stream算法框架</title><p>D-Stream是一种典型的基于网格密度的聚类算法，它把空间区域<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x80_hanspub.png" xlink:type="simple"/></inline-formula>划分为一个个离散的网格，将新来的数据映射到对应的网格。这样不需要关心原始数据，只要对网格特征向量数据进行相关操作，最终得出聚类结果。D-Stream算法框架分为在线部分和离线部分，在线部分用于接收数据流，将数据对应的网格信息进行更新；离线部分定期取出在线部分的数据，通过聚类算法进行聚类和调整，最终将结果输出。</p><p>D-Stream在线部分负责接收数据流，更新数据所在网格的特征向量。对于每个网格的当前状态，在D-Stream算法中，有如下特征向量进行表示：</p><p>定义2.4网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x81_hanspub.png" xlink:type="simple"/></inline-formula>的特征向量为一个四元组：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x82_hanspub.png" xlink:type="simple"/></inline-formula>，代表含义分别为：</p><p> <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x83_hanspub.png" xlink:type="simple"/></inline-formula>：网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x84_hanspub.png" xlink:type="simple"/></inline-formula>最后接收到数据的时间。</p><p> <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x85_hanspub.png" xlink:type="simple"/></inline-formula>：即为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x86_hanspub.png" xlink:type="simple"/></inline-formula>的值，记录网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x87_hanspub.png" xlink:type="simple"/></inline-formula>最后更新后的密度系数</p><p> <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x88_hanspub.png" xlink:type="simple"/></inline-formula>：表示网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x89_hanspub.png" xlink:type="simple"/></inline-formula>密度的划分，取值范围是<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x90_hanspub.png" xlink:type="simple"/></inline-formula></p><p> <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x91_hanspub.png" xlink:type="simple"/></inline-formula>：表示网格的聚簇标签</p><p>每当一个新数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x92_hanspub.png" xlink:type="simple"/></inline-formula>在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x93_hanspub.png" xlink:type="simple"/></inline-formula>进入系统时，首先找到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x94_hanspub.png" xlink:type="simple"/></inline-formula>所属的网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x95_hanspub.png" xlink:type="simple"/></inline-formula>，并更新网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x96_hanspub.png" xlink:type="simple"/></inline-formula>加入数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x97_hanspub.png" xlink:type="simple"/></inline-formula>后的特征向量：记录数据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x98_hanspub.png" xlink:type="simple"/></inline-formula>的时间戳为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x99_hanspub.png" xlink:type="simple"/></inline-formula>，并依据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x100_hanspub.png" xlink:type="simple"/></inline-formula>更新网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x101_hanspub.png" xlink:type="simple"/></inline-formula>的密度系数，同时将<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x102_hanspub.png" xlink:type="simple"/></inline-formula>更新为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x103_hanspub.png" xlink:type="simple"/></inline-formula>，label依据<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x104_hanspub.png" xlink:type="simple"/></inline-formula>的值并对比阈值<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x105_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x106_hanspub.png" xlink:type="simple"/></inline-formula>确定值为sparse、transitional或dense。这样，在线层完成了空间中网格特征向量的更新，为离线部分的聚类过程做好了准备工作。</p><p>D-Stream算法的主要思想就是将密度较大的相邻网格连成聚簇，由于生成聚簇的计算量较大，实时维护一个聚类结果是相当困难的。基于这个事实，算法离线部分在每隔<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x107_hanspub.png" xlink:type="simple"/></inline-formula>时间，对聚簇结果进行一次维护。D-Stream的离线部分就是基于这个思想，考虑当前时间为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x108_hanspub.png" xlink:type="simple"/></inline-formula>，在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x109_hanspub.png" xlink:type="simple"/></inline-formula>之前，算法已经维护了一个聚簇结果，而在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x110_hanspub.png" xlink:type="simple"/></inline-formula>时间内，一批新的数据进入了系统，算法将这批数据对原有聚簇产生的影响增量地加入其中，产生新的聚簇结果。</p><p>一个稠密网格长期不接受数据，可能会变成稀疏网格；一个稀疏网格接收一些新的数据，也可能升级为一个过渡网格或稠密网格，因此，一个关键点是决定离线部分生成聚簇的时间间隔<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x111_hanspub.png" xlink:type="simple"/></inline-formula>的长度，如果<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x112_hanspub.png" xlink:type="simple"/></inline-formula>太大，那么数据流的动态变化不能很好地识别过来；如果<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x113_hanspub.png" xlink:type="simple"/></inline-formula>太小，则导致离线部分频繁计算从而增加了负载。因此，根据D-Stream [<xref ref-type="bibr" rid="hanspub.19030-ref2">2</xref>] 中的描述使用以下命题来确定<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x114_hanspub.png" xlink:type="simple"/></inline-formula>：</p><p>命题2.2：对任何稠密网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x115_hanspub.png" xlink:type="simple"/></inline-formula>，从稠密网格成为一个稀疏网格所需的最少时间是<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x116_hanspub.png" xlink:type="simple"/></inline-formula>；而对任何稀疏网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x117_hanspub.png" xlink:type="simple"/></inline-formula>，从稀疏网格成为一个稠密网格所需的最少时间是<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x118_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>因此，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x119_hanspub.png" xlink:type="simple"/></inline-formula>设置为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x120_hanspub.png" xlink:type="simple"/></inline-formula>，这样能够识别一个网格状态的任何变化。</p></sec><sec id="s4_3"><title>2.3. Spark和Spark Streaming</title><p>Spark是加州大学伯克利分校的AMP实验室所开源的类似MapReduce的通用并行计算框架，它拥有MapReduce的优点，并且由于Spark将中间计算结果的读写操作都在内存中进行，从而不需要读写HDFS，也不负责数据的存储，这样能够更好地优化迭代MapReduce工作的负载。</p><p>Spark对于数据的处理是基于弹性数据集RDD，它是一个不可变的带分区的记录集合。Spark为RDD提供了两类操作：转换和动作，转换是对原有的RDD进行一些变换来生成一个新的RDD，而动作则是返回一个结果。一个job可以拆分成RDD经过一系列的变换操作得到最终的结果，也就是可以拆分成RDD组成的有向无环图DAG (如图1)，并将这个DAG作为一个job提交给Spark执行。</p><p>Spark Streaming是一种构建在Spark上的实时计算框架，它扩展了Spark处理大规模流式数据的能力，它的基本原理是将输入数据流以时间片<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x121_hanspub.png" xlink:type="simple"/></inline-formula>为单位拆分成块，然后以类似Spark批处理的方式将每块数据作为RDD生成一个job进行处理，最终结果也返回多块。</p><p>Spark Streaming具有高容错性，每一批输入到RDD中的数据都会在内存中备份，当某个结点发生故障导致数据丢失时，Spark Streaming计算框架会找到备份的数据并在其他结点上重新计算得到最终的结果。</p><p>随着大数据的发展，人们对大数据处理提出了更高的要求。原有的批处理框架MapReduce由于其所有中间结果数据的读写都需要经过HDFS文件系统，因此启动一次job的代价很高，难以满足实时性要求。而Spark Streaming是Spark处理流式数据的框架，使用基于内存的Spark作为执行引擎，具有高速的执行效率和极低的延迟，对流数据的处理有极好的支持。</p></sec></sec><sec id="s5"><title>3. 分布式流聚类算法PDStream设计</title><p>结合Spark Streaming框架和D-Stream算法，本节提出一种基于分布式环境下的流数据聚类算法 PDStream。该算法将数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x122_hanspub.png" xlink:type="simple"/></inline-formula>划分为不同的块，对每个块运用D-Stream算法进行处理，得到该块的聚簇结果，最后将所有块的聚簇进行合并，生成最终的聚簇结果。</p><p>图1. Spark Job执行过程</p><sec id="s5_1"><title>3.1. 相关定义</title><p>定义3.1数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x124_hanspub.png" xlink:type="simple"/></inline-formula>包含<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x125_hanspub.png" xlink:type="simple"/></inline-formula>个维度，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x126_hanspub.png" xlink:type="simple"/></inline-formula>，而对每个子空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x127_hanspub.png" xlink:type="simple"/></inline-formula>的一个连续子集<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x128_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x129_hanspub.png" xlink:type="simple"/></inline-formula>可以组成一个较小的数据空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x130_hanspub.png" xlink:type="simple"/></inline-formula>，该空间被定义为块。</p><p>定义3.2 块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x131_hanspub.png" xlink:type="simple"/></inline-formula>在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x132_hanspub.png" xlink:type="simple"/></inline-formula>维空间中可以表示为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x133_hanspub.png" xlink:type="simple"/></inline-formula>，将每个子空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x134_hanspub.png" xlink:type="simple"/></inline-formula>划分为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x135_hanspub.png" xlink:type="simple"/></inline-formula>个部分，则整个块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x136_hanspub.png" xlink:type="simple"/></inline-formula>可以划分的网格数为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x137_hanspub.png" xlink:type="simple"/></inline-formula>。设<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x138_hanspub.png" xlink:type="simple"/></inline-formula>表示块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x139_hanspub.png" xlink:type="simple"/></inline-formula>中的网格<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x140_hanspub.png" xlink:type="simple"/></inline-formula>在第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x141_hanspub.png" xlink:type="simple"/></inline-formula>个维度的相邻网格数，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x142_hanspub.png" xlink:type="simple"/></inline-formula>。若存在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x143_hanspub.png" xlink:type="simple"/></inline-formula>，则<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x144_hanspub.png" xlink:type="simple"/></inline-formula>是块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x145_hanspub.png" xlink:type="simple"/></inline-formula>的一个边界网格。</p><p>定义3.3 若构成块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x146_hanspub.png" xlink:type="simple"/></inline-formula>和块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x147_hanspub.png" xlink:type="simple"/></inline-formula>的第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x148_hanspub.png" xlink:type="simple"/></inline-formula>维子空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x149_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x150_hanspub.png" xlink:type="simple"/></inline-formula>在第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x151_hanspub.png" xlink:type="simple"/></inline-formula>维上相邻，则块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x152_hanspub.png" xlink:type="simple"/></inline-formula>和块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x153_hanspub.png" xlink:type="simple"/></inline-formula>是相邻块。</p></sec><sec id="s5_2"><title>3.2. PDStream算法流程</title><p>在算法运行之前，将空间<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x154_hanspub.png" xlink:type="simple"/></inline-formula>划分为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x155_hanspub.png" xlink:type="simple"/></inline-formula>个互不相交的块，即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x156_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x157_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x158_hanspub.png" xlink:type="simple"/></inline-formula>。对每个块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x159_hanspub.png" xlink:type="simple"/></inline-formula>分别运行D-Stream算法。PDStream算法流程如算法1。</p><p>对于块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x160_hanspub.png" xlink:type="simple"/></inline-formula>处理模块，运行D-Stream算法，它分为在线层和离线层。在线层<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x161_hanspub.png" xlink:type="simple"/></inline-formula>_online_component负责接收数据，保存网格的特征向量；离线层<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x162_hanspub.png" xlink:type="simple"/></inline-formula>_offline_component每隔<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x163_hanspub.png" xlink:type="simple"/></inline-formula>时间生成<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x164_hanspub.png" xlink:type="simple"/></inline-formula>内部的聚簇。当所有块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x165_hanspub.png" xlink:type="simple"/></inline-formula>的聚簇生成完毕后，所有分块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x166_hanspub.png" xlink:type="simple"/></inline-formula>的聚簇结果需要进行合并，合并算法过程如算法2。</p><p>Algorithm 1. PDStream</p><p>算法1. PDStream</p><p>Algorithm 2. Merge sub-clustering</p><p>算法2. 合并分块聚簇</p></sec><sec id="s5_3"><title>3.3. 基于并查集的优化</title><p>应当注意到，算法中经常涉及到将两个聚簇进行合并或者将某个网格合并到聚簇的操作。在实际代码编写中，每个网格需要设置它所属的聚簇标签，当需要将聚簇c<sub>1</sub>合并到c<sub>2</sub>中时，程序会将c<sub>1</sub>中所有的网格所属的聚簇标签修改为c<sub>2</sub>，当这样的操作一旦大量增加，将会成为算法的瓶颈。使用并查集可以对上述操作进行优化，避免大量的修改。并查集是一种森林结构，用于处理一些不相交集合的合并及查询问题，核心思想是用一个代表元素表示集合中的所有元素，即森林中每棵树的根结点表示该树的所有结点，并且进行查找操作时可以进行路径压缩，将查找路径中每个结点直接连接至该树的根节点，提高再次查找的效率。当需要将结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x202_hanspub.png" xlink:type="simple"/></inline-formula>和结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x203_hanspub.png" xlink:type="simple"/></inline-formula>合并至一个集合时，先找到结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x204_hanspub.png" xlink:type="simple"/></inline-formula>的祖先结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x205_hanspub.png" xlink:type="simple"/></inline-formula>和结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x206_hanspub.png" xlink:type="simple"/></inline-formula>的祖先结点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x207_hanspub.png" xlink:type="simple"/></inline-formula>，将<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x208_hanspub.png" xlink:type="simple"/></inline-formula>变为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x209_hanspub.png" xlink:type="simple"/></inline-formula>的孩子结点，这样就将两颗树代表的集合进行了合并，新树的根<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x210_hanspub.png" xlink:type="simple"/></inline-formula>节点即为集合合并后的代表结点。</p><p>如图2，有三个块：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x211_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x212_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x213_hanspub.png" xlink:type="simple"/></inline-formula>，其中块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x214_hanspub.png" xlink:type="simple"/></inline-formula>中有聚簇c<sub>1</sub>、c<sub>2</sub>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x215_hanspub.png" xlink:type="simple"/></inline-formula>中有聚簇c<sub>3</sub>、c<sub>4</sub>、c<sub>5</sub>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x216_hanspub.png" xlink:type="simple"/></inline-formula>中有聚簇c<sub>6</sub>、c<sub>7</sub>。</p><p>首先对于每个块内的聚簇，在森林F中生成自身结点进行初始化，表示每个聚簇自成一个集合。在进行相邻块聚簇的合并操作时，对于块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x217_hanspub.png" xlink:type="simple"/></inline-formula>，遍历它的右边边界网格时，发现聚簇c<sub>2</sub>和相邻块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x218_hanspub.png" xlink:type="simple"/></inline-formula>中的c<sub>3</sub>可以进行合并，于是在F中找到c<sub>2</sub>和c<sub>3</sub>，通过并查集的查找操作发现他们的祖先就是本身，并且并不属于同一个集合，则可将c<sub>2</sub>作为c<sub>3</sub>的孩子结点，表示聚簇c<sub>2</sub>和c<sub>3</sub>已经进行了合并，合并后的聚簇代表元为c<sub>3</sub>。在遍历块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x219_hanspub.png" xlink:type="simple"/></inline-formula>下方的边界网格时，再次发现聚簇c<sub>2</sub>可以和块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x220_hanspub.png" xlink:type="simple"/></inline-formula>中的c<sub>6</sub>进行合并，于是在森林F中找到c<sub>2</sub>，将c<sub>6</sub>变为c<sub>2</sub>的孩子节点。再次查找c<sub>6</sub>的祖先结点时，通过路径压缩可以直接把c<sub>6</sub>变为c<sub>3</sub>的孩子结点。上述过程如图3所示。</p><p>图2. 块中生成的聚簇</p><p>下面给出算法伪代码。在分块合并前，需要将所有块中的聚簇以结点形式加入到F中，以此来对F进行初始化，伪代码如算法3。</p><p>初始化工作完成后，分属不同块的聚簇需要进行合并，下面给出将块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x222_hanspub.png" xlink:type="simple"/></inline-formula>中的聚簇<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x223_hanspub.png" xlink:type="simple"/></inline-formula>和块<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x224_hanspub.png" xlink:type="simple"/></inline-formula>中的聚簇<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x225_hanspub.png" xlink:type="simple"/></inline-formula>合并的过程(算法4)。</p><p>该算法的第一行调用了FindRoot函数，该函数可以查找一个节点所在树的根节点。在利用树结构递归查找根节点的同时，可以使用路径压缩技术进行优化，将该路径上的所有结点直接变为该树根结点的孩子。下面给出该函数伪代码(算法5)。</p><p>完成所有的合并操作后，F中树的个数即为最终形成的聚簇数，最后结合F将聚簇结果输出。</p><p>图3. 并查集合并聚簇</p><p>Algorithm 3. Init (clusters_List)</p><p>算法3. 并查集初始化</p><p>Algorithm 4. Merge (p,q)</p><p>算法4. 合并聚簇(p,q)</p><p>Algorithm 5. Find Root (p)</p><p>算法5. 寻找树根(代表元)</p></sec></sec><sec id="s6"><title>4. 实验结果</title><p>PDStream算法运行在分布式环境下，该环境使用三台机器构建一个集群，机器的硬件环境为4核CPU处理器，16G内存，在集群无其他任务运行的条件下进行实验。Spark框架支持多种语言接口，我们使用java语言编写Spark Job，并提交到集群中运行。在下面进行的所有实验中参数设置保持一致：<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x235_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x236_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x237_hanspub.png" xlink:type="simple"/></inline-formula>。</p><sec id="s6_1"><title>4.1. 实验数据</title><p>我们使用两份数据集进行实验。第一份是一个真实的数据集KDD-CUP 99 [<xref ref-type="bibr" rid="hanspub.19030-ref11">11</xref>] ，由MIT林肯实验室在1998年美国国防部高级规划署建立了模拟美国空军局域网的一个网络环境，收集了9周时间的 TCP连接数据，仿真各种用户类型、各种不同的网络流量和攻击手段，使它就像一个真实的网络环境。这些原始数据被分为两个部分：7周时间的训练数据，以及2周时间的测试数据，这些数据可以测试聚类算法的准确度。林肯实验室主页上提供的数据集有500,000条连接记录，这个数据集中包含5个聚簇，每个聚簇代表着一类异常连接或正常连接记录，分别是DOS，R2L，U2R，PROBING以及NORMAL，每一条连接记录中包含42个属性。根据 [<xref ref-type="bibr" rid="hanspub.19030-ref3">3</xref>] ，将其中的34个连续的属性作为聚类的输入，最终聚簇结果应当为5，我们将运行PDStream算法验证结果的正确性。</p><p>另一份数据集是人工生成的二维数据集，为了与D-Stream算法进行对比，我们模拟 [<xref ref-type="bibr" rid="hanspub.19030-ref3">3</xref>] 中使用的人工数据集，数据量为85K，聚簇数量设置为4。这个数据集主要用来观察PDStream输出的聚簇结果是否准确，并且是否可以消除历史数据的影响。</p></sec><sec id="s6_2"><title>4.2. 聚类的准确度</title><p>首先使用KDD-CUP 99作为实验数据集，将它分别运行单机运行D-Stream算法、单机运行PDStream算法、多线程运行PDStream算法。如图4，可以看出在单机情况下PDStream和D-Stream正确率保持一致，而在分布式多线程环境下，PDStream算法的正确率依然能够得到保证，并且可以从图中看出，随着线程的增加，准确度并没有明显提高，线程数为2的时候甚至会下降，这说明块的划分数目、划分方式以及聚簇的分布对算法结果有着很大的影响。</p><p>在人工数据集中，一台机器上以4个线程运行PDStream算法，数据量为85 K，以1 K/s的速率将数</p><p>图4. D-Stream与PDStream准确率对比</p><p>据传入系统，数据集如图5所示，将区域分为4个聚簇。</p><p>为了验证算法可以显示聚簇随着时间动态变化的准确性，首先不加入衰减，输出最后的聚类结如图6所示，从图中可以清楚地看到数据形成了4个聚簇。</p><p>现在再次运行算法，并在其中加入衰减参数<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/10-1540665x239_hanspub.png" xlink:type="simple"/></inline-formula>，选取t = 10 s、t = 50 s、t = 85 s三个时间点来观察聚簇的生成情况，分别如图7、图8、图9所示。观察这几幅图可以发现，由于衰减的存在，数据流的聚簇结果会随着时间发生变化，消除了历史数据的影响。从图中还可以很直观地看到PDStream聚类算法能够得到当前时间正确的聚类结果，验证了算法的准确性。</p><p>图5. 包含四个聚簇的人工数据集</p><p>图6. 无衰减下的聚簇结果</p><p>图7. t = 10 s时聚簇结果</p><p>图8. t = 50 s时聚簇结果</p><p>图9. t = 85 s时聚簇结果</p></sec><sec id="s6_3"><title>4.3. 性能表现</title><p>由于加入了基于并查集的优化，PDStream的运行效率较D-Stream得到了显著提升。在KDD-CUP 99数据集上分别运行单机运行D-Stream算法和PDStream算法，记录不同数据量下生成聚簇的时间，如图10所示。从图中可以看出，随着数据量的增多，PDStream在时间效率上的优势越明显。</p><p>观察多线程下PDStream的性能表现，在人工数据集中分别以单线程、2线程、4线程、8线程运行PDStream算法，统计不同数据量下聚簇的生成时间，如图11所示。</p><p>从图中可以看出，随着线程的增加，聚簇生成的时间明显缩短，在数据量达到85K时，2线程相比单线程运行时间上缩短了接近20%，而4线程缩短了40%，可见分布式环境下分块中运行聚簇算法使得效率得到提升。但由于本文所用的人工数据集聚簇较少，数据空间较小，并且随着线程数目的增加，块的划分数目变多，块之间聚簇的合并操作成了算法新的瓶颈，因此从图中可看出8线程较4线程环境下的时间效率并无提升，反而有所下降，可见针对不同规模的数据集，需要根据实际情况合理规划线程数，使得算法达到最理想的运行效果。</p><p>图10. D-Stream与PDStream效率对比</p><p>图11. 多线程下PDStream运行时间</p></sec></sec><sec id="s7"><title>5. 总结</title><p>本文设计了一种基于Spark Streaming的分布式流聚类算法PDStream，该算法在D-Stream的基础上，对数据集进行了分块并行处理，在聚类结果得到保证的情况下，加入了基于并查集的优化算法，极大地提高了算法的运行效率。实验结果表明PDStream在运行效率上相比D-Stream有较大的提高，并能适用于分布式环境，从而说明了PDStream算法的可行性。</p></sec><sec id="s8"><title>基金项目</title><p>上海市科委基础研究重点项目(13JC1403501)。</p></sec><sec id="s9"><title>文章引用</title><p>张伯涛,李建华,范 磊. 基于Spark的动态聚类算法研究 Research on Dynamic Clustering Algorithm Based on Spark Framework[J]. 计算机科学与应用, 2016, 06(11): 715-727. http://dx.doi.org/10.12677/CSA.2016.611086</p></sec><sec id="s10"><title>参考文献 (References)</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.19030-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Aggarwal, C.C., Han, J., Wang, J., et al. (2003) A Framework for Clustering Evolving Data Streams. Vldb, 29, 81-92.  
&lt;br&gt;https://doi.org/10.1016/b978-012722442-8/50016-1</mixed-citation></ref><ref id="hanspub.19030-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Cao, F., Ester, M., Qian, W., et al. (2006) Density-Based Clustering over an Evolving Data Stream with Noise. Siam International Conference on Data Mining, Bethesda, 20-22 April 2006, 328-339.</mixed-citation></ref><ref id="hanspub.19030-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Chen, Y. and Tu, L. (2007) Density-Based Clustering for Real-Time Stream Data. ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, San Jose, August 2007, 133-142.</mixed-citation></ref><ref id="hanspub.19030-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Amini, A. (2012) DENGRIS-Stream: A Density-Grid Based Clustering Algorithm for Evolving Data Streams over Sliding Window. International Conference on Data Mining and Computer Engineering.</mixed-citation></ref><ref id="hanspub.19030-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Bhatnagar, V., Kaur, S. and Chakravarthy, S. (2014) Clustering Data Streams Using Grid-Based Synopsis. Knowledge &amp; Information Systems, 41, 127-152. &lt;br&gt;https://doi.org/10.1007/s10115-013-0659-1</mixed-citation></ref><ref id="hanspub.19030-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Forestiero, A., Pizzuti, C. and Spezzano, G. (2013) A Single Pass Algorithm for Clustering Evolving Data Streams Based on Swarm Intelligence. Data Mining &amp; Knowledge Discovery, 26, 1-26.  
&lt;br&gt;https://doi.org/10.1007/s10618-011-0242-x</mixed-citation></ref><ref id="hanspub.19030-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Eberhart, R.C. (2001) Swarm Intelligence.</mixed-citation></ref><ref id="hanspub.19030-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Hadoop, W.T. (2010) The Definitive Guide. O’reilly Media Inc Gravenstein Highway North, 215, 1-4.</mixed-citation></ref><ref id="hanspub.19030-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Zaharia, M., Chowdhury, M., Franklin, M.J., et al. (2010) Spark: Cluster Computing with Working Sets. 10.</mixed-citation></ref><ref id="hanspub.19030-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">夏俊鸾, 邵赛赛. Spark Streaming: 大规模流式数据处理的新贵[J]. 程序员, 2014(2): 44-47.</mixed-citation></ref><ref id="hanspub.19030-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">张新有, 曾华燊, 贾磊. 入侵检测数据集KDD CUP99研究[J]. 计算机工程与设计, 2010, 31(22): 4809-4812.</mixed-citation></ref></ref-list></back></article>