<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2019.97157</article-id><article-id pub-id-type="publisher-id">CSA-31408</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20190700000_87815976.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  森林在递归算法分析中的应用
  Application of Forest in the Analysis of Recursive Algorithm
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>刘</surname><given-names>月锟</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>颛</surname><given-names>孙盈</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>徐</surname><given-names>贝宁</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>沈</surname><given-names>碧荷</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>青岛理工大学信息与控制工程学院，山东 青岛</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>11</day><month>07</month><year>2019</year></pub-date><volume>09</volume><issue>07</issue><fpage>1398</fpage><lpage>1405</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   
   本文提出用森林进行递归算法分析的方法，该方法将递归逻辑映射到森林，具体处理上以树为处理单元，对程序递归结构分析，定义树节点，通过搜索建立树和调用状态表，所建立的树不局限于二叉树，根据实际问题可以是单分支树、二叉树、多叉树，甚至多棵树组成的森林，到达叶子节点进行回溯，根据程序执行情况，多棵树需要树间跳转；依据树和调用状态表的对照，既分析全面，又使分析结构清晰、结果准确、适用广泛，有效解决了递归算法结果分析中的难题。 This paper presents a method of recursive algorithm analysis by forest. This method maps recur-sive logic to forest. Tree is used as processing unit. The recursive structure of program is analyzed and tree nodes are defined. Tree is established by searching and calling state table. The tree is not limited to binary tree. According to practical problems, it can be composed of single branch tree, binary tree, multi-branch tree or even multi-tree. According to the implementation of the program, many trees need to jump between trees. According to the comparison between the tree and the invocation state table, the analysis is comprehensive, and the analysis structure is clear, the results are accurate, and the application is extensive, which effectively solves the difficulties in the analysis of the results of the recursive algorithm.
   
    
  
 
</p></abstract><kwd-group><kwd>森林，逻辑映射，状态表，递归算法，搜索，回溯, Forest</kwd><kwd> Logistic Map</kwd><kwd> State Table</kwd><kwd> Recursive Algorithm</kwd><kwd> Search</kwd><kwd> Backtrack</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>森林在递归算法分析中的应用<sup> </sup></title><p>刘月锟，颛孙盈，徐贝宁，沈碧荷</p><p>青岛理工大学信息与控制工程学院，山东 青岛</p><p><img src="//html.hanspub.org/file/21-1541471x1_hanspub.png" /></p><p>收稿日期：2019年7月4日；录用日期：2019年7月18日；发布日期：2019年7月25日</p><disp-formula id="hanspub.31408-formula40"><graphic xlink:href="//html.hanspub.org/file/21-1541471x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>本文提出用森林进行递归算法分析的方法，该方法将递归逻辑映射到森林，具体处理上以树为处理单元，对程序递归结构分析，定义树节点，通过搜索建立树和调用状态表，所建立的树不局限于二叉树，根据实际问题可以是单分支树、二叉树、多叉树，甚至多棵树组成的森林，到达叶子节点进行回溯，根据程序执行情况，多棵树需要树间跳转；依据树和调用状态表的对照，既分析全面，又使分析结构清晰、结果准确、适用广泛，有效解决了递归算法结果分析中的难题。</p><p>关键词 :森林，逻辑映射，状态表，递归算法，搜索，回溯</p><disp-formula id="hanspub.31408-formula41"><graphic xlink:href="//html.hanspub.org/file/21-1541471x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2019 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/21-1541471x7_hanspub.png" /> <img src="//html.hanspub.org/file/21-1541471x8_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>递归算法是一种直接或者间接地调用自身算法的过程，递归算法把大问题转化为规模缩小的同类问题的子问题，将一个复杂问题逐步简化并最终转化为一个最简单的问题，最简单问题的解决就意味着整个问题解决。递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解，为一些问题提供了最简单的解决方案 [<xref ref-type="bibr" rid="hanspub.31408-ref1">1</xref>] 。递归算法简洁、规整，虽然在整体结构上易于理解，但在分析递归运行情况时，总给人不可捉摸、难以理解的感觉，主要原因是递归调用实现机制太抽象，递归函数层层跳转、回溯，使人们对递归算法的分析难以把握。</p><p>多年来，很多学者对递归算法的分析进行了深入研究，但还存在一些不足，文献 [<xref ref-type="bibr" rid="hanspub.31408-ref2">2</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref3">3</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref4">4</xref>] 在讨论递归算法结果时，一般根据函数调用的过程直接分析，对于简单的问题容易实现，但对复杂递归函数分析就困难重重，分析过程过于抽象，极易出错；文献 [<xref ref-type="bibr" rid="hanspub.31408-ref5">5</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref6">6</xref>] 使用递推函数对递归算法分析研究，这种方法不具有通用性，而且一些递归算法难以转换为递推式；文献 [<xref ref-type="bibr" rid="hanspub.31408-ref7">7</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref9">9</xref>] 提出了用递归树研究递归的方法，将递归与树进行映射，便于操作，但分析时局限于单棵树，注重于函数调用关系的研究，而递归调用中有时是多棵树组成的森林，递归树在处理这些问题时显得不足，且在树上标注，处理结构不清晰。</p><p>本文将森林引入递归算法的分析处理过程，解决递归算法分析中存在的问题，通过建立递归与森林的逻辑映射关系，根据对程序递归结构分析，判断树结构，由入口函数，建立搜索树，所建立的树不仅限于二叉树，根据实际问题可以是单分支树，可以是二叉树、多叉树，甚至多棵树，到达叶子节点进行回溯，将程序结构映射为森林，并根据执行情况建立状态调用表，既分析全面，又使分析结构清晰、结果准确，有效解决了递归算法结果分析中的难题。</p></sec><sec id="s4"><title>2. 树在递归分析中的应用</title><p>递归算法整个过程分为两部分：递推和回归，递归调用由多个子递归构成，递归的结构和处理与树的特点很相似，树由多个子树构成，对树的遍历就是搜索和回溯的过程，所以在递归算法分析上可以将递归结构映射到树型结构上，可以用树结构进行递归算法的分析。实际问题中，存在一些分支语句中含有递归的情形，这时需要分成多棵树，多棵树组成逻辑上的森林。</p><p>森林为M棵互不相交的树的集合，表示为F = {T<sub>1</sub>, T<sub>2</sub>, ∙∙∙, T<sub>m</sub>} [<xref ref-type="bibr" rid="hanspub.31408-ref10">10</xref>] ，T<sub>1</sub>, T<sub>2</sub>, ∙∙∙, T<sub>m</sub>为组成森林的树，可以将递归算法逻辑映射为森林，具体处理上以树为处理单元，建立标准的处理流程。</p><p>递归算法映射到树时，在分析中对树的遍历采用先根遍历，边界条件即为树的叶子节点，下面以一简单递归类型的程序结构为例，说明使用树对递归算法分析的过程，在第3部分采用具体实例进行详细说明：</p><p>(1)void Recursive (int m, int n)</p><p>{</p><p>(2) if (m==0)</p><p>(3) return ;</p><p>(4) if (n==0)</p><p>{</p><p>(5) a= Recursive (m-1,1);</p><p>(6) return a;</p><p>}</p><p>(7)else</p><p>{</p><p>(8) b= Recursive (m-1,n);</p><p>(9) printf(“%d %d”,m,n);</p><p>(10) c= Recursive (m,n-1);</p><p>}</p><p>}</p><sec id="s4_1"><title>2.1. 分析程序结构</title><p>首先分析程序的整体结构，函数Recursive为递归函数，作为树的基础节点，通过深度搜索对树节点进行扩展，每次递归函数执行过程的节点作为树的一个节点类型；其次要分析递归函数在程序结构中所处位置，语句(5)的递归函数与语句(8)、(10)的递归函数处于不同的语句结构体中，执行到语句(5)时程序跳转到另外一棵树，所以要分成两个不同的树进行处理，这两棵树构成森林；第三，语句(8)、(10)在一棵树中进行处理，处理过程扩展为二叉树，b和c处于二叉树的不同分支；第四，两个分支中的其他语句，如：程序中的处理语句(9)在b执行到叶子节点回溯到c的过程中执行。</p><p>程序中语句(2)、(4)为边界，搜索到叶子节点时执行，执行语句(4)时跳到另一棵树执行搜索；语句(1)为程序入口，可看作根节点。</p></sec><sec id="s4_2"><title>2.2. 建立树型图</title><p>根据对程序结构的分析，明确树的总体结构，本示例为两棵树构成的森林，每棵树为二叉树，入口函数作为树的根节点，从根节点进行深度搜索，由搜索情况建立树节点，到叶子节点进行回溯。多棵树组成的森林，在搜索树节点时，根据实际情况进行树间跳转，根据搜索情况绘制树型图，标明节点序号。</p></sec><sec id="s4_3"><title>2.3. 建立状态调用表</title><p>树只建立节点，根据节点扩展情况，对应树的节点建立对应状态调用表，调用表反映状态变化及其他语句块执行，一方面反映程序整体全貌，另一方面使分析更加清晰、直观；状态调用表主要内容有：节点编号、节点名、节点动作、节点值等，根据树的搜索情况建立该表，回溯节点前加H代表回溯动作，回溯到根节点，递归算法分析结束，结果为递归算法处理结果。</p></sec></sec><sec id="s5"><title>3. 实例分析</title><sec id="s5_1"><title>3.1. 汉诺塔问题</title><p>有A，B，C三根柱子，A柱上按大小顺序从下往上摞着n片圆盘，现在要将这些圆盘从A柱移至C柱，并保持上小下大的顺序。移动规则如下：每次只能移动一个盘，大盘不能放在小盘上。</p><p>程序主体结构：</p><p>void hanoi (int n,char a,char b,char c)</p><p>{</p><p>if(n==1)</p><p>{</p><p>printf(“%c--&gt;%c”, a,c);//1</p><p>}</p><p>else</p><p>{</p><p>hanoi(n-1,a,c,b );</p><p>printf(“%c--&gt;%c”, a,c);//2</p><p>hanoi(n-1,b,a,c);</p><p>}</p><p>}</p><p>递归分析：</p><p>将递归函数作为树的节点，程序中有两个递归函数分别为树的左右分支，左分支：hanoi(n-1,a,c,b)，右分支：hanoi(n-1,b,a,c)，其他处理语句单独列明：如：1语句在n等于1时执行，为出口语句，2语句在右分支前执行，在下述实例中只在4、5、7节点前执行。</p><p>假如初始调用为hanoi(3,'A','B','C')，则调用树结构如图1所示，执行过程调用状态如表1所示。</p><p>图1. 汉诺塔执行的树结构</p><table-wrap-group id="1"><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> The Tower of Hanoi call status table on execution procedur</title></caption><table-wrap id="1_1"><table><tbody><thead><tr><th align="center" valign="middle" >节点</th><th align="center" valign="middle" >H(n,a,b,c)</th><th align="center" valign="middle" >动作</th><th align="center" valign="middle" >节点值</th><th align="center" valign="middle" >备注</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >H(3,’A’,’B’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >H(2,’A’,’C’,’B’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >H(1,’A’,’B’,’C’)</td><td align="center" valign="middle" >‘A’→’C’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H2</td><td align="center" valign="middle" >H(2,’A’,’C’,’B’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯到2节点，搜索4节点</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >‘A’→’B’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >执行语句2，父节点为2</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" >H(1,’C’,’A’,’B’)</td><td align="center" valign="middle" >‘C’→’B’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr></tbody></table></table-wrap><table-wrap id="1_2"><table><tbody><thead><tr><th align="center" valign="middle" >H2</th><th align="center" valign="middle" >H(2,’A’,’C’,’B’)</th><th align="center" valign="middle" ></th><th align="center" valign="middle" ></th><th align="center" valign="middle" >回溯节点2，2节点搜索完毕</th></tr></thead><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >H(3,’A’,’B’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯到1节点，搜索右分支</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >‘A’→’C’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >在5节点前执行</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" >H(2,’B’,’A’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" >H(1,’B’,’C’,’A’)</td><td align="center" valign="middle" >‘B’→’A’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H5</td><td align="center" valign="middle" >H(2,’B’,’A’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯节点5</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >‘B’→’C’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >执行语句2，父节点为5</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle" >H(1,’A’,’B’,’C’)</td><td align="center" valign="middle" >‘A’→’C’</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >父节点为5</td></tr><tr><td align="center" valign="middle" >H5</td><td align="center" valign="middle" >H(2,’B’,’A’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯节点5，节点5搜索完毕</td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >H(3,’A’,’B’,’C’)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯到根节点，处理完毕</td></tr></tbody></table></table-wrap></table-wrap-group><p>表1. 汉诺塔执行过程调用状态表</p></sec><sec id="s5_2"><title>3.2. 2018 noip普及组试题三(3)</title><p>int findans(int n,int m)</p><p>{</p><p>if(n==0) return m;</p><p>if(m==0) return n%3;</p><p>return findans(n-1,m)-findans(n,m-1)+findans(n-1,m-1);</p><p>}</p><p>将return findans(n-1,m)-findans(n,m-1)+findans(n-1,m-1)，修改为：</p><p>f1= findans(n-1,m)</p><p>f2= findans(n,m-1)</p><p>f3= findans(n-1,m-1)</p><p>return f1-f2+f3</p><p>调用实例findans(1,2)</p><p>树为三叉树，第一分支为findans(n-1,m)，第二分支为findans(n,m-1)，第三分支为findans(n-1,m-1)，函数简称为f(n,m)。</p><p>语句f1-f2+f3在第三分支后执行，return m，return n%3为出口语句。</p><p>调用树结构如图2所示，执行过程调用状态如表2所示。</p><p>结果为：3。</p><p>图2. 2018 noip普及组树结构</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> The call status table of 2018 noip popularization grou</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >节点</th><th align="center" valign="middle" >f(n,m)</th><th align="center" valign="middle" >动作</th><th align="center" valign="middle" >节点值</th><th align="center" valign="middle" >备注</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >f(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >f(0,2)</td><td align="center" valign="middle" >f1 = 2</td><td align="center" valign="middle" >f1 = f(0,2) = 2</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >f(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯，搜索第二分支</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >f(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" >f(0,1)</td><td align="center" valign="middle" >f1 = 1</td><td align="center" valign="middle" >f1 = f(0,1) = 1</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H3</td><td align="center" valign="middle" >f(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯，搜索第二分支</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" >f(1,0)</td><td align="center" valign="middle" >f2 = 1</td><td align="center" valign="middle" >f2 = f(1,0) = 1</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H3</td><td align="center" valign="middle" >f(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯，搜索第三分支</td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" >f(0,0)</td><td align="center" valign="middle" >f3 = 0</td><td align="center" valign="middle" >f3 = f(0,0) = 0</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >f2 = f1 − f2 + f3 = 0</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H3</td><td align="center" valign="middle" >f(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >f2 = 0</td><td align="center" valign="middle" >回溯节点3，搜索完毕</td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >f(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >回溯，搜索第三分支</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle" >f(0,1)</td><td align="center" valign="middle" >f3 = 1</td><td align="center" valign="middle" >f3 = f(0,1) = 1</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >f1 − f2 + f3 = 2 – 0 + 1 = 3</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >f(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >回溯到根节点，结束</td></tr></tbody></table></table-wrap><p>表2. 2018 noip普及组调用状态表</p></sec><sec id="s5_3"><title>3.3. 阿克曼函数</title><p>阿克曼函数定义：</p><p>n+1m=0,n&gt;0</p><p>A(m,n)=A(m-1,1) n=0,m&gt;0</p><p>A(m-1,A(m,n-1)) n&gt;0,m&gt;0</p><p>程序主体结构：</p><p>int Ackerman(int m, int n)</p><p>{</p><p>if (m==0)</p><p>return n + 1;</p><p>if (n==0)</p><p>return Ackerman(m - 1, 1);</p><p>else</p><p>return Ackerman(m - 1,Ackerman(m, n - 1));</p><p>}</p><p>因为递归函数是参数，语句return Ackerman(m - 1,Ackerman(m, n - 1))；修改为：</p><p>a= Ackerman(m, n - 1);</p><p>b= Ackerman(m - 1,a);</p><p>return b;</p><p>因为if语句含有递归函数，所以分为两棵树，树1称为t1，树2称为t2。t1有两个分支，左分支为Ackerman(m, n - 1)，右分支为Ackerman(m - 1,a)，函数简称为A(m,n)。t2有1个分支为Ackerman(m - 1, 1)。</p><p>入口调用函数为：A(1,2)</p><p>t1调用树结构如图3所示，执行过程调用状态如表3所示，跳转后的分支树t2的调用树结构如图4所示，执行过程调用状态如表4所示。</p><p>结果为：4。</p><p>图3. t1树结构</p><p>图4. t2树结构</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> The call status table of T</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >节点</th><th align="center" valign="middle" >A(m,n)</th><th align="center" valign="middle" >动作</th><th align="center" valign="middle" >节点值</th><th align="center" valign="middle" >备注</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >A(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >A(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >A(1,0)</td><td align="center" valign="middle" >执行t2树</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >接收t2树返回值</td></tr><tr><td align="center" valign="middle" >H2</td><td align="center" valign="middle" >A(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >a = 2</td><td align="center" valign="middle" >回溯节点2</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" >A(0,2)</td><td align="center" valign="middle" >n + 1 = 3</td><td align="center" valign="middle" >b = 3</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H2</td><td align="center" valign="middle" >A(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >b = 3</td><td align="center" valign="middle" >回溯节点2</td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >A(1,2)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >回溯节点1，搜索右分支</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" >A(0,3)</td><td align="center" valign="middle" >n + 1 = 4</td><td align="center" valign="middle" >b = 4</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >A(1,1)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >4</td><td align="center" valign="middle" >回溯根节点1，搜索结束</td></tr></tbody></table></table-wrap><p>表3. T1树调用状态表</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> The call status table of T</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >节点</th><th align="center" valign="middle" >A(m,n)</th><th align="center" valign="middle" >动作</th><th align="center" valign="middle" >节点值</th><th align="center" valign="middle" >备注</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >A(1,0)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >A(0,1)</td><td align="center" valign="middle" >n + 1</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >H1</td><td align="center" valign="middle" >A(1,0)</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >回溯节点1，t2树执行完毕</td></tr></tbody></table></table-wrap><p>表4. T2树调用状态表</p></sec></sec><sec id="s6"><title>4. 结论</title><p>当前对递归算法的分析方法主要有：根据函数调用的过程直接分析 [<xref ref-type="bibr" rid="hanspub.31408-ref2">2</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref3">3</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref4">4</xref>] ，使用递推函数分析 [<xref ref-type="bibr" rid="hanspub.31408-ref5">5</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref6">6</xref>] ，这两种方法分析递归算法的局限性是显而易见的，在分析稍复杂的递归算法时是无能为力的；用递归树分析递归过程 [<xref ref-type="bibr" rid="hanspub.31408-ref7">7</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.31408-ref9">9</xref>] ，分析时局限于单棵树、状态调用过程不清晰；本文通过对递归不同类型典型实例的分析，将递归算法逻辑映射到森林，用树结构处理递归函数结果。给出了用森林分析递归函数的基本流程，通过分析程序结构、搜索建立分析树和状态变化对照表，到达叶子节点进行回溯，既分析全面，又使分析结构清晰、结果准确，有效解决了递归算法结果分析中的难题。</p></sec><sec id="s7"><title>文章引用</title><p>刘月锟,颛孙盈,徐贝宁,沈碧荷. 森林在递归算法分析中的应用 Application of Forest in the Analysis of Recursive Algorithm[J]. 计算机科学与应用, 2019, 09(07): 1398-1405. https://doi.org/10.12677/CSA.2019.97157</p></sec><sec id="s8"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.31408-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Prata, S. C Primer Plus [M]. 第6版. 姜佑, 译. 北京: 人民邮电出版社, 2016: 256-282.</mixed-citation></ref><ref id="hanspub.31408-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">晏素芹. 递归算法的教学方法探讨——以C程序设计为例[J]. 福建电脑, 2018, 34(8): 170-171.</mixed-citation></ref><ref id="hanspub.31408-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">方娇莉, 潘晟旻, 刘明. 程序设计微课教学设计方法研究——以递归为例[J]. 计算机教育, 2016(5): 116-120.</mixed-citation></ref><ref id="hanspub.31408-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">吴晓晨. 递归程序设计教学方法的研究[J]. 天津科技, 2017, 44(1): 69-71.</mixed-citation></ref><ref id="hanspub.31408-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">陈瑞环, 杨庆红, 姚兴. 使用递推解决递归问题的研究与应用[J]. 计算机应用与软件, 2011, 28(3): 186-187.</mixed-citation></ref><ref id="hanspub.31408-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">周法国, 韩智, 高天. 递归算法设计思想与策略分析[J]. 软件导刊, 2017, 16(10): 35-38.</mixed-citation></ref><ref id="hanspub.31408-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">张建波. 一种将递归过程转换为非递归过程的方法研究[J]. 计算机教育, 2017(8): 139-142.</mixed-citation></ref><ref id="hanspub.31408-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">黎远松. 基于树的递归算法分析技术[J]. 四川理工学院学报(自然科学版), 2012, 25(4): 50-51.</mixed-citation></ref><ref id="hanspub.31408-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">张俊. 基于递归树的递归调用分析[J]. 实验室研究与探索, 2010, 29(3): 83-87.</mixed-citation></ref><ref id="hanspub.31408-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">严蔚敏, 吴伟民. 数据结构(C语言版) [M]. 北京: 清华大学出版社, 2009: 118-155.</mixed-citation></ref></ref-list></back></article>