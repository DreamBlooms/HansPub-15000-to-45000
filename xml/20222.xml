<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2017.74038</article-id><article-id pub-id-type="publisher-id">CSA-20222</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20170400000_99110086.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  基于UEFI的操作系统完整性度量方法
  Operating System Integrity Measurement Method Based on UEFI
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>周</surname><given-names>艺华</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>安</surname><given-names>会</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>王</surname><given-names>冠</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>孙</surname><given-names>亮</given-names></name><xref ref-type="aff" rid="aff4"><sup>4</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff3"><addr-line>北京工业大学计算机学院，北京;可信计算北京市重点实验室，北京</addr-line></aff><aff id="aff4"><addr-line>中电科技(北京)有限公司，北京</addr-line></aff><aff id="aff2"><addr-line>北京工业大学计算机学院，北京</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><author-notes><corresp id="cor1">* E-mail:<email>1216589268@qq.com (安会)</email>;</corresp></author-notes><pub-date pub-type="epub"><day>18</day><month>4</month><year>2017</year></pub-date><volume>07</volume><issue>04</issue><fpage>310</fpage><lpage>319</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   操作系统内核受到攻击，会对操作系统以及应用程序造成重大的威胁，为了保证操作系统内核的完整性，本文提出了一种基于UEFI固件的操作系统完整性度量机制，该方案主要在UEFI BIOS启动过程中，利用TCM芯片的加密，认证和Hash运算等技术，对操作系统内核进行完整性度量，能够有效保护内核以及操作系统的安全。 If the operating system kernel is under attack, it can pose a significant threat to operating systems and applications. In order to ensure the integrity of the operating system kernel, this paper presents an operating system integrity measurement method based on UEFI firmware. In the scheme, we measure the integrity of operating system mainly in UEFI BIOS boot process, using TCM chip’s encryption, authentication functions and Hash algorithm. The scheme can effectively protect the kernel and the safety of the operating system.
    
  
 
</p></abstract><kwd-group><kwd>UEFI，操作系统内核，TCM，完整性度量, UEFI</kwd><kwd> OS Kernel</kwd><kwd> TCM</kwd><kwd> Integrity Measurement</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>基于UEFI的操作系统完整性度量方法<sup> </sup></title><p>周艺华<sup>1</sup>，安会<sup>1,2</sup>，王冠<sup>1,2</sup>，孙亮<sup>3</sup></p><p><sup>1</sup>北京工业大学计算机学院，北京</p><p><sup>2</sup>可信计算北京市重点实验室，北京</p><p><sup>3</sup>中电科技(北京)有限公司，北京</p><p>收稿日期：2017年4月2日；录用日期：2017年4月14日；发布日期：2017年4月19日</p><disp-formula id="hanspub.20222-formula51"><graphic xlink:href="http://html.hanspub.org/file/4-1540738x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>操作系统内核受到攻击，会对操作系统以及应用程序造成重大的威胁，为了保证操作系统内核的完整性，本文提出了一种基于UEFI固件的操作系统完整性度量机制，该方案主要在UEFI BIOS启动过程中，利用TCM芯片的加密，认证和Hash运算等技术，对操作系统内核进行完整性度量，能够有效保护内核以及操作系统的安全。</p><p>关键词 :UEFI，操作系统内核，TCM，完整性度量</p><disp-formula id="hanspub.20222-formula52"><graphic xlink:href="http://html.hanspub.org/file/4-1540738x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2017 by authors and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="http://image.hanspub.org:8080\Html/htmlimages\1-2890033x\e70a10f1-7c93-45ea-9603-062237856e4b.png" /><img src="http://image.hanspub.org:8080\Html\htmlimages\1-2890033x\e898c85e-ffc4-45c9-b817-14224a4d6960.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>操作系统是计算机硬件和软件的纽带，是应用软件运行的基础环境，而内核的安全性是操作系统安全的核心问题，若操作系统内核受到攻击，会对操作系统以及应用程序造成重大的威胁。</p><p>文献 [<xref ref-type="bibr" rid="hanspub.20222-ref1">1</xref>] 中指出了可信验证包括启动验证和运行时验证两种类型，启动验证来源于认证启动 [<xref ref-type="bibr" rid="hanspub.20222-ref2">2</xref>] ，认证启动保证了操作系统开机启动时是安全可信的，如果开机启动时不能够保证操作系统的安全性，则开机启动之后的验证将不再有意义。如何在开机启动时保护操作系统的完整性，防止恶意程序攻击内核系统是可信计算 [<xref ref-type="bibr" rid="hanspub.20222-ref3">3</xref>] [<xref ref-type="bibr" rid="hanspub.20222-ref4">4</xref>] 亟待解决的问题。本文通过在UEFI BIOS启动的过程中，基于TCM [<xref ref-type="bibr" rid="hanspub.20222-ref5">5</xref>] 芯片的加密和认证等功能，完成对操作系统内核文件的完整性度量，从而保证了操作系统内核的完整性和安全性。</p><p>IMA [<xref ref-type="bibr" rid="hanspub.20222-ref6">6</xref>] (IBM integrity measurement)提出了一种有效的度量方法，该方法是在加载动态链接库或内核模块时，对用到的一些关键数据和信息进行度量，并将度量的结果扩展到通过TPM来保护的信任链中。IMA架构要求任何软件在加载的时候都要被度量，而用户可能只关心某一部分的完整性，对于这些用户来说IMA度量会有冗余，会降低系统的效率 [<xref ref-type="bibr" rid="hanspub.20222-ref2">2</xref>] 。</p><p>而本文提出的基于UEFI [<xref ref-type="bibr" rid="hanspub.20222-ref7">7</xref>] 的操作系统完整性度量方法只是对操作系统的内核进行完整性度量，而且适用于一台计算机装一个或者多个操作系统的情况。该方法是以硬件芯片作为起点，度量在BIOS中执行，增加了其自身的安全性，相对于那些在应用层做度量的方法更安全。而且将被检测的对象分离开，更能够有效的防止篡改和不可旁路性，在实现技术上，通过一台安全管理服务器来管理度量初始值的安全性，更简单方便。</p><p>UEFI (United Extensible Firmware Interface)是Intel联合业界采用开源方式共同制定推出的规范 [<xref ref-type="bibr" rid="hanspub.20222-ref8">8</xref>] 。UEFI BIOS定义了操作系统和平台固件之间的接口标准，是运行在操作系统和硬件之间的一个新的模型 [<xref ref-type="bibr" rid="hanspub.20222-ref9">9</xref>] 。UEFI较BIOS有可编程性好，可扩展性好，安全性高等优点，所以能够很快速的取代传统BIOS，成为新一代的趋势。</p></sec><sec id="s4"><title>2. 基于UEFI的操作系统完整性度量的总体设计</title><p>基于UEFI的操作系统完整性度量主要包括两部分，一部分是需要度量的客户机，另一部分是进行安全管理的服务器。整个系统的流程图如图1所示，客户机首先在UEFI BIOS启动的时候获取操作系统的内核以及版本，对操作系统内核做Hash运算，然后判断本地存储的OsKernalFile文件是否被篡改，如果被篡改，则将OsKernalFile文件里的内容清空后向服务器发送请求，要求服务器发送该版本的安全内核文件；如果没有被篡改，再查看本机中是否存储该操作系统的安全内核Hash值以及该Hash值是否失</p><p>图1. 系统流程图</p><p>效，如果存在该操作系统的安全内核Hash值并且该Hash值在有效期内，则取出该安全内核Hash值，与开机启动时获取的操作系统内核Hash值进行对比，对比通过，进入到操作系统，对比不通过，直接关机；如果不存在该操作系统的安全内核Hash值或者该Hash值已经失效，则向服务器发送请求，要求服务器发送该版本的安全内核文件。客户机向服务器发送的内容主要包括操作系统的内核Hash值和版本信息，安全管理服务器通过通讯模块接收请求，对客户机进行身份的认证，然后得到操作系统内核镜像文件Hash值以及版本信息，进一步跟DB里存放的安全的操作系统内核镜像Hash值进行对比，对比通过之后，将该版本的操作系统内核相关的信息(内核Hash值，版本信息和有效期)发送给客户机，客户机接收到该信息之后，将该条信息更新到OsKernalFile文件，将整个OsKernalFile文件的Hash值更新到TCM上。</p><p>OsKernalFile文件存储的是客户端装的所有的操作系统内核相关的信息，每一条记录是一个操作系统相关的信息，包括内核的有效期，内核的版本信息和内核的Hash值。每次开机，要先对整个文件做Hash运算，再跟TCM中存储的整个文件的Hash做对比，对比通过，说明OsKernalFile文件没有被篡改，对比不通过，首先清空该文件，然后再请求服务器重新发送安全内核的Hash值。</p><p>本系统使用SM3杂凑算法 [<xref ref-type="bibr" rid="hanspub.20222-ref10">10</xref>] 产生Hash值，SM3算法是国家密码管理局编制的商用算法，适用于商用密码应用中的数字签名和验证、消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。SM3密码杂凑算法的设计主要遵循的原则有3点，第一点是能够有效抵抗比特追踪法及其他分析方法；第二点是软硬件实现需求合理；第三点是在保障安全性的前提下综合性能指标与SHA-256同等条件下相当 [<xref ref-type="bibr" rid="hanspub.20222-ref11">11</xref>] 。</p><p>安全管理服务器中的DB是专门用于存储所有安全的操作系统内核镜像文件的相关信息，包括系统的版本和内核的Hash值。在接收验证请求时，首先会对客户端发过来的操作系统内核镜像进行对比，如果在DB里能够找到该镜像文件，说明该镜像文件是安全的，将该安全的内核镜像文件发送给客户机，所以要想保证整个过程的一个安全性，首先要确保存放在安全管理服务器上的DB的安全性，如果用户攻击了DB，修改了部分操作系统内核镜像，那么在运行验证内核安全性模块的时候就不会通过，整个过程将会终止，针对这个问题，本系统采取的措施是在硬盘上存储加密的DB，秘钥存放到TCM上，每次修改该DB时，都要通过SMI中断进入SMM模式，在BIOS层修改。</p><p>整个系统的框架图如图2所示，客户机主要包括发送请求模块，安全内核管理模块，信息处理和度量模块，安全管理服务器包括通讯模块，内核安全性验证模块，数据管理模块，发送安全内核相关信息模块。客户机是在操作系统启动之前的UEFI BIOS启动的时候进行的一系列的操作，安全管理服务器是在操作系统起来之后的应用层进行的，在UEFI BIOS启动的DXE阶段，就已经能够进行网络传输，所以向安全管理服务器发送请求模块和安全管理服务器向客户机发送安全内核模块都具有可行性。</p></sec><sec id="s5"><title>3. 基于UEFI固件的操作系统完整性度量的模块设计</title><sec id="s5_1"><title>3.1. 客户端模块的设计</title><p>客户机从本地获取安全的系统内核Hash值，通过跟自己机器中的内核Hash值对比，决定是否开关机，在本地没有内核Hash值时需要向服务器发出请求，要求服务器将安全的内核Hash值存储到本机中。如图3所示，客户机包括四个模块，分别是请求发送模块，安全内核文件管理模块，信息处理模块，度量模块，其中安全内核管理模块又包括文件的存储管理，失效检测和读取管理3个模块。</p><p>1) 请求发送模块</p><p>该模块主要是用来向服务器端发送请求，请求服务器端将某种版本的操作系统内核文件传输给自己。本地存储的OsKernalFile文件被篡改，或不存在该内核Hash值或存在但是不在有效期内时调用该模块。</p><p>图2. 系统的总体框架图</p><p>图3. 客户端的组织结构图</p><p>2) 安全内核管理模块</p><p>文件存储管理模块：主要用来存储安全管理服务器端发送过来的安全操作系统内核相关信息的模块。在存储该模块的时候，首先将该条消息存储到硬盘上，然后对整个文件进行杂凑运算得到新的文件Hash值，将整个文件Hash值更新到TCM中。</p><p>文件失效检测模块：该模块主要实现检测本机中已存在的安全操作系统内核Hash值是否失效，如果失效，调用请求发送模块。主要是通过有效期来判断，首先获得当前的日期，再跟服务器端发来的文件的有效期进行对比。</p><p>文件读取管理模块：该模块是用来实现对安全操作系统内核Hash值的读取，但是在读取信息之前，需要先确定该Hash值是不是被篡改过，需要将存储到本机硬盘上的安全操作系统内核Hash值文件在进行杂凑运算，将生成的整个文件的Hash值与TCM中已存的文件Hash值进行对比，对比通过之后，在对硬盘上的安全操作系统内核Hash值进行读取操作。</p><p>3) 信息处理模块</p><p>数据加解密模块：该模块主要实现的是TCM相关的一些算法，包括SM3杂凑算法，平台身份秘钥PIK (本质上是一对SM2秘钥)。</p><p>数字信封解封管理模块：该模块主要实现的功能主要包括两个：一个是对客户端向安全管理服务器端发送信息的封装操作，另一个是对服务器端向客户端发送数据的解封操作。</p><p>4) 度量模块</p><p>在BIOS启动的时候，首先获取os内核镜像文件，使用SM3杂凑算法产生Hash值，调用文件读取管理模块读取文件中的安全os内核Hash值，将这两个Hash值对比，从而决定操作系统的启动与关闭。</p></sec><sec id="s5_2"><title>3.2. 安全服务器端的设计</title><p>服务器端接收到请求之后，将客户端发送过来的内核Hash值与本地安全内核DB中的同一版本的Hash值进行对比，通过之后给客户端发送安全的操作系统内核Hash值相关信息。如图4所示，服务器端主要包括通讯模块，内核安全性验证模块，信息处理模块，数据管理模块，安全内核相关信息生成模块5个模块，其中数据管理模块又包括数据增加模块，数据查找模块和数据删除模块。</p><p>图4. 服务器端模块图</p><p>1) 通讯模块</p><p>主要利用UEFI中的网络协议相关的知识实现接收验证请求，以及与客户端的通讯功能。</p><p>2) 内核安全性验证模块</p><p>该模块主要实现的是将客户端发送的操作系统内核Hash值与本地存储的同一版本os内核Hash值做对比，如果两个Hash值一致，说明该客户端发送的内核信息是安全的，如果不一致，则返回一个错误的信息。由于在安全服务器端存放的是已经加密的所有安全操作系统内核Hash值文件，所以需要先对其解密。</p><p>3) 数据管理模块</p><p>该模块是供安全服务器管理员使用的模块，主要实现的是对服务器中的安全操作系统内核Hash值文件的管理，包括数据的查找，增加和删除。在服务器端存放的是使用SM2公钥对整个文件加密过的，而秘钥存放在TCM中。</p><p>数据查找模块：该模块主要实现的是内核Hash值的获取，首先利用SMI中断进入到SMM模式，然后在SMM模式下获取SM2私钥信息，在BIOS下对文件进行解密，退出SMM模式，找到想要的内核Hash值，然后进入到SMM模式，在BIOS层对文件使用SM2公钥加密，最后退出SMM模式 [<xref ref-type="bibr" rid="hanspub.20222-ref9">9</xref>] 。</p><p>数据增加模块：该模块主要实现的是管理员在SMM模式下增加一条或者多条安全的操作系统内核Hash值记录，同样需要对安全的操作系统内核Hash值整个文件在UEFI BIOS层进行解密和加密。</p><p>数据删除模块：该模块实现的过程与上述两个模块的实现过程类似，只不过是在对文件的操作不同。在UEFI BIOS层进行解密，删除一条信息之后，在对整个存放内核信息的文件进行加密。</p><p>4) 安全内核相关信息生成模块</p><p>该模块是在跟客户机发送的内核信息比较通过之后调用的模块，主要是用来生成安全内核文件的一些信息，在将这些信息发送到客户机端，生成的安全操作系统内核信息(OsKernalMessage)的格式如图5所示，设置分隔符的作用主要是为了便于程序的读取。</p><p>图5. 服务器端发送文件格式图</p><p>5) 信息处理模块</p><p>数字信封封装模块：该模块主要实现的是对客户端发过来的数字信封进行拆封以及将要发送给客户机的信息进行封装。</p><p>信息加解密模块：同客户端的信息加解密一样，调用TCM相关的算法完成对数据的加解密操作。</p></sec></sec><sec id="s6"><title>4. 基于UEFI固件的操作系统完整性度量流程设计及算法实现</title><sec id="s6_1"><title>4.1. 客户端存储度量初始值的流程及算法实现</title><p>Client：</p><p>1. 首先获得操作系统内核信息OsKernal和版本信息OsVersion；</p><p>2. 对操作系统内核信息做SM3杂凑运算：OsKernalHash = SM3 (OsKernal)；</p><p>3. 对本地存储的OsKernalFile文件做hash运算得到OsKernalFileHash，跟TCM中存储的OsKernalFileHashTCM值对比看是否一致，如果不一致，或者一致，但是本地没有存储该操作系统相关的信息，或者存储但是已经失效，拼接系统内核信息和版本信息：OsKernalMsg = OsVersion|OsKernal；</p><p>4. 将操作系统内核相关的信息封装成数字信封，封装数字信封的过程如下：</p><p>1) 产生一个对称的秘钥，用对称的秘钥对OsKernalMsg信息进行加密，利用TCM中的随机数生成器生成一个128位的数据，将这个数据作为SMS4的对称秘钥，利用SMS4对称算法对OsKernalMessage加密。</p><p>encOsKernalMessage = SMS4_Encrypt (SMS4Key，OsKernalMsg)；</p><p>2) 利用服务器的PIK公钥Server_PIK_public对SMS4Key对称秘钥进行加密，得到加密的对称秘钥EncryptSMS4Key，EncryptSMS4Key = SM2_Encrypt (Server_PIK_public，SMS4Key)；</p><p>3) 将加密的操作系统内核信息encOsKernalMsg和加密秘钥EncryptSMS4Key封装成数字信封。</p><p>DigitalEnvelop = encOsKernalMsg|EncryptSMS4Key。</p><p>5. 将封装好的DigitalEnvelop发送给安全管理服务器。</p><p>Server。</p><p>6. 安全管理服务器接收到DigitalEnvelop信息之后，对DigitalEnvelop进行拆封运算，具体的流程如下：</p><p>1) 拆封数据信封，分别得到encOsKernalMsg信息和EncryptSMS4Key信息。</p><p>2) 使用自己的PIK私钥Server_PIK_private解密，得到对称秘钥SMS4Key。</p><p>SMS4Key = SM2_Decode (Server_PIK_private，EncryptSMS4Key)。</p><p>3) 使用对称秘钥SMS4Key解密加密的操作系统内核信息encOsKernalMsg得到OsKernalMsg。</p><p>OsKernalMsg = SMS4_Decoode (SMS4Key,encOsKernalMsg)。</p><p>7. 查看os内核信息OsKernalMsg是否在本地库中，String SerchMessage (File f，String str)函数实现的是查找文件中是否存在s功能，查找成功返回数据库中的这条记录，并进行下一步信息的封装操作；查找失败返回NOT_EXIT,并将该消息发送给客户端，客户端收到该消息之后，执行关机命令。</p><p>8. 将整条os内核记录与有效期进行拼接，得到OsKernalMessage。</p><p>OsKernalMessage = indate|OsVersion|OsKernalHash。</p><p>9. 对OsKernalMessage进行封装，封装的过程如下，其中Client_PIK_public是客户端PIK公钥，SMS4Key是一个128位的随机数：</p><p>encOsKernalMessage = SMS4_Encrypt (SMS4Key，OsKernalMessage)；</p><p>EncryptSMS4Key = SM2_Encrypt(Client_PIK_public, SMS4Key)；</p><p>DigitalEnvelop = OsKernalMessage|EncryptSMS4Key。</p><p>10. 使用服务器端的PIK私钥数字签名，并将签名信息发送给客户端。</p><p>SignatureDigitalEnvelop = SM2_Signature (Server_PIK_private，DigitalEnvelop)；</p><p>Client。</p><p>11. 客户端用服务器端的PIK公钥验证签名，对安全管理服务器进行身份认证。</p><p>DigitalEnvelop = SM2_VerifySignature (Server_PIK_public，SignatureDigitalEnvelop)。</p><p>12. 拆封数字信封，得到OsKernalMessage信息，并将该信息存储到硬盘上。</p><p>SMS4Key = SM2_Decode (Client_PIK_private，EncryptSMS4Key)；</p><p>OsKernalMessage = SMS4_Decoode (SMS4Key，encOsKernalMessage)。</p><p>13. 将存储OsKernalMessage的整个文件OsKernalFile做hash运算，得到文件Hash值，在将该信息更新到TCM中。</p><p>OsKernalFileHash = SM3 (OsKernalMessage)。</p></sec><sec id="s6_2"><title>4.2. 客户机完整性度量的流程及算法实现</title><p>1. 客户机开机启动获取内核相关信息并对内核信息进行hash运算，得到内核的hash值。</p><p>OsKernalHash = SM3 (OsKernal)。</p><p>2. 对本地存储的OsKernalFile文件做hash运算得到OsKernalFileHash，跟TCM中存储的OsKernalFileHashTCM值是否一致，如果不一致，则清空OsKernalFile文件里的内容，然后调用客户端存储度量初始值模块，具体的步骤在上一小节已详细介绍；如果一致，则说明硬盘上存储的没有被篡改。</p><p>OsKernalFileHash = SM3 (OsKernalFile)。</p><p>3. 在本地OsKernalFile文件中取出该操作系统的OsKernalHash’，将OsKernalHash信息与OsKernalHash’做对比，如果一致，说明内核没有篡改，进入到操作系统；如果不一致，说明内核被篡改，执行关机命令。</p></sec></sec><sec id="s7"><title>5. 系统安全性的核心问题</title><p>本系统是在UEFI BIOS启动的时候根据本地存放的安全内核的文件，对操作系统内核文件进行完整性度量，度量通过开机启动，要想保证整个过程的安全性，需要做到以下3点：</p><p>1) 客户端OsKernalFile文件的安全存储问题。OsKernalFile文件中存储的是本计算机中装的所有操作系统内核Hash相关的信息，是度量的初始值，如果OsKernalFile文件被篡改，度量会失去意义。为了保证该文件的安全性，需要将整个的OsKernalFile文件的Hash值存储到TCM中。在每次读取该文件时，都需要将OsKernalFile文件的Hash值与TCM中的Hash值做对比，对比通过，说明存储到该硬盘上的OsKernalFile文件是安全的。</p><p>2) 服务器端DB的安全存储问题。在安全管理服务器端存放着所有安全可信的操作系统内核镜像的文件，每次都要判断客户机发过来的操作系统内核文件是否在该DB中，如果有，说明该操作系统内核镜像文件是安全的。如何保障DB的安全性是一件极其重要的工作，该系统采用的是硬件防护，将存储和数据加解密进行有效的隔离，在操作系统上存放的是已加密的文件，在加密和解密的时候在可信的UEFI BIOS完成。</p><p>3) 传输数据的安全性。数据在网络中传输，为了保证数据的安全性，一般采取的是对需要传输的数据进行加密，常见的一些传输加密技术包括数字信封技术，SSL协议等技术，由于客户机的固件只是在开机启动的时候工作，而SSL在传输数据的时候需要三次握手才能够确认其身份，所以在该系统中SSL协议不适用，所以本系统采用了数字信封的方式来保证数据传输的安全性。</p></sec><sec id="s8"><title>6. 实验及结果</title><p>该系统的安全性在上一章节已经论述，下面我们将对整个系统的功能进行验证：</p><p>1) 在一台计算机中装一个win8的操作系统，调用该系统，能够正确的对操作系统的完整性度量，计算机正常开机。</p><p>2) 在重新开机启动该计算机，也能够实现对操作系统的完整性度量，计算机正常开机。</p><p>3) 修改操作系统内核文件，在开机时进行度量，该操作系统的内核摘要跟本地存储的内核度量初始值不一致，度量不通过，计算机不会开机。</p><p>4) 修改客户机本地硬盘中存储的内核度量初始值，在开机启动时度量，对OsKernalFile文件做SM3杂凑，跟TCM中存储的OsKernalFile文件hash不一致，会请求服务器重新发送该操作系统内核信息。</p><p>5) 伪装成服务器的身份，发送给客户机不安全的内核信息，客户机收到该消息后，对服务器进行身份认证不通过，会再次请求服务器发送安全内核信息。</p></sec><sec id="s9"><title>7. 总结</title><p>OS的安全性是计算机安全的核心，而内核的安全性是操作系统安全的核心，本文提出了一种基于UEFI BIOS的操作系统完整性度量机制，实现了在UEFI BIOS的启动过程中对操作系统内核镜像文件的完整性度量，保证了操作系统内核的安全性。在实现的整个过程中最主要的是要保证操作系统度量初始值的完整性和安全性，这是该度量机制的难点也是关键点，如果不能够保证度量初始值的正确性，该系统的度量将不再有意义。</p><p>该机制会对电脑的开机速度有较大的影响，在后续的工作中，会对该问题进行改进。本机制只是实现对操作系统完整性的度量，但是不能够保证电脑安装操作系统时操作系统的安全性，下一步可以增加操作系统的远程安装功能，进一步保证电脑中操作系统的安全性。</p></sec><sec id="s10"><title>文章引用</title><p>周艺华,安 会,王 冠,孙 亮. 基于UEFI的操作系统完整性度量方法Operating System Integrity Measurement Method Based on UEFI[J]. 计算机科学与应用, 2017, 07(04): 310-319. http://dx.doi.org/10.12677/CSA.2017.74038</p></sec><sec id="s11"><title>参考文献 (References)</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.20222-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">胡浩, 张敏, 冯登国. 基于信息流的可信操作系统度量架构[J]. 中国科学院大学学报, 2009, 26(4): 522-529.</mixed-citation></ref><ref id="hanspub.20222-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Smith, S.W. (2004) Outbound Authentication for Programmable Secure Coprocessors. International Journal of Information Security, 3, 28-41. &lt;br&gt;https://doi.org/10.1007/s10207-004-0033-0</mixed-citation></ref><ref id="hanspub.20222-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Trusted, B.G. (2010) Computing Group. Trusted Platform Module (TPM) Specifications.</mixed-citation></ref><ref id="hanspub.20222-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Parno, B., Mccune, J.M. and Perrig, A. (2010) Bootstrapping Trust in Commodity Computers. Security and Privacy. IEEE,:414-429.</mixed-citation></ref><ref id="hanspub.20222-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">国家密码管理局. 可信计算密码支撑平台功能与接口规范[S]. 国家密码管理局, 2007.</mixed-citation></ref><ref id="hanspub.20222-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Sailer, R., Zhang, X., Jaeger, T., et al. (2004) Design and Implementation of a TCG-Based Integrity Measurement Architecture. Conference on USENIX Security Symposium, San Diego, 9-13 August 2004, 16.</mixed-citation></ref><ref id="hanspub.20222-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">戴正华. UEFI原理与编程[M]. 北京: 机械工业出版社, 2015.</mixed-citation></ref><ref id="hanspub.20222-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">The Unified EFI Forum (2011) Unified Extensible Firmware Interface Specification Version 2.3.1. &lt;br&gt;http://www.uefi.org</mixed-citation></ref><ref id="hanspub.20222-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">周艺华, 王伟, 王冠, 等. 基于固件的远程身份认证[J]. 信息安全与技术, 2016, 7(3): 35-39.</mixed-citation></ref><ref id="hanspub.20222-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">国家密码管理局. SM3密码杂凑算法(SM3 Cryptographic Hash Algorithm)[M]. 国家密码管理局, 2010.  
&lt;br&gt;http://www.oscca.gov.cn/UpFile/20101222141857786.pdf</mixed-citation></ref><ref id="hanspub.20222-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">王小云, 于红波. SM3密码杂凑算法[J]. 信息安全研究, 2016, 2(11): 983-994.</mixed-citation></ref></ref-list></back></article>