<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2018.85067</article-id><article-id pub-id-type="publisher-id">CSA-24764</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20180500000_23670895.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  云计算下基于无证书的跨域认证密钥交换协议
  Cross-Domain Authentication Key Exchange Protocol Based on Certificateless in Cloud Computing Environment
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>张</surname><given-names>兴兰</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>黎</surname><given-names>丁玲</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>北京工业大学信息学部，北京</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>03</day><month>05</month><year>2018</year></pub-date><volume>08</volume><issue>05</issue><fpage>591</fpage><lpage>600</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   基于椭圆曲线上的离散对数难题和双线性对运算，提出了一个云计算中基于无证书的跨域认证密钥交换协议，并且在eCK (extended Canetti-Krawczyk)模型下证明所提出协议的安全性。该协议满足了不同云之间的认证，一个云中用户的私钥由用户自己生成的秘密值和该云中的认证服务器生成的部分私钥两部分组成，充分保证了用户私钥的安全。用户身份认证的计算交由云认证服务器完成，用户认证和密钥协商经由一次交互完成，提高了协议执行效率。 Based on the discrete logarithm problem and bilinear pairings on the elliptic curve, this paper proposed a certificateless cross-domain authentication key exchange protocol in cloud computing environment and was proved secure in extended eCK model. The protocol satisfied the authentication between the different clouds and the user’s private key in a cloud consisted of a secret value selected by the user and a partial private key generated by the authentication server in the cloud. It’s fully guaranteed the security of the user’s private key. The calculation in user identity authentication finished by the cloud authentication server and user authentication and key agreement were completed in an interaction. It has improved the execution efficiency of the agreement. 
  
 
</p></abstract><kwd-group><kwd>云计算，无证书，跨域认证，密钥交换，eCK模型, Cloud Computing</kwd><kwd> Certificateless</kwd><kwd> Cross-Domain Authentication</kwd><kwd> Key Exchange</kwd><kwd> ECK Model</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>云计算下基于无证书的跨域认证密钥交换协议<sup> </sup></title><p>张兴兰，黎丁玲<sup>*</sup></p><p>北京工业大学信息学部，北京</p><disp-formula id="hanspub.24764-formula95"><graphic xlink:href="//html.hanspub.org/file/3-1541010x5_hanspub.png"  xlink:type="simple"/></disp-formula><p>收稿日期：2018年4月12日；录用日期：2018年4月26日；发布日期：2018年5月3日</p><disp-formula id="hanspub.24764-formula96"><graphic xlink:href="//html.hanspub.org/file/3-1541010x6_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>基于椭圆曲线上的离散对数难题和双线性对运算，提出了一个云计算中基于无证书的跨域认证密钥交换协议，并且在eCK (extended Canetti-Krawczyk)模型下证明所提出协议的安全性。该协议满足了不同云之间的认证，一个云中用户的私钥由用户自己生成的秘密值和该云中的认证服务器生成的部分私钥两部分组成，充分保证了用户私钥的安全。用户身份认证的计算交由云认证服务器完成，用户认证和密钥协商经由一次交互完成，提高了协议执行效率。</p><p>关键词 :云计算，无证书，跨域认证，密钥交换，eCK模型</p><disp-formula id="hanspub.24764-formula97"><graphic xlink:href="//html.hanspub.org/file/3-1541010x7_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2018 by authors and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/3-1541010x8_hanspub.png" /> <img src="//html.hanspub.org/file/3-1541010x9_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>云计算作为一种新兴的资源共享模式，充分利用了分布式计算 [<xref ref-type="bibr" rid="hanspub.24764-ref1">1</xref>] 和虚拟资源管理等一些技术，并且整合了网络中大量的资源，为用户提供了存储、计算、软件以及平台等服务 [<xref ref-type="bibr" rid="hanspub.24764-ref2">2</xref>] 也给用户带来极大的便利条件，但云计算的不断发展和普及，随之而来的则是安全 [<xref ref-type="bibr" rid="hanspub.24764-ref3">3</xref>] 方面的问题。</p><p>云计算依照部署模型可分为：公有云、私有云、社区云和混合云四种类型 [<xref ref-type="bibr" rid="hanspub.24764-ref4">4</xref>] 。混合云一般由多个云组成，每个云都有自己的用户身份管理系统。每个云中，有云内用户信任的认证服务器，提供用户注册等请求。而云间的资源共享要求，用户在访问自己所属云之外的其它云时，要考虑与不同云用户的身份认证 [<xref ref-type="bibr" rid="hanspub.24764-ref5">5</xref>] 和密钥协商 [<xref ref-type="bibr" rid="hanspub.24764-ref6">6</xref>] 。</p><p>针对云计算中存在的跨域认证 [<xref ref-type="bibr" rid="hanspub.24764-ref7">7</xref>] 问题，Xu C等 [<xref ref-type="bibr" rid="hanspub.24764-ref8">8</xref>] 基于零知识证明和密钥托管的思想提出了一个认证方案，该方法实现了匿名性和用户真实信息的追踪。Castiglione A等 [<xref ref-type="bibr" rid="hanspub.24764-ref9">9</xref>] 基于盲签名实现了一个跨域认证方案来支持用户身份验证，保护用户身份信息。这个方案满足了匿名性，可以避免中间人攻击，服务器的欺骗攻击等。解福 [<xref ref-type="bibr" rid="hanspub.24764-ref10">10</xref>] 实现了基于验证元客户端到客户端的跨域认证协议，能够抵御主动和被动攻击，但该协议的交互复杂。现有的方案需要在认证服务器上保存用户的身份信息或者用来验证身份的信息，因此存在证书管理问题。2003年，Al-Riyami和Paterson [<xref ref-type="bibr" rid="hanspub.24764-ref11">11</xref>] 提出无证书的公钥密码体制，这一体制解决了密钥托管问题。</p><p>本文提出了一个基于无证书的跨域认证方案，并且在eCK模型 [<xref ref-type="bibr" rid="hanspub.24764-ref12">12</xref>] 下证明了所提出协议的安全性。在本文的协议中，私钥由两部分组成，不存在密钥托管问题。经过一次交互就完成了用户认证和密钥协商，提高了协议的效率，用户认证部分也充分利用了云服务器的计算能力，适合于云计算环境。</p></sec><sec id="s4"><title>2. 预备知识</title><sec id="s4_1"><title>2.1. 椭圆曲线上的双线性映射</title><p>双线性对 [<xref ref-type="bibr" rid="hanspub.24764-ref13">13</xref>] 是两个循环群间的线性映射关系。设 G 1 和 G 2 分别是阶为q的加法循环群和乘法循环群，q是大素数，且在 G 1 和 G 2 中离散对数问题都是难解的。e是 G 1 &#215; G 1 → G 2 的双线性映射，要满足以下性质：</p><p>1) 双线性：对于任意 P , Q ∈ G 1 , a , b ∈ Z q * ，满足 e ( a P , b Q ) = e ( P , Q ) a b ；对于任意 P 1 , P 2 , Q ∈ G 1 ，有 e ( P 1 + P 2 , Q ) = e ( P 1 , Q ) &#215; e ( P 2 , Q ) 。</p><p>2) 非退化性：若P是 G 1 的生成元，则 e ( P , P ) ∈ G 2 是 G 2 的生成元，即 e ( P , P ) ≠ 1 。</p><p>3) 可计算性：有多项式时间算法可计算映射e。</p></sec><sec id="s4_2"><title>2.2. 相关困难问题及假设</title><p>CDH(Computational Diffie-Hellman)问题：G为q阶的循环加法群，P为G的生成元，给定 P , a P , b P ∈ G (其中 a , b ∈ Z q * )，计算<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x25_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>定义1：在安全参数λ 下多项式时间算法A解决CDH问题的优势为 A d v A C D H ( λ ) = Pr [ A ( P , a P , b P ) = a b P | P ∈ G , a , b ∈ Z q * ]</p><p>定义2：CDH假设：对于任意多项式时间算法A ， A d v A C D H ( λ ) 是可忽略的。</p></sec><sec id="s4_3"><title>2.3. 安全模型</title><p>针对无证书认证密钥交换协议，有两种类型的敌手 [<xref ref-type="bibr" rid="hanspub.24764-ref14">14</xref>] 。敌手 A 1 不知道系统主密钥，但是<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x29_hanspub.png" xlink:type="simple"/></inline-formula>可以把任意协议参与者的公钥替换成自己所选的值。敌手 A 2 知道系统所拥有的主密钥，但是不可以替换协议参与者的公钥。</p><p>∏ i , j s 表示参与者i和j的第s个会话。</p><p>Lippold [<xref ref-type="bibr" rid="hanspub.24764-ref15">15</xref>] 等将传统的eCK模型扩展成为无证书下的eCK模型，该模型是通过挑战者C和敌手 A ∈ { A 1 , A 2 } 之间进行的游戏来定义的。该游戏分成两个阶段：</p><p>阶段1：敌手可以以任何顺序进行以下查询。</p><p>Create(i)：C为身份是 I D i 的协议参与者i生成公钥和私钥对。</p><p>RevealMasterKey：C 把系统主密钥返回给敌手A。</p><p>RevealSessionKey( ∏ i , j s )：如果该会话已计算出会话密钥，则把该会话密钥返回，否则返回 ⊥ 。</p><p>RevealPartialPrivateKey(i)：C把参与者i的部分私钥返回给敌手A。</p><p>RevealSecretValue(i)：C把参与者i的秘密值返回给敌手A。</p><p>ReplacePublicKey(i,pk)：C把参与者i的公钥更换为A所选的值pk。</p><p>RevealEphemeralKey( ∏ i , j s )：C把参与者i的临时密钥返回给A。</p><p>Send( ∏ i , j s ,m)：A向会话发送消息m，然后依据协议的执行得到相应的响应信息。</p><p>如果A认为第一个阶段的查询结束了，则A选一个新鲜会话，然后进行游戏的第二阶段，执行Test()查询。</p><p>阶段2：Test()：第一阶段询问结束，A选一个新鲜会话 ∏ i , j s 执行Test查询。随机选 b ∈ { 0 , 1 } ，如果 b = 0 ，则返给A会话密钥，如果 b = 1 ，则在会话密钥空间里选一个随机的值返回给A。</p><p>在游戏的最后，A输出对b的猜测 b ′ ，如果 b ′ = b ，则A赢得游戏。A赢得该游戏的优势为<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x44_hanspub.png" xlink:type="simple"/></inline-formula>，其中k为安全参数。</p><p>定义3：新鲜会话。为参与者i和j已经结束的会话。如果下面的条件都不成立，则称是新鲜的。</p><p>1) A查询了的会话密钥。</p><p>2) A查询了i拥有的部分私钥或秘密值和会话的临时密钥。</p><p>定义4：安全性。当认证密钥交换协议达到如下条件 [<xref ref-type="bibr" rid="hanspub.24764-ref16">16</xref>] 时，则称该协议是安全的。</p><p>1) 若攻击者诚实的转发消息，且参与者接受该会话，则参与者能获得在会话密钥空间内均匀分布的密钥。</p><p>2) 对于任意的多项式时间敌手A，能够赢得游戏的概率是可忽略的。</p></sec></sec><sec id="s5"><title>3. 基于无证书的跨域认证方案</title><p>基于苏航等 [<xref ref-type="bibr" rid="hanspub.24764-ref17">17</xref>] 的无证书方案设计和CDH假设，提出了本文的协议。</p><sec id="s5_1"><title>3.1. 方案设计</title><p>1) 系统初始化算法</p><p>选取满足安全常数λ的阶为q的椭圆曲线循环群 G 1 和 G 2 ，即 | q | = λ ， G 1 的生成元为P。 G 1 和 G 2 分别是加法循环群和乘法循环群，e是 G 1 &#215; G 1 → G 2 的双线性映射。选取安全散列函数 H 1 : { 0 , 1 } * &#215; G 1 → Z q * ， H 2 : G 1 → K ，其中K是会话密钥空间。</p><p>域A和域B分别选取 s A ∈ Z q * ， s B ∈ Z q * 作为系统主私钥即 m s k A = s A ， m s k B = s B ，计算公钥 P p u b A = s A P ， P p u b B = s B P 。域A和域B在各自域内公开系统参数 p a r a m s A = { G 1 , G 2 , e , q , P , H 1 , H 2 , P p u b A } 和 p a r a m s B = { G 1 , G 2 , e , q , P , H 1 , H 2 , P p u b B } 。</p><p>2) 用户部分私钥生成算法</p><p>域A内用户user向域A发出注册请求并发送自己的身份信息 I D U ，域A随机选 g ∈ Z q * ，计算 k = s A + g H 1 ( I D U ∥ g P ) 并把它作为用户的部分私钥，并把 { g P , k } 发送给user。</p><p>user验证 k P = P p u b A + g P H 1 ( I D U ∥ g P ) ，相等则接收k。若等式不成立，则拒绝此部分私钥。</p><p>3) 用户公私钥生成算法</p><p>用户user随机选 ，计算私钥 d U = k + x ，输出公钥 p k U : { g P , x P } 。</p><p>4) 密钥协商算法</p><p>用户user选择临时密钥 t U ∈ Z q * ，计算临时信息 T U = t U d U P ， T ′ U = t U P 。选随机数 N r ，同时用域B的公钥加密 H 1 ( I D U ∥ g P ) 和随机数 N r ，得到 e U = { H 1 ( I D U ∥ g P ) , N r } P p u b B ，把 T U , T ′ U , e U , p k U 发送给域B。</p><p>域B解密 e U 得到 H 1 ( I D U ∥ g P ) 和 N r 验证等式 e ( T U , P ) = e ( T ′ U , P p u b A ) e ( g P H 1 ( I D U ∥ g P ) , T ′ U ) e ( T ′ U , x P ) ，验证通过则选择临时密钥 t B ∈ Z q * ， 计算临时信息 T B = t B s B P ，计算出会话密钥 s k B 后用该会话密钥加密 N r 得到 e B = { N r } s k B ，把 { T B , e B , P p u b B } 发送给用户user。</p><p>用户user解密 e B 得到 N ′ r ，确认<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x90_hanspub.png" xlink:type="simple"/></inline-formula>和 N ′ r 是不是相等，若相等，则可确定域B的身份，进而双方可用计算得到的会话密钥进行安全的通信。</p><p>用户user计算：</p><p>k U 1 = d U T B + d U t U s B P</p><p>k U 2 = t U d U T B = t U t B d U s B P</p><p>会话密钥 s k U = H 2 ( T U ∥ T B ∥ k U 1 ∥ k U 2 )</p><p>域B计算：</p><p>k B 1 = s B T U + t B s B ( P p u b A + g P H 1 ( I D U ∥ g P ) + x P )</p><p>k B 2 = t B s B T U = t B t U s B d U P</p><p>会话密钥 s k B = H 2 ( T U ∥ T B ∥ k B 1 ∥ k B 2 )</p></sec><sec id="s5_2"><title>3.2. 正确性分析</title><p>1) 域B验证用户的正确性</p><p>e ( T U , P ) = e ( t U d U P , P ) = e ( t U ( k + x ) P , P ) = e ( t U ( s A + g H 1 ( I D U ∥ g P ) + x ) P , P ) = e ( ( t U s A + t U g H 1 ( I D U ∥ g P ) + t U x ) P , P ) = e ( t U s A P , P ) e ( t U g H 1 ( I D U ∥ g P ) P , P ) e ( t U x P , P ) = e ( P , P ) t U s A e ( P , P ) t U g H 1 ( I D U ∥ g P ) e ( P , P ) t U x</p><p>e ( T ′ U , P p u b A ) e ( g P H 1 ( I D U ∥ g P ) , T ′ U ) e ( T ′ U , x P ) = e ( t U P , s A P ) e ( g P H 1 ( I D U ∥ g P ) , t U P ) e ( t U P , x P ) = e ( P , P ) t U s A e ( P , P ) t U g H 1 ( I D U ∥ g P ) e ( P , P ) t U x</p><p>2) 协议的正确性</p><p>协议正确，则需证明用户user和域B计算得到了相同的会话密钥，即证明 s k U = s k B 。</p><p>用户user的计算如下：</p><p>k U 1 = d U T B + d U t U s B P = d U t B s B P + d U t U s B P = ( t B + t U ) d U s B P</p><p>域B的计算如下：</p><p>k B 1 = s B T U + t B s B ( P p u b A + g P H 1 ( I D U ∥ g P ) + x P ) = s B T U + t B s B ( k P + x P ) = s B T U + t B s B d U P = s B t U d U P + t B s B d U P = ( t U + t B ) d U s B P</p><p>由计算结果可知，用户user和域B能得到一样的会话密钥。</p></sec><sec id="s5_3"><title>3.3. 安全性证明</title><p>下面给出本文提出的协议在eCK模型下的安全性的证明， H 1 和<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x104_hanspub.png" xlink:type="simple"/></inline-formula> 是随机预言机。</p><p>引理1：由于CDH问题是困难问题，则本文协议在 A 1 的攻击下是安全的。</p><p>证明：假设 A 1 能 以不可忽略的优势<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x107_hanspub.png" xlink:type="simple"/></inline-formula>赢得2.3节中定义的游戏。那么挑战者C可以利用 A 1 的能力解决CDH问题。C随机选 P 0 ∈ G 1 ，设置 P 0 为协商用户所在域(域A)的公钥，并令 P p u b A = P 0 。令域A内全局系统参数为 { G 1 , G 2 , e , q , P , H 1 , H 2 , P 0 } ，并把该参数发给 A 1 。</p><p>令 n 0 为参与方可拥有的最多会话数， n 1 为最多激活的用户数， n 2 为最多进行的哈希询问次数。令 A d v C C D H 为C 解决CDH问题的优势。为了解决CDH问题，给定CDH挑战 U = u P ， V = v P ( u , v ∈ Z q * ) 和一个预言机DDH(*,*,*)，C 的任务是计算 C D H ( U , V ) = u v P 。C 模拟2.3节中定义的游戏，在游戏中C要回答 A 1 的所有询问。</p><p>在游戏开始前，C 随机选 u ∈ { 1 ⋯ n 1 } ，代表参与跨域认证的用户。随机选 t ∈ { 1 ⋯ n 0 } ，选择<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x124_hanspub.png" xlink:type="simple"/></inline-formula>作为Test会话。</p><p>将敌手攻击的情况 [<xref ref-type="bibr" rid="hanspub.24764-ref18">18</xref>] 分为以下几种来讨论：</p><p>1) 不知道用户的部分私钥和域B的临时密钥。</p><p>Create(i)：C维护一个初始为空的列表 L C ，其中存储的元组格式为 ( I D i , k i , G i , x i , P i ) ，如果 i = u ，C随机选 x i , h i ∈ Z q * ，计算 G i = ( U − P 0 ) h i − 1 ， P i = x i P ，设置<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x131_hanspub.png" xlink:type="simple"/></inline-formula>，并在 L C 中存储 ( I D i , ⊥ , G i , x i , P i ) ，在 L H 1 中存储 ( I D i , G i , h i ) 。如果 i ≠ u ，随机选 k i , x i , h i ∈ Z q * ，计算 G i = ( k i P − P 0 ) h i − 1 ， P i = x i P ， 设置 H 1 ( I D i ∥ G i ) = h i ，并在 L C 中存储 ( I D i , k i , G i , x i , P i ) ，在 L H 1 中存储<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x144_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>H 1 ( I D i , G i ) 询问：C维护一个初始为空的列表 L H 1 ，其中存储的元组格式为 ( I D i , G i , h i ) 。如果 ( I D i , G i ) 在 L H 1 中，则返回 h i 给 h i 。否则随机选择 h i ∈ Z q * 返回给 A 1 ，并在 L H 1 中存储 ( I D i , G i , h i ) 。</p><p><inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x156_hanspub.png" xlink:type="simple"/></inline-formula>询问：C维护一个初始为空的列表 L H 2 ，记录的元组格式为 ( I D i , T i , T B , Z 1 , Z 2 , s k ) 。如果查询的元组在 L H 2 中，则返回 s k 给 A 1 。否则按如下操作：</p><p>如果 i = u ，C 在列表 L S 中找形如 ( I D i , T i , T B , p k i , s k ) 的元祖，若找到，则计算</p><p>Z 1 &#175; = Z 1 − x i ( T B + t i P p u b B )</p><p>Z 2 &#175; = Z 2 − x i t i T B</p><p>C 检查分别输入<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x167_hanspub.png" xlink:type="simple"/></inline-formula>， ( P 0 + G i H 1 ( I D i ∥ G i ) , t i T B , Z 2 &#175; ) ，DDH预言机是否输出1。如果 Z 1 和 Z 2 计算正确，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ， s k 为 L S 中的值。如果计算错误，则随机选 s k ∈ K ，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x178_hanspub.png" xlink:type="simple"/></inline-formula>给 A 1 。</p><p>如果 i ≠ u ，在列表 L S 中找形如 ( I D i , T i , T B , p k i , s k ) 的元祖，若找到，则在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ， s k 为 L S 中的值。否则随机选<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x187_hanspub.png" xlink:type="simple"/></inline-formula>，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回 s k 给 A 1 。</p><p>RevealMasterKey：C 停止模拟。</p><p>RevealSessionKey( ∏ i , j s )：如果 ∏ i , j s = ∏ u , B t ，则C 停止模拟，否则把会话密钥 s k 返回给 A 1 。</p><p>RevealPartialPrivateKey(i)：如果 i = u ，则C停止模拟，否则把部分私钥 k i 返回给 A 1 。</p><p>RevealSecretValue(i)：C查找 L C 列表，若找到形如 ( I D i , ∗ , ∗ , ∗ , ∗ ) 的元组，则返回 x i 给 A 1 。否则执行Create(i)，返回 x i 给 A 1 。</p><p>ReplacePublicKey(i,pk)：C查找 L C 列表，若找到形如 ( I D i , ∗ , ∗ , ∗ , ∗ ) 的元组，则替换 x i 和 P i 为 和 P ′ i ，其中 p k = P ′ i ， P ′ i = x ′ i P 。若没有找到，则执行Create(i)，再替换 x i 和 P i 为<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x215_hanspub.png" xlink:type="simple"/></inline-formula>和 P ′ i 。</p><p>RevealEphemeralKey(i)：如果 ∏ i , j s = ∏ u , B t ，则C停止模拟，否则C发送临时密钥给<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x218_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>Send( ∏ i , j s ,m)：C维护一个初始为空的列表 L S ，其中存储的元组格式为 ( I D i , T i , T B , p k i , s k ) 。</p><p>如果 ∏ i , j s = ∏ u , B t ，则返回 T B = V 给 A 1 。</p><p>如果 i = u ，C 随机选择 t i ∈ Z q * ，并计算</p><p>Z 1 &#175; = Z 1 − x i ( T B + t i P p u b B )</p><p>Z 2 &#175; = Z 2 − x i t i T B</p><p>C 检查分别输入<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x229_hanspub.png" xlink:type="simple"/></inline-formula>， ( P 0 + G i H 1 ( I D i ∥ G i ) , t i T B , Z 2 &#175; ) ，DDH预言机是否输出1，如果 Z 1 和 Z 2 计算正确，则在 L S 中记录 ( I D i , T i , T B , p k i , s k ) ， s k 为 L H 2 中的值。否则，随机选<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x237_hanspub.png" xlink:type="simple"/></inline-formula>，在 L S 中存储 ( I D i , T i , T B , p k i , s k ) 。</p><p>如果 i ≠ u ，则按协议规则进行回答。</p><p>Test()：如果 ∏ i , j s = ∏ u , B t ，则C停止模拟，否则，C随机选 s k ∈ K ，并把 s k 返回给 A 1 。</p><p>假设 A 1 能够 赢该游戏，那么 A 1 一定计算出了准确的 Z 1 和 Z 2 。C 有 1 n 2 的概率在 L H 2 中找到正确的元组。 C 计算：</p><p>Z 2 &#175; = Z 2 − x i t i T B = t i C D H ( U , V )</p><p>C D H ( U , V ) = t i − 1 ( Z 2 − x i t i V )</p><p>则 C 解决CDH问题的优势 A d v C C D H ≥ 1 n 0 n 1 n 2 A d v A 1 ，C以不可忽略的优势解决了CDH问题，这与CDH假设冲突。</p><p>2) 不知道用户的临时密钥和域B的临时密钥。</p><p>Create(i)：C 维护一个初始为空的列表 L C ，其中存储的元组格式为 ( I D i , k i , G i , x i , P i ) ，C 随机选 k i , x i , h i ∈ Z q * ，计算 G i = ( k i P − P 0 ) h i − 1 ，<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x258_hanspub.png" xlink:type="simple"/></inline-formula>，设置 H 1 ( I D i ∥ G i ) = h i ，并在 L C 中存储 ( I D i , k i , G i , x i , P i ) ，在 L H 1 中存储 ( I D i , G i , h i ) 。</p><p>H 2 ( I D i , T i , T B , Z 1 , Z 2 ) 询问：C 维护一个初始为空的列表 L H 2 ，其中存储的元组格式为 ( I D i , T i , T B , Z 1 , Z 2 , s k ) 。如果查询的元组在 L H 2 中，则返回 s k 给 A 1 。否则按如下操作：</p><p>C 在列表 L S 中找形如 ( I D i , T i , T B , p k i , s k ) 的元祖，若找到，则计算</p><p>Z 1 &#175; = Z 1 − ( k i + x i ) T B</p><p>C 检查分别输入<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x273_hanspub.png" xlink:type="simple"/></inline-formula>， ( T i , T B , Z 2 ) ，DDH预言机是否输出1。如果 Z 1 和 Z 2 计算正确，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ， 为 L S 中的值。如果计算错误，则随机选 s k ∈ K ，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x284_hanspub.png" xlink:type="simple"/></inline-formula>给 A 1 。</p><p>若没有找到，则随机选 s k ∈ K ，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回 s k 给 A 1 。</p><p>RevealPartialPrivateKey(i)：C 查找列表 L C ，把相应的部分私钥 k i 返回给 A 1 。</p><p>RevealEphemeralKey(<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x294_hanspub.png" xlink:type="simple"/></inline-formula>)：如果 ∏ i , j s = ∏ u , B t ，或者 ∏ i , j s = ∏ B , u t ，则C 停止模拟，否则C 发送临时密钥给 A 1 。</p><p>Send( ∏ i , j s ,m)：C维护一个初始为空的列表 L S ，其中存储的元组格式为 ( I D i , T i , T B , p k i , s k ) 。</p><p>如果 ∏ i , j s = ∏ u , B t ，C返回 T i = U 给 A 1 ，如果 ∏ i , j s = ∏ B , u t ，则返回 T B 给 A 1 。否则按协议规则进行回答。</p><p>除以上询问外，其它情况和1)中相同。</p><p>假设 A 1 能够 赢该游戏，则 A 1 一定计算出了准确的 Z 1 和 Z 2 。C有 1 n 2 的概率在 L H 2 中找到正确的元组。 C D H ( U , V ) = Z 2 。</p><p>则 C 解决CDH问题的优势 A d v C C D H ≥ 1 n 0 n 1 n 2 A d v A 1 ，C以不可忽略的优势解决了CDH问题，这与CDH假设冲突。</p><p>引理2：由于CDH问题是困难问题，则本文协议在 A 2 的攻击下是安全的。</p><p>证明：假设 A 2 能 以不可忽略的优势 A d v A 2 赢得2.3节中定义的游戏。那么挑战者C可以利用 A 2 的能力解决CDH问题。</p><p>C随机选 s ∈ Z q * ，设置 s P 作为用户所在域(域A)的系统公钥，并发送s给 A 2 。其它参数的设置和引理1的证明相同。</p><p>将敌手攻击的情况分为以下几种来讨论：</p><p>不知道用户的私有秘密值和域B的临时密钥。</p><p>Create(i)：C 维护一个初始为空的列表 L C ，其中存储的元组格式为<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/3-1541010x323_hanspub.png" xlink:type="simple"/></inline-formula>，如果 i = u ，C 随机选 g i , h i ∈ Z q * ，计算 G i = g i P ， P i = U ， k i = s + g i h i ，设置 H 1 ( I D i ∥ G i ) = h i ，并在 L C 中存储 ( I D i , k i , G i , ⊥ , P i ) ，在 L H 1 中存储 ( I D i , G i , h i ) 。如果 i ≠ u ，随机选 x i , g i , h i ∈ Z q * ，计算 G i = g i P ， P i = x i P ， k i = s + g i h i ，设置 H 1 ( I D i ∥ G i ) = h i ，并在 L C 中存储 ( I D i , k i , G i , x i , P i ) ，在 L H 1 中存储 ( I D i , G i , h i ) 。</p><p>H 2 ( I D i , T i , T B , Z 1 , Z 2 ) 询问：C 维护一个初始为空的列表 L H 2 ，其中存储的元组格式为 ( I D i , T i , T B , Z 1 , Z 2 , s k ) 。如果查询的元组在 L H 2 中，则返回 s k 给 。否则按如下操作：</p><p>如果 i = u ，C 在列表 L S 中找形如 ( I D i , T i , T B , p k i , s k ) 的元祖，若找到，则计算</p><p>Z 1 &#175; = Z 1 − k i ( T B + t i P p u b B )</p><p>Z 2 &#175; = Z 2 − k i t i T B</p><p>C检查分别输入 ( P i , T B + t i P p u b B , Z 1 &#175; ) ， ( P i , t i T B , Z 2 &#175; ) ，DDH预言机是否输出1。如果 Z 1 和 Z 2 计算正确，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ， s k 为 L S 中的值。如果计算错误，则随机选 s k ∈ K ，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回 s k 给 A 2 。</p><p>如果 i ≠ u ，在列表 L S 中找形如 ( I D i , T i , T B , p k i , s k ) 的元祖，若找到，则在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ， s k 为 L S 中的值。否则随机选 s k ∈ K ，在 L H 2 中存储 ( I D i , T i , T B , Z 1 , Z 2 , s k ) ，并返回 s k 给 A 2 。</p><p>RevealMasterKey：C把主私钥返回给 A 2 。</p><p>RevealPartialPrivateKey(i)：C把部分私钥 k i 返回给 A 2 。</p><p>RevealSecretValue(i)：如果 i = u ，则停止模拟，否则C查找 L C 列表，若找到形如 ( I D i , ∗ , ∗ , ∗ , ∗ ) 的元组，则返回 x i 给 A 2 。否则执行Create(i)，返回 x i 给 A 2 。</p><p>Send( ∏ i , j s ,m)：C维护一个初始为空的列表 L S ，记录的元组格式为 ( I D i , T i , T B , p k i , s k ) 。</p><p>如果 ∏ i , j s = ∏ u , B t ，则返回 T B = V 给 A 2 。</p><p>如果 i = u ，C随机选择 t i ∈ Z q * ，并计算</p><p>Z 1 &#175; = Z 1 − k i ( T B + t i P p u b B )</p><p>Z 2 &#175; = Z 2 − k i t i T B</p><p>C检查分别输入 ( P i , T B + t i P p u b B , Z 1 &#175; ) ， ( P i , t i T B , Z 2 &#175; ) ，DDH预言机是否输出1。如果 Z 1 和 Z 2 计算正确，则在 L S 中记录 ( I D i , T i , T B , p k i , s k ) ， s k 为 L H 2 中的值。否则，随机选 s k ∈ K ，在 L S 中存储 ( I D i , T i , T B , p k i , s k ) 。</p><p>如果 i ≠ u ，则按协议规则进行回答。</p><p>除以上询问外，其它情况和引理1的证明1)中相同。</p><p>假设 A 2 能够 赢得该游戏，则 A 2 一定计算出了准确的 Z 1 和 Z 2 。C有 1 n 2 的概率在 L H 2 中找到正确的元组。C计算：</p><p>Z 2 &#175; = Z 2 − k i t i T B = t i C D H ( U , V )</p><p>C D H ( U , V ) = t i − 1 ( Z 2 − k i t i V )</p><p>则C解决CDH问题的优势 A d v C C D H ≥ 1 n 0 n 1 n 2 A d v A 2 ，C以不可忽略的优势解决了CDH问题，这与CDH假设冲突。</p><p>剩余情况和引理1类似。</p><p>由以上引理的证明，可知本文所提出的协议在eCK模型下是安全的。</p></sec></sec><sec id="s6"><title>4. 性能分析与比较</title><p>本文协议和文献 [<xref ref-type="bibr" rid="hanspub.24764-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.24764-ref10">10</xref>] 的协议在构造上有差别，所以从方案的交互次数、加解密次数方面比较了这</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Performance comparison of different solution</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >性能</th><th align="center" valign="middle" >文献 [<xref ref-type="bibr" rid="hanspub.24764-ref8">8</xref>]</th><th align="center" valign="middle" >文献 [<xref ref-type="bibr" rid="hanspub.24764-ref10">10</xref>]</th><th align="center" valign="middle" >本文方案</th></tr></thead><tr><td align="center" valign="middle" >方案交互次数</td><td align="center" valign="middle" >5</td><td align="center" valign="middle" >8</td><td align="center" valign="middle" >4</td></tr><tr><td align="center" valign="middle" >加解密次数</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >5</td><td align="center" valign="middle" >2</td></tr><tr><td align="center" valign="middle" >密钥托管问题</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >否</td></tr></tbody></table></table-wrap><p>表1. 各方案性能比较</p><p>三个方案。</p><p>和文献 [<xref ref-type="bibr" rid="hanspub.24764-ref8">8</xref>] 和文献 [<xref ref-type="bibr" rid="hanspub.24764-ref10">10</xref>] 相比，本文解决了密钥托管问题，而且交互次数和加解密次数都相应的减少。文献 [<xref ref-type="bibr" rid="hanspub.24764-ref8">8</xref>] 基于零知识证明实现了方案的匿名性和可追踪性，但是缺乏对所提出方案详细的安全性证明。文献 [<xref ref-type="bibr" rid="hanspub.24764-ref10">10</xref>] 所提出协议的参与方有四方，交互过于复杂，且对于方案的安全性也是给出了相应的分析缺乏详尽的证明。分析说明，本文的方案保证了安全性的同时，还降低了开销。</p></sec><sec id="s7"><title>5. 结语</title><p>本文基于无证书提出了一个云计算下的跨域认证密钥交换协议。实现了用户的跨域认证，降低了服务器的压力，充分保证了用户的密钥安全，与同类协议相比(表1)，提高了认证和密钥协商的效率。</p></sec><sec id="s8"><title>基金项目</title><p>国家自然科学基金(10007016201201)。</p></sec><sec id="s9"><title>文章引用</title><p>张兴兰,黎丁玲. 云计算下基于无证书的跨域认证密钥交换协议Cross-Domain Authentication Key Exchange Protocol Based on Certificateless in Cloud Computing Environment[J]. 计算机科学与应用, 2018, 08(05): 591-600. https://doi.org/10.12677/CSA.2018.85067</p></sec><sec id="s10"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.24764-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Buyya, R., Yeo, C.S. and Venugopal, S. (2008) Market-Oriented Cloud Computing: Vision, Hype, and Reality for Delivering IT Ser-vices as Computing Utilities. IEEE International Conference on High PERFORMANCE Computing and Communications, 10-1016.</mixed-citation></ref><ref id="hanspub.24764-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">吴吉义, 傅建庆, 平玲娣, 谢琪. 一种对等结构的云存储系统研究[J]. 电子学报, 2011, 39(5): 1100-1107.</mixed-citation></ref><ref id="hanspub.24764-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">房晶, 吴昊, 白松林. 云计算安全研究综述[J]. 电信科学, 2011, 27(4): 37-42.</mixed-citation></ref><ref id="hanspub.24764-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">段志强. 混合云安全策略研究[J]. 计算机安全, 2014(8): 33-37.</mixed-citation></ref><ref id="hanspub.24764-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">张建晓. 身份认证技术及其发展趋势[J]. 信息通信, 2015(2): 125-126.</mixed-citation></ref><ref id="hanspub.24764-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">李文敏. 认证密钥协商协议的设计与应用[D]: [博士学位论文]. 北京: 北京邮电大学, 2012.</mixed-citation></ref><ref id="hanspub.24764-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">李小标. 跨域认证关键技术研究[D]: [博士学位论文]. 北京: 北京邮电大学, 2011.</mixed-citation></ref><ref id="hanspub.24764-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Xu, C. and He, J. (2015) A Cross-Domain Authentication Method for Cloud Computing. Interna-tional Journal of Security &amp; Its Applications, 9, 285-292. &lt;br&gt;https://doi.org/10.14257/ijsia.2015.9.3.22</mixed-citation></ref><ref id="hanspub.24764-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Castiglione, A., Palmieri, F., Chen, C.L., et al. (2016) A Blind Signature-Based Approach for Cross-Domain Authentication in the Cloud Environment. Interna-tional Journal of Data Warehousing &amp; Mining, 12, 34-48. 
&lt;br&gt;https://doi.org/10.4018/IJDWM.2016010103</mixed-citation></ref><ref id="hanspub.24764-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">解福. 云计算环境中认证与密钥协商关键技术研究[D]: [博士学位论文]. 济南: 山东师范大学, 2014.</mixed-citation></ref><ref id="hanspub.24764-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">Al-Riyami, S.S. and Paterson, K.G. (2003) Certificateless Public Key Cryptography. In: Advances in Cryptology-ASIACRYPT 2003, Springer, Berlin, Heidelberg, 452-473.</mixed-citation></ref><ref id="hanspub.24764-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">田静. eCK模型下认证密钥交换协议及其证明[D]: [硕士学位论文]. 沈阳: 东北大学, 2011.</mixed-citation></ref><ref id="hanspub.24764-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">翁江. 椭圆曲线密码中双线性对与离散对数问题研究[D]: [硕士学位论文]. 郑州: 解放军信息工程大学, 2012.</mixed-citation></ref><ref id="hanspub.24764-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">李贵莹. 基于无证书的两方认证密钥协商协议的研究与分析[D]: [硕士学位论文]. 济南: 山东大学, 2014.</mixed-citation></ref><ref id="hanspub.24764-ref15"><label>15</label><mixed-citation publication-type="other" xlink:type="simple">Lippold, G., Boyd, C. and Nieto, J.G. (2009) Strongly Secure Certificateless Key Agreement. In: Pairing-Based Cryptography—Pairing 2009, Springer, Berlin, Heidelberg, 206-230.</mixed-citation></ref><ref id="hanspub.24764-ref16"><label>16</label><mixed-citation publication-type="other" xlink:type="simple">周彦伟, 杨波, 张文政. 一种改进的无证书两方认证密钥协商协议[J]. 计算机学报, 2017, 40(5): 1181-1191.</mixed-citation></ref><ref id="hanspub.24764-ref17"><label>17</label><mixed-citation publication-type="other" xlink:type="simple">苏航, 刘建伟, 陶芮. 无证书的层次认证密钥协商协议[J]. 通信学报, 2016, 37(7): 161-171.</mixed-citation></ref><ref id="hanspub.24764-ref18"><label>18</label><mixed-citation publication-type="other" xlink:type="simple">He, D., Padhye, S. and Chen, J. (2012) An Efficient Certificateless Two-Party Authenticated Key Agreement Protocol. Computers and Mathematics with Applications, 64, 1914-1926. &lt;br&gt;https://doi.org/10.1016/j.camwa.2012.03.044</mixed-citation></ref></ref-list></back></article>