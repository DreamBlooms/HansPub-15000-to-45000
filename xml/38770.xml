<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2020.1011215</article-id><article-id pub-id-type="publisher-id">CSA-38770</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20201100000_85285010.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  基于约束一致策略的人工蜂群算法
  Artificial Bee Colony Algorithm Based on Constrained Consistent Strategy
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>吴</surname><given-names>钰晗</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>梁</surname><given-names>晓丹</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>天津工业大学计算机科学与技术学院，天津</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>09</day><month>11</month><year>2020</year></pub-date><volume>10</volume><issue>11</issue><fpage>2034</fpage><lpage>2048</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   在过去的研究中，进化算法逐渐被广泛应用于求解复杂优化问题。然而，利用进化算法解决约束优化问题时，常常不能得到很好的结果，因为它们不能直接减少约束问题的约束违反程度。为了能够更好地得到目标函数的最优解，且减少约束违反对最优解的影响，本文将人工蜂群算法(ABC)的全局优化优势和约束一致策略(CC)的稳定计算特性集成到一种新的混合启发式算法中——基于约束一致策略的人工蜂群算法(ABCCC)。在进化搜索过程中，约束一致策略对于快速减少约束违反是相当有效的。通过一组测试函数，以及基于约束一致策略的粒子群算法(PSOCC)和基于约束一致策略的差分进化算法(DECC)两种方法进行比较，证明ABCCC具有一定的处理约束优化问题的能力。实验结果表明，该算法在优化质量和收敛速度方面都具有良好的性能。 Over the last few decades, evolutionary algorithms have been widely used to solve complex optimization problems. However, when using evolutionary algorithms to solve constraint optimization problems, best results are often not obtained, because they cannot directly reduce the degree of constraint violation. In order to obtain the better optimal solution of the objective function and reduce the impact of constraint violation on the optimal solution, this paper integrates the global op-timization advantages of the artificial bee colony algorithm (ABC) and the stable computing characteristics of the constraint consensus strategy (CC) into a new hybrid heuristic algorithm—the constraint consensus strategy based artificial bee colony algorithm (ABCCC). During the evolutionary search, the constraint consensus strategy is quite effective for rapidly reducing constraint violations. Through a set of test functions and a comparison between PSOCC and DECC, it is proved that ABCCC has certain ability to deal with constraint optimization problems. Experimental results show that the algorithm has good performance in optimizing quality and convergence speed. 
  
 
</p></abstract><kwd-group><kwd>约束优化，人工蜂群算法，约束一致，进化算法, Constraint Optimization Problem</kwd><kwd> Artificial Bee Colony (ABC)</kwd><kwd> Constraint Consensus (CC)</kwd><kwd> Evolutionary Algorithms</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>摘要</title><p>在过去的研究中，进化算法逐渐被广泛应用于求解复杂优化问题。然而，利用进化算法解决约束优化问题时，常常不能得到很好的结果，因为它们不能直接减少约束问题的约束违反程度。为了能够更好地得到目标函数的最优解，且减少约束违反对最优解的影响，本文将人工蜂群算法(ABC)的全局优化优势和约束一致策略(CC)的稳定计算特性集成到一种新的混合启发式算法中——基于约束一致策略的人工蜂群算法(ABCCC)。在进化搜索过程中，约束一致策略对于快速减少约束违反是相当有效的。通过一组测试函数，以及基于约束一致策略的粒子群算法(PSOCC)和基于约束一致策略的差分进化算法(DECC)两种方法进行比较，证明ABCCC具有一定的处理约束优化问题的能力。实验结果表明，该算法在优化质量和收敛速度方面都具有良好的性能。</p></sec><sec id="s2"><title>关键词</title><p>约束优化，人工蜂群算法，约束一致，进化算法</p></sec><sec id="s3"><title>Artificial Bee Colony Algorithm Based on Constrained Consistent Strategy<sup> </sup></title><p>Yuhan Wu, Xiaodan Liang</p><p>School of Computer Science and Technology, Tiangong University, Tianjin</p><p><img src="//html.hanspub.org/file/13-1541933x4_hanspub.png" /></p><p>Received: Nov. 3<sup>rd</sup>, 2020; accepted: Nov. 18<sup>th</sup>, 2020; published: Nov. 25<sup>th</sup>, 2020</p><p><img src="//html.hanspub.org/file/13-1541933x5_hanspub.png" /></p></sec><sec id="s4"><title>ABSTRACT</title><p>Over the last few decades, evolutionary algorithms have been widely used to solve complex optimization problems. However, when using evolutionary algorithms to solve constraint optimization problems, best results are often not obtained, because they cannot directly reduce the degree of constraint violation. In order to obtain the better optimal solution of the objective function and reduce the impact of constraint violation on the optimal solution, this paper integrates the global optimization advantages of the artificial bee colony algorithm (ABC) and the stable computing characteristics of the constraint consensus strategy (CC) into a new hybrid heuristic algorithm—the constraint consensus strategy based artificial bee colony algorithm (ABCCC). During the evolutionary search, the constraint consensus strategy is quite effective for rapidly reducing constraint violations. Through a set of test functions and a comparison between PSOCC and DECC, it is proved that ABCCC has certain ability to deal with constraint optimization problems. Experimental results show that the algorithm has good performance in optimizing quality and convergence speed.</p><p>Keywords:Constraint Optimization Problem, Artificial Bee Colony (ABC), Constraint Consensus (CC), Evolutionary Algorithms</p><disp-formula id="hanspub.38770-formula6"><graphic xlink:href="//html.hanspub.org/file/13-1541933x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2020 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY 4.0).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/13-1541933x7_hanspub.png" /> <img src="//html.hanspub.org/file/13-1541933x8_hanspub.png" /></p></sec><sec id="s5"><title>1. 引言</title><p>约束优化问题是在给定约束条件下对目标函数进行优化的问题 [<xref ref-type="bibr" rid="hanspub.38770-ref1">1</xref>]，在实际应用中经常出现。具有不等式、等式、上界和下界约束的一般约束优化问题定义为：</p><p>min           f ( x ) s . t .                 g j ( x ) ≤ 0   ,     j = 1 , 2 , ⋯ , q                                     h j ( x ) = 0   ,     j = q + 1 , ⋯ , m                                       l i ≤ x i ≤ u i   ,   i = 1 , 2 , ⋯ , n (1)</p><p>其中 x = ( x 1 , x 2 , ⋯ , x n ) 为n维变量，f(x)为目标函数，g(x)为不等式约束，h(x)为等式约束，j为不等式或等式约束的个数，l<sub>i</sub>和u<sub>i</sub>分别是x<sub>i</sub>的下界和上界。上下界定义了约束优化问题的搜索空间，不等式和等式定义了可行域。可行域或边界上的点称为可行点，否则即为不可行点。</p><p>由于约束优化问题的复杂性，传统的进化算法难以求解。同时，进化算法大多是基于无约束优化问题的搜索技术，在应用进化算法求解约束优化问题时，其最优解可能不精确。因此，有必要结合合适的约束处理技术来处理约束优化问题。</p><p>本文提出了一种基于约束一致策略的人工蜂群算法(ABCCC)。人工蜂群算法(Artificial bee colony, ABC)是由Karaboga提出的一种最新的启发式算法，其灵感来自于蜜蜂的觅食行为，用于求解数值优化问题 [<xref ref-type="bibr" rid="hanspub.38770-ref2">2</xref>]。相对于差分进化算法(DE)和粒子群算法(PSO)，ABC算法有两个明显的优势：1) ABC在局部优化和全局优化方面都很好。2) ABC灵活、稳健、使用简单，它可以有效地应用于多模态、多变量问题的优化。为了驱动个体向可行域移动，在ABC算法中引入了约束一致策略。CC策略具有以下优点 [<xref ref-type="bibr" rid="hanspub.38770-ref3">3</xref>]：1) CC策略易于实现。2) CC计算量小，计算稳定性好。为了有效地结合ABC算法和CC策略，文中重新设计了对不可行个体的处理。即部分不可行个体采用CC策略进行进化，其余不可行个体和可行个体采用ABC算法进行再生。为了验证ABCCC的特性，采用CEC2017基准函数对其性能进行测试。实验表明，在大多数情况下，ABCCC收敛速度较快，收敛精度较好，并且能较好地考虑种群多样性问题。ABCCC与DECC和PSOCC相比也更具竞争力。然后利用ABCCC算法与其他算法(CALSHADE [<xref ref-type="bibr" rid="hanspub.38770-ref4">4</xref>]、UDE [<xref ref-type="bibr" rid="hanspub.38770-ref5">5</xref>]、CABC [<xref ref-type="bibr" rid="hanspub.38770-ref6">6</xref>] 和GABC [<xref ref-type="bibr" rid="hanspub.38770-ref7">7</xref>] )进行了比较。实验结果表明，ABCCC算法的性能优于其他算法。</p><p>本文组织结构如下，引言后，第2节详细阐述了约束一致策略，第3节介绍了人工蜂群算法，新算法的详细信息见第4节，第5节给出了实验结果和分析。最后，第6节对全文做了总结。</p></sec><sec id="s6"><title>2. 约束一致策略</title><p>约束一致策略(Constraint Consensus Strategy, CC)是一种同步分量平均梯度投影算法 [<xref ref-type="bibr" rid="hanspub.38770-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.38770-ref9">9</xref>] [<xref ref-type="bibr" rid="hanspub.38770-ref10">10</xref>]，主要的思想是通过采取某些行动，在当前违反的约束之间产生一个在行动的方向和距离上“一致意见”的结果，根据这个结果改进当前的不可行点以实现可行性。</p><p>约束一致策略算法的第一步就是找到在当前点x处违反的每个约束的可行性向量，对于每个约束违反，可行性向量近似从当前的不可行解到最近的可行解的移动。它对于线性约束是精确的，但对于非线性约束只是一个估计。衡量不可行点到可行区域的距离是点与可行区域之间的最小欧几里得距离，称为可行性距离 [<xref ref-type="bibr" rid="hanspub.38770-ref11">11</xref>]。可行性向量的计算公式如下：</p><p>f v = v   d ∇ c ( x ) / ‖ ∇ c ( x ) ‖ 2 (2)</p><p>其中，&#209;c(x)是约束的梯度，||&#209;c(x)||是它的长度；v是约束违反量，当满足约束条件时v = 0；d是一个方向参数，如果有必要增加c(x)满足约束条件则d + 1，如果有必要减少c(x)来满足约束条件则d − 1。可行性向量的长度表示为||fv||，也即可行性距离。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Pseudocode of constraint consensus strateg</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >Inputs:</th><th align="center" valign="middle"  colspan="5"  >a set of constraints c</th></tr></thead><tr><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="5"  >an initial point x</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="5"  >a feasibility distance tolerance a</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="5"  >a movement tolerance b</td></tr><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle"  colspan="5"  >NINF = 0, for all j: n<sub>j</sub> = 0, s<sub>j</sub> = 0</td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle"  colspan="5"  >For every constraint c<sub>i</sub></td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="4"  >If c<sub>i</sub> is violated</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="3"  >Calculate feasibility vector fv and the feasibility distance||fv||</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="3"  >If ||fv|| &gt; a</td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >NINF = NINF + 1</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >For every variable x<sub>j</sub> in c<sub>i</sub></td></tr><tr><td align="center" valign="middle" >8</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >n<sub>j</sub> &#172; n<sub>j</sub> + 1, s<sub>j</sub> &#172; s<sub>j</sub> + fv<sub>ij</sub></td></tr><tr><td align="center" valign="middle" >9</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >End for</td></tr><tr><td align="center" valign="middle" >10</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="3"  >End if</td></tr><tr><td align="center" valign="middle" >11</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="4"  >End if</td></tr><tr><td align="center" valign="middle" >12</td><td align="center" valign="middle"  colspan="5"  >End for</td></tr><tr><td align="center" valign="middle" >13</td><td align="center" valign="middle"  colspan="5"  >If NINF = 0, then exist successfully</td></tr><tr><td align="center" valign="middle" >14</td><td align="center" valign="middle"  colspan="5"  >For every variable x<sub>j</sub></td></tr><tr><td align="center" valign="middle" >15</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="4"  >t<sub>j</sub> = s<sub>j</sub> / n<sub>j</sub></td></tr><tr><td align="center" valign="middle" >16</td><td align="center" valign="middle"  colspan="5"  >End for</td></tr><tr><td align="center" valign="middle" >17</td><td align="center" valign="middle"  colspan="5"  >If ||t|| &#163; b then exit unsuccessfully</td></tr><tr><td align="center" valign="middle" >18</td><td align="center" valign="middle"  colspan="5"  >x &#172; x + t</td></tr><tr><td align="center" valign="middle" >19</td><td align="center" valign="middle"  colspan="5"  >If necessary, reset x to respect any violated variable bounds</td></tr><tr><td align="center" valign="middle" >20</td><td align="center" valign="middle"  colspan="5"  >Go to step1</td></tr></tbody></table></table-wrap><p>表1. 约束一致策略</p><p>第二步是对所有违反约束的可行性向量进行组合，得到实际用于更新的一致向量。这个过程是以组件方式完成的：只有在c(x)中包含特定变量的违反约束才能对该维度中的移动进行“投票”。通过对各可行性向量的相关分量进行平均得到各维度的运动，产生的一致向量指定了移动的方向和距离，应用一致向量来更新当前点。这两步不断重复直至满足终止条件。约束一致策略的算法步骤如表1所示。NINF是当前违反约束的数量，s<sub>j</sub>表示变量x<sub>j</sub>的fv<sub>ij</sub>对所有违反约束条件的可行性向量的和，n<sub>j</sub>代表以变量x<sub>j</sub>为组件的违反约束的数量，fv<sub>ij</sub>表示第i个约束的可行性向量中变量x<sub>j</sub>的分量，t为一致向量。如果这个向量太短，那么迭代将停止，结果是失败的。当每个约束的约束违反量为零或可行性距离小于a，即NINF为零时，算法停止 [<xref ref-type="bibr" rid="hanspub.38770-ref8">8</xref>]。</p><p>约束一致策略的方法是简单的，缺点在于，单个可行性向量组合的方法可能会被特殊情况所阻碍，特别是一组向某个方向拉动的可行性向量与另一组向相反方向拉动的可行性向量相平衡时。但是，当约束一致策略与进化算法一起使用时，这样的个体不会产生任何问题。</p></sec><sec id="s7"><title>3. 人工蜂群算法</title><p>人工蜂群算法(Artificial Bee Colony, ABC)，是由Karaboga发明的一种基于群体的随机优化方法，它模拟了蜜蜂的智能觅食行为，蜜蜂根据各自的分工进行不同的活动，并实现蜂群信息的共享和交流，从而找到问题的最优解。</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Pseudocode of ABC algorith</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >1</th><th align="center" valign="middle"  colspan="3"  >Initialize the food sources and evaluate the nectar amount (fitness) of food sources</th></tr></thead><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle"  colspan="3"  >Send the employed bees to the current food source</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle"  colspan="3"  >Iteration = 0</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle"  colspan="3"  >Do while (the termination conditions are not met)</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >/*Employed Bees’ Phase*/</td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >For (each employed bee)</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Generate a candidate solution in its neighborhood following Equation (4)</td></tr><tr><td align="center" valign="middle" >8</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Evaluate the candidate solution and apply greedy selection</td></tr><tr><td align="center" valign="middle" >9</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >End for</td></tr><tr><td align="center" valign="middle" >10</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >Calculate the probability P for each food source according to Equation (5)</td></tr><tr><td align="center" valign="middle" >11</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >/*Onlooker Bees’ Phase*/</td></tr><tr><td align="center" valign="middle" >12</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >For (each onlooker bee)</td></tr><tr><td align="center" valign="middle" >13</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Send onlooker bees to food sources by the roulette selection depending on P</td></tr><tr><td align="center" valign="middle" >14</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Generate a candidate solution in its neighborhood following Equation (4)</td></tr><tr><td align="center" valign="middle" >15</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Evaluate the candidate solution and apply greedy selection</td></tr><tr><td align="center" valign="middle" >16</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >End for</td></tr><tr><td align="center" valign="middle" >17</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >/*Scout Bees’ Phase*/</td></tr><tr><td align="center" valign="middle" >18</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >If (any employed bee becomes scout bee)</td></tr><tr><td align="center" valign="middle" >19</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Send the scout bee to a randomly produced food source</td></tr><tr><td align="center" valign="middle" >20</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >End if</td></tr><tr><td align="center" valign="middle" >21</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >Memorize the best solution achieved so far</td></tr><tr><td align="center" valign="middle" >22</td><td align="center" valign="middle" ></td><td align="center" valign="middle"  colspan="2"  >Iteration = Iteration + 1</td></tr><tr><td align="center" valign="middle" >23</td><td align="center" valign="middle"  colspan="3"  >End while</td></tr><tr><td align="center" valign="middle" >24</td><td align="center" valign="middle"  colspan="3"  >Output the best solution achieved</td></tr></tbody></table></table-wrap><p>表2. ABC的伪代码</p><p>在一个自然的蜂群中，通常有三种觅食的蜜蜂，分别是雇佣蜂、旁观蜂和侦查蜂。蜂群的一半是雇佣蜂，另一半是旁观蜂。雇佣蜂负责在自己的蜜源周围搜寻，同时向旁观蜂传递高质量的蜜源信息。旁观蜂根据收到的信息，倾向于选择更好的蜜源进行开采。若某蜜源在规定迭代次数内未更新，则雇佣蜂抛弃该位置转化为侦查蜂，去随机寻找新的蜜源 [<xref ref-type="bibr" rid="hanspub.38770-ref1">1</xref>] [<xref ref-type="bibr" rid="hanspub.38770-ref12">12</xref>]。表2列出了人工蜂群算法的伪代码。</p><p>人工蜂群算法中，蜜源的位置表示优化问题的解，每个蜜源的花蜜量表示相应解的适应度值。首先，对蜜源的位置进行初始化，雇佣蜂(或旁观蜂)的数量等于蜜源的数量：</p><p>x i , j = x j min + r a n d ( 0 , 1 ) ( x j max − x j min ) (3)</p><p>其中，i = 1, 2, …, SN，j = 1, 2, … D，SN是蜜源的数量。D为决策变量的维度，表示待优化参数的个数。xmax j和xmin j分别是蜜蜂在第j维坐标位置的上界和下界。另外，在此阶段，存储每个蜜蜂试验次数的计数器被设置为0。</p><p>初始化阶段结束后，ABC进入雇佣蜂、旁观蜂和侦查蜂阶段的循环，直到满足终止条件。在雇佣蜂阶段，每只雇佣蜂对应一个确定的蜜源并在迭代中对邻近的蜜源进行搜索，根据式(4)产生相邻的蜜源：</p><p>v i , j = x i , j + ϕ ( x i , j − x k , j ) (4)</p><p>k是不同于i的随机蜜源，j是随机选择的维度。f是在[−1, 1]范围内的一个均匀分布的随机数，决定了扰动程度。通过改变x上的一个维度来确定新的蜜源v，如果这个操作产生的这个维度的值超过了预定边界，就把其设置为边界值。</p><p>然后评估新蜜源的适应度值，当新蜜源v的适应度优于x时，采用贪婪选择法用新蜜源代替原来的蜜源，否则保留x。如果蜜源发生了变化，试验计数器将重置为零；否则，其值将增加1。所有的雇佣蜂完成该步骤的运算后，飞回信息交流区共享蜜源 [<xref ref-type="bibr" rid="hanspub.38770-ref13">13</xref>]。</p><p>在旁观蜂阶段，旁观蜂接收到雇佣蜂共享的蜜源信息，然后他们会根据蜜源的花蜜量的概率，各自选择一种蜜源进行开发。概率的计算公式如(5)所示：</p><p>P i = f i t n e s s i ∑ j = 1 S N f i t n e s s j (5)</p><p>人工蜂群算法中，解的适应度评估根据公式(6)计算，f<sub>i</sub>表示解的函数值：</p><p>f i t i = { 1 / ( 1 + f i )                             f i ≥ 0 1 + a b s ( f i )                     o t h e r w i s e (6)</p><p>旁观蜂采用轮盘赌的方法选择蜜源后，每只旁观蜂会像雇佣蜂一样，按照公式(4)在其附近继续寻找新的蜜源。</p><p>在侦查蜂阶段，引入一个叫做“limit”的控制参数来决定是否抛弃某一蜜源。如果该蜜源没有在“limit”预定的周期内得到改善，那么该蜜源就会被抛弃，并且对应该蜜源的雇佣蜂转化为侦查蜂。接着使用(3)在搜索空间中随机产生一个新的蜜源，就像初始化阶段一样。</p><p>x i t + 1 = { x j min + r a n d ( 0 , 1 ) ( x j max − x j min )       trial i ≥ lim it x i t                                                                                 trial i &lt; limit (7)</p></sec><sec id="s8"><title>4. 基于约束一致策略的人工蜂群算法</title><p>该章节中，将详细介绍基于约束一致策略的人工蜂群算法的内容。图1是该算法的流程图。根据流程图可以看出，种群在处理的过程中，根据个体是否可行分成了两部分，一部分是少量的不可行个体，另一部分则是可行个体和剩余不可行个体的集合。然后分别采用约束一致策略和人工蜂群算法处理两部分种群个体。</p><p>在该算法中，首先随机初始化一个种群P，然后评估种群当前的适应度值和约束违反程度，根据约束违反程度可以找到当前种群状态下的可行个体集合和不可行个体集合。假设初始化后的种群中存在的不可行个体为SP，在SP中选取部分不可行个体，记为SSP(即只选取部分不可行个体，而不是全部的不可行个体SP)，基于章节2介绍的约束一致策略，对SSP个不可行个体进行处理，产生原部分不可行个体的新位置。随后，剩余的不可行个体与可行个体合并，将经典的人工蜂群算法应用于该个体的集合。算法之所以只选取部分不可行个体进行操作的目的是可以节省计算时间，不可行个体越多，约束一致策略运行的时间越长，另外一个目的则是能够保持种群的多样性。</p><p>图1. 基于约束一致策略的人工蜂群算法流程</p><p>初始种群P采用如下公式生成：</p><p>x i , d = L d + r a n d ( 0 , 1 ) ( U d − L d ) (8)</p><p>其中，U<sub>d</sub>和L<sub>d</sub>是决策变量的上下界，d为变量的维度。rand(0, 1)表示(0, 1)范围内的随机数。x<sub>i</sub><sub>,d</sub>即代表初始的种群个体。</p><p>接下来，计算初始化种群P内全部个体的适应度值和约束违反量，如果所有约束的违反量均小于等于0，表明当前个体没有违反约束，是可行的个体，这样的个体暂时不采取任何措施，等待后续与剩余不可行个体合并直接采用ABC进化。如果至少有一个约束产生违反，即约束违反量大于0，那么这个个体就是不可行个体，所有不可行个体的集合为SP。</p><p>当不可行个体的集合SP不为空时，在SP内随机的选取SPP个不可行个体，利用前面章节介绍的约束一致策略，改变当前SPP个不可行个体的位置。个体的改变依照公式(9)进行。即对每个不可行个体，计算出针对它的一致向量t，将当前的位置与向量的坐标相加得到个体的新位置，新个体记为x’<sub>i</sub><sub>,d</sub>。剩余的不可行个体和原先找到的可行个体形成的合集利用人工蜂群算法进行演化。若SP的集合为空时，说明当前迭代下没有不可行个体，此时，所有的可行个体直接利用人工蜂群算法产生后代，寻找最优解。</p><p>x ′ i , d = x i , d + x c c , d (9)</p><p>需要注意的是，在人工蜂群算法原来的贪婪选择操作下，做了一点改动，将可行性规则引入对个体进行选拔，即个体的选择需要同时考虑目标函数值和约束违反程度。当个体均可行时，目标函数值越小(极小化问题)，个体的解最优；当可行个体与不可行个体同时存在，可行个体的解总是优于不可行个体的解；当同为不可行个体时，选取约束违反量总和最小的解予以保留。</p><p>该算法中，等式约束的处理将转换为公式(10)的不等式，e是一个容差值，实验中取值10<sup>−4</sup>。</p><p>| h j ( x ) | − ε ≤ 0 (10)</p><p>算法的伪代码如表3所示：</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> Pseudocode of ABCC</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >1</th><th align="center" valign="middle"  colspan="2"  >Initialize a population P</th></tr></thead><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle"  colspan="2"  >Evaluate the fitness values and constraint violations</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle"  colspan="2"  >If there are infeasible solutions (SP)</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Select SPP of the infeasible solutions and generate offspring using CC strategy</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >The merged group evolves utilizing ABC algorithm</td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >Sort the entire population based on the feasibility rules</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle"  colspan="2"  >End if</td></tr><tr><td align="center" valign="middle" >8</td><td align="center" valign="middle"  colspan="2"  >Go to step 2</td></tr></tbody></table></table-wrap><p>表3. ABCCC伪代码</p></sec><sec id="s9"><title>5. 实验结果与分析</title><p>该章节主要列举和分析了ABCCC算法的实验结果，首先在指定的测试函数集进行测试，找到了测试集的优秀结果，验证了该算法能够用来解决约束优化问题。接下来，还将ABCCC与DECC和PSOCC算法进行了对比(把ABC替换为差分进化算法(DE)和粒子群算法(PSO))，实验结果表明，ABCCC优于其余两个算法。同时该章节还分析了算法内部参数对实验结果的影响。最后将ABCCC算法与其他较优秀的算法进行了比较，实验表明了ABCCC在解决约束优化问题上具有一定的竞争力。</p><sec id="s9_1"><title>5.1. 测试函数集与参数设置</title><p>通过求解CEC2017约束优化测试函数集中的部分函数，对算法进行了测试 [<xref ref-type="bibr" rid="hanspub.38770-ref14">14</xref>]。函数集中的问题具有不同的数学特征，比如有的目标函数或约束是线性或非线性的，有的约束是等式或不等式，有的目标函数是单峰或多峰。并且有的函数是可行空间非常小，这更增加了解决问题的难度。</p><p>算法的参数设置包括如下内容：种群P的大小为100，选择SPP个不可行个体的依据是SPP = 0.5SP (在5.3章节讨论为什么将比例设置为0.5)，总迭代次数设为100，每个问题独立运行的次数为10次。对比算法DECC和PSOCC的参数设置为：DE的变异因子F设为0.5，交叉因子CR设为0.4；PSO的学习因子C<sub>1</sub>和C<sub>2</sub>相等，取值均为1.4，惯性权值w设为0.8。约束一致策略的参数设置如下：可行距离的容差值a设为10<sup>−6</sup>，移动容差值b为10<sup>−4</sup>。</p></sec><sec id="s9_2"><title>5.2. 实验结果</title><p>在本节，首先列出了ABCCC在CEC2017函数集下的实验结果，同时还对比了DECC和PSOCC在相同状况下的实验结果，表4列出了实验过程中得到的最优解、平均值和标准差。最优解表明算法在解决该问题时找到的目标函数的最小值，平均值反映了10次运行的平均结果，标准差则能表明算法的鲁棒性，标准差越小，表明算法每次运行得到的结果都是近似的，说明算法是稳定的。实验结果表明ABCCC的算法性能总体上要优于DECC和PSOCC，收敛迅速且能找到最优解。</p><p>从表4可以看出，ABCCC算法得到的最优解和平均解在大多数函数(C01、C02、C03、C04、C05、C06、C07和C09)的表现都优于DECC和PSOCC。而对于函数C08和C10，DECC得到的结果则是最小的，优于PSOCC和ABCCC。其中有一个函数C09，该函数在ABCCC和PSOCC下取得的最优解相同。</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> Comparison results of ABCCC, DECC and PSOC</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >Algorithm</th><th align="center" valign="middle" >best</th><th align="center" valign="middle" >mean</th><th align="center" valign="middle" >std</th><th align="center" valign="middle" ></th><th align="center" valign="middle" >best</th><th align="center" valign="middle" >mean</th><th align="center" valign="middle" >std</th></tr></thead><tr><td align="center" valign="middle"  rowspan="3"  >C01</td><td align="center" valign="middle" >ABCCC</td><td align="center" valign="middle" >4.3422e−01</td><td align="center" valign="middle" >1.0276e+00</td><td align="center" valign="middle" >7.7749e−01</td><td align="center" valign="middle"  rowspan="3"  >C06</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9903e−01</td><td align="center" valign="middle" >6.2940e−01</td></tr><tr><td align="center" valign="middle" >DECC</td><td align="center" valign="middle" >2.0552e+01</td><td align="center" valign="middle" >5.7294e+01</td><td align="center" valign="middle" >2.6456e+01</td><td align="center" valign="middle" >1.1025e+02</td><td align="center" valign="middle" >1.5862e+02</td><td align="center" valign="middle" >5.6512e+01</td></tr><tr><td align="center" valign="middle" >PSOCC</td><td align="center" valign="middle" >1.9394e+01</td><td align="center" valign="middle" >3.0953e+01</td><td align="center" valign="middle" >7.5116e+00</td><td align="center" valign="middle" >6.9656e+01</td><td align="center" valign="middle" >1.3079e+02</td><td align="center" valign="middle" >5.3494e+01</td></tr><tr><td align="center" valign="middle"  rowspan="3"  >C02</td><td align="center" valign="middle" >ABCCC</td><td align="center" valign="middle" >1.1917e−01</td><td align="center" valign="middle" >5.6705e−01</td><td align="center" valign="middle" >3.6207e−01</td><td align="center" valign="middle"  rowspan="3"  >C07</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >6.7115e−06</td></tr><tr><td align="center" valign="middle" >DECC</td><td align="center" valign="middle" >2.2081e+01</td><td align="center" valign="middle" >3.8531e+01</td><td align="center" valign="middle" >1.2447e+01</td><td align="center" valign="middle" >−3.1552e+02</td><td align="center" valign="middle" >−3.0261e+02</td><td align="center" valign="middle" >8.6554e+00</td></tr><tr><td align="center" valign="middle" >PSOCC</td><td align="center" valign="middle" >2.8930e+01</td><td align="center" valign="middle" >3.6837e+01</td><td align="center" valign="middle" >4.6696e+00</td><td align="center" valign="middle" >−2.3716e+02</td><td align="center" valign="middle" >−2.0193e+02</td><td align="center" valign="middle" >2.3230e+01</td></tr><tr><td align="center" valign="middle"  rowspan="3"  >C03</td><td align="center" valign="middle" >ABCCC</td><td align="center" valign="middle" >2.6169e−01</td><td align="center" valign="middle" >7.2534e−01</td><td align="center" valign="middle" >4.5649e−01</td><td align="center" valign="middle"  rowspan="3"  >C08</td><td align="center" valign="middle" >1.2499e+00</td><td align="center" valign="middle" >2.6492e+00</td><td align="center" valign="middle" >1.0700e+00</td></tr><tr><td align="center" valign="middle" >DECC</td><td align="center" valign="middle" >1.9347e+01</td><td align="center" valign="middle" >7.9392e+01</td><td align="center" valign="middle" >2.6244e+01</td><td align="center" valign="middle" >7.6596e−01</td><td align="center" valign="middle" >1.4086e+00</td><td align="center" valign="middle" >4.8360e−01</td></tr><tr><td align="center" valign="middle" >PSOCC</td><td align="center" valign="middle" >2.5698e+01</td><td align="center" valign="middle" >3.2883e+01</td><td align="center" valign="middle" >3.7946e+00</td><td align="center" valign="middle" >1.2276e+00</td><td align="center" valign="middle" >2.2839e+00</td><td align="center" valign="middle" >5.8413e−01</td></tr><tr><td align="center" valign="middle"  rowspan="3"  >C04</td><td align="center" valign="middle" >ABCCC</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle"  rowspan="3"  >C09</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td></tr><tr><td align="center" valign="middle" >DECC</td><td align="center" valign="middle" >1.7852e+01</td><td align="center" valign="middle" >3.2618e+01</td><td align="center" valign="middle" >7.5740e+00</td><td align="center" valign="middle" >1.8540e−01</td><td align="center" valign="middle" >3.2352e−01</td><td align="center" valign="middle" >1.2396e−01</td></tr><tr><td align="center" valign="middle" >PSOCC</td><td align="center" valign="middle" >4.4996e+01</td><td align="center" valign="middle" >6.7187e+01</td><td align="center" valign="middle" >1.4799e+01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td></tr><tr><td align="center" valign="middle"  rowspan="3"  >C05</td><td align="center" valign="middle" >ABCCC</td><td align="center" valign="middle" >3.8795e−04</td><td align="center" valign="middle" >5.4388e−03</td><td align="center" valign="middle" >9.4572e−03</td><td align="center" valign="middle"  rowspan="3"  >C10</td><td align="center" valign="middle" >1.0175e+01</td><td align="center" valign="middle" >1.5753e+01</td><td align="center" valign="middle" >5.1411e+00</td></tr><tr><td align="center" valign="middle" >DECC</td><td align="center" valign="middle" >7.2160e+00</td><td align="center" valign="middle" >8.1310e+00</td><td align="center" valign="middle" >6.5960e−01</td><td align="center" valign="middle" >4.5172e−01</td><td align="center" valign="middle" >1.1297e+00</td><td align="center" valign="middle" >6.1977e−01</td></tr><tr><td align="center" valign="middle" >PSOCC</td><td align="center" valign="middle" >2.0620e+01</td><td align="center" valign="middle" >4.6958e+01</td><td align="center" valign="middle" >3.0318e+01</td><td align="center" valign="middle" >1.3172e+00</td><td align="center" valign="middle" >2.3567e+00</td><td align="center" valign="middle" >4.3120e−01</td></tr></tbody></table></table-wrap><p>表4. ABCCC与DECC和PSOCC的对比结果</p><p>从图2所示的收敛曲线图可以看出，ABCCC比其他算法收敛速度更快，收敛结果较优，得到了更理想的全局最优解。然而，函数C08和C10则是DECC得到的解更优。</p><p>图2. 各算法的收敛曲线对比图</p><p>图3. 算法的盒图对比结果</p><p>图3给出了算法的盒图。对于每个盒图，中心标记表示中间值，方框的底部和顶部边缘分别表示第25百分位数和第75百分位数。胡须延伸到不被认为是异常值的最极端数据点，并使用“+”符号分别绘制异常值。从图3可以看出，ABCCC在大部分测试函数(C01、C02、C03、C04、C05、C06、C07、C09)均是性能较优越的。</p></sec><sec id="s9_3"><title>5.3. SPP值对ABCCC的影响</title><p>在5.1章节中，SPP参数的选取为0.5，即选取了不可行个体的一半，在该章节中，我们将测试SPP值对算法性能的影响。</p><p>处理不可行个体时，5.1节中介绍的是在所有的不可行个体中只选取部分个体，因此本节按照不同比例范围选值进行测试，其中SPP设置为0.1SP、0.3SP、0.5SP、0.7SP和0.9SP (SP即为前面章节介绍的全部不可行个体)。SPP值越高，预计搜索周期越长，具体的实验结果如表5所示。从搜索周期的角度看，SPP的值越小，搜索的时间越短，所以当SPP = 0.1SP时算法会更好，因为它的运行时间相对最短。但是从解的质量角度看，当SPP = 0.5SP时，大多数函数的实验结果比其他情况较好，尤其是平均适应度值的结果。因此ABCCC算法中SPP值的选取为0.5时更合适，能够解决大部分的测试函数问题。</p><table-wrap-group id="5"><label><xref ref-type="table" rid="table5">Table 5</xref></label><caption><title> The influence of SSP on result</title></caption><table-wrap id="5_1"><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >SPP−value</th><th align="center" valign="middle" >best</th><th align="center" valign="middle" >aver</th><th align="center" valign="middle" >std</th><th align="center" valign="middle" ></th><th align="center" valign="middle" >best</th><th align="center" valign="middle" >aver</th><th align="center" valign="middle" >std</th></tr></thead><tr><td align="center" valign="middle"  rowspan="5"  >C01</td><td align="center" valign="middle" >SPP = 0.1</td><td align="center" valign="middle" >3.6224e−01</td><td align="center" valign="middle" >2.1745e+00</td><td align="center" valign="middle" >3.7883e+00</td><td align="center" valign="middle"  rowspan="5"  >C02</td><td align="center" valign="middle" >9.6252e−02</td><td align="center" valign="middle" >7.5394e−01</td><td align="center" valign="middle" >5.1756e−01</td></tr><tr><td align="center" valign="middle" >SPP = 0.3</td><td align="center" valign="middle" >6.6545e−01</td><td align="center" valign="middle" >1.0406e+00</td><td align="center" valign="middle" >3.4463e−01</td><td align="center" valign="middle" >1.2425e−01</td><td align="center" valign="middle" >1.9530e+00</td><td align="center" valign="middle" >2.8007e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.5</td><td align="center" valign="middle" >4.3422e−01</td><td align="center" valign="middle" >1.0276e+00</td><td align="center" valign="middle" >7.7749e−01</td><td align="center" valign="middle" >1.1917e−01</td><td align="center" valign="middle" >5.6705e−01</td><td align="center" valign="middle" >3.6207e−01</td></tr><tr><td align="center" valign="middle" >SPP = 0.7</td><td align="center" valign="middle" >8.0072e−01</td><td align="center" valign="middle" >1.4671e+00</td><td align="center" valign="middle" >7.0296e−01</td><td align="center" valign="middle" >2.6261e−01</td><td align="center" valign="middle" >9.3691e−01</td><td align="center" valign="middle" >1.2533e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.9</td><td align="center" valign="middle" >2.7358e−01</td><td align="center" valign="middle" >1.2008e+00</td><td align="center" valign="middle" >6.8819e−01</td><td align="center" valign="middle" >2.5149e−01</td><td align="center" valign="middle" >9.4132e−01</td><td align="center" valign="middle" >1.2486e+00</td></tr><tr><td align="center" valign="middle"  rowspan="2"  >C03</td><td align="center" valign="middle" >SPP = 0.1</td><td align="center" valign="middle" >3.3249e−01</td><td align="center" valign="middle" >1.2147e+00</td><td align="center" valign="middle" >5.6815e−01</td><td align="center" valign="middle"  rowspan="2"  >C04</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.3</td><td align="center" valign="middle" >5.2694e−01</td><td align="center" valign="middle" >1.3587e+00</td><td align="center" valign="middle" >7.7649e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td></tr></tbody></table></table-wrap><table-wrap id="5_2"><table><tbody><thead><tr><th align="center" valign="middle"  rowspan="3"  >C03</th><th align="center" valign="middle" >SPP = 0.5</th><th align="center" valign="middle" >2.6169e−01</th><th align="center" valign="middle" >7.2534e−01</th><th align="center" valign="middle" >4.5649e−01</th><th align="center" valign="middle"  rowspan="3"  >C04</th><th align="center" valign="middle" >0.0000e+00</th><th align="center" valign="middle" >0.0000e+00</th><th align="center" valign="middle" >0.0000e+00</th></tr></thead><tr><td align="center" valign="middle" >SPP = 0.7</td><td align="center" valign="middle" >1.7941e−01</td><td align="center" valign="middle" >2.2968e+00</td><td align="center" valign="middle" >3.1205e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.9</td><td align="center" valign="middle" >3.1033e−01</td><td align="center" valign="middle" >3.1911e+00</td><td align="center" valign="middle" >3.8990e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td></tr><tr><td align="center" valign="middle"  rowspan="5"  >C05</td><td align="center" valign="middle" >SPP = 0.1</td><td align="center" valign="middle" >3.1579e−04</td><td align="center" valign="middle" >3.0156e−03</td><td align="center" valign="middle" >3.4689e−03</td><td align="center" valign="middle"  rowspan="5"  >C06</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >2.0000e−01</td><td align="center" valign="middle" >6.3244e−01</td></tr><tr><td align="center" valign="middle" >SPP = 0.3</td><td align="center" valign="middle" >1.3199e−03</td><td align="center" valign="middle" >1.2395e−02</td><td align="center" valign="middle" >1.7242e−02</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >7.9602e−01</td><td align="center" valign="middle" >1.0277e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.5</td><td align="center" valign="middle" >3.8795e−04</td><td align="center" valign="middle" >5.4388e−03</td><td align="center" valign="middle" >9.4572e−03</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9903e−01</td><td align="center" valign="middle" >6.2940e−01</td></tr><tr><td align="center" valign="middle" >SPP = 0.7</td><td align="center" valign="middle" >1.4399e−04</td><td align="center" valign="middle" >5.3629e−03</td><td align="center" valign="middle" >6.7180e−03</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9921e+00</td><td align="center" valign="middle" >1.3279e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.9</td><td align="center" valign="middle" >6.0703e−04</td><td align="center" valign="middle" >1.2685e−02</td><td align="center" valign="middle" >2.9036e−02</td><td align="center" valign="middle" >3.9851e+00</td><td align="center" valign="middle" >1.1887e+02</td><td align="center" valign="middle" >1.4430e+02</td></tr><tr><td align="center" valign="middle"  rowspan="5"  >C07</td><td align="center" valign="middle" >SPP = 0.1</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >2.1047e−07</td><td align="center" valign="middle"  rowspan="5"  >C08</td><td align="center" valign="middle" >5.1001e+00</td><td align="center" valign="middle" >8.7588e+00</td><td align="center" valign="middle" >2.7110e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.3</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >2.6055e−07</td><td align="center" valign="middle" >1.1888e+00</td><td align="center" valign="middle" >2.8243e+00</td><td align="center" valign="middle" >9.0287e−01</td></tr><tr><td align="center" valign="middle" >SPP = 0.5</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >6.7115e−06</td><td align="center" valign="middle" >1.2499e+00</td><td align="center" valign="middle" >2.6492e+00</td><td align="center" valign="middle" >1.0700e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.7</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2453e+02</td><td align="center" valign="middle" >6.7970e−01</td><td align="center" valign="middle" >2.5761e+00</td><td align="center" valign="middle" >4.3356e+00</td><td align="center" valign="middle" >1.0971e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.9</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >9.0928e−06</td><td align="center" valign="middle" >6.5659e−01</td><td align="center" valign="middle" >4.0359e+00</td><td align="center" valign="middle" >1.9499e+00</td></tr><tr><td align="center" valign="middle"  rowspan="5"  >C09</td><td align="center" valign="middle" >SPP = 0.1</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle"  rowspan="5"  >C10</td><td align="center" valign="middle" >1.4054e+01</td><td align="center" valign="middle" >2.0605e+01</td><td align="center" valign="middle" >5.9842e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.3</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >8.9854e+00</td><td align="center" valign="middle" >1.6984e+01</td><td align="center" valign="middle" >5.7525e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.5</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.0175e+01</td><td align="center" valign="middle" >1.5753e+01</td><td align="center" valign="middle" >5.1411e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.7</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >8.3204e+00</td><td align="center" valign="middle" >1.7478e+01</td><td align="center" valign="middle" >5.2565e+00</td></tr><tr><td align="center" valign="middle" >SPP = 0.9</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >8.9586e+00</td><td align="center" valign="middle" >1.6326e+01</td><td align="center" valign="middle" >4.7826e+00</td></tr></tbody></table></table-wrap></table-wrap-group><p>表5. SPP值的选取对算法结果的影响</p><p>图4为测试函数C02的收敛曲线图，从图中可以明显地看出，SPP = 0.5SP时收敛速度更快，得到的最优解更好。</p><p>图4. 不同SPP值下ABCCC的收敛曲线图(函数C02)</p></sec><sec id="s9_4"><title>5.4. ABCCC与其他算法的比较结果</title><p>在该章节，ABCCC算法与其他的算法进行了比较，具体的实验结果展示在下面的表6中。ABCCC先与CALSHADE和UDE进行了实验对比，结果表明ABCCC能取得大多数测试函数的最优解。但对于函数C01和C02，CALSHADE算法取得了函数的最优解；对于函数C08和C10，算法UDE的表现更好。但从整体来说，实验结果表明ABCCC算法的性能优于其他算法。</p><table-wrap id="table6" ><label><xref ref-type="table" rid="table6">Table 6</xref></label><caption><title> Comparison results of ABCCC、CLSHADE and UD</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  rowspan="2"  ></th><th align="center" valign="middle"  colspan="2"  >ABCCC</th><th align="center" valign="middle"  colspan="2"  >CALSHADE</th><th align="center" valign="middle"  colspan="2"  >UDE</th></tr></thead><tr><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td></tr><tr><td align="center" valign="middle" >C01</td><td align="center" valign="middle" >4.3422e−01</td><td align="center" valign="middle" >1.0276e+00</td><td align="center" valign="middle" >1.6437e−02</td><td align="center" valign="middle" >1.7105e−01</td><td align="center" valign="middle" >3.1160e+03</td><td align="center" valign="middle" >5.2019e+03</td></tr><tr><td align="center" valign="middle" >C02</td><td align="center" valign="middle" >1.1917e−01</td><td align="center" valign="middle" >5.6705e−01</td><td align="center" valign="middle" >2.4550e−03</td><td align="center" valign="middle" >1.3606e−01</td><td align="center" valign="middle" >2.4394e+03</td><td align="center" valign="middle" >4.3835e+03</td></tr><tr><td align="center" valign="middle" >C03</td><td align="center" valign="middle" >2.6169e−01</td><td align="center" valign="middle" >7.2534e−01</td><td align="center" valign="middle" >1.7797e+04</td><td align="center" valign="middle" >2.2553e+05</td><td align="center" valign="middle" >2.0650e+03</td><td align="center" valign="middle" >4.1730e+03</td></tr><tr><td align="center" valign="middle" >C04</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.8905e+01</td><td align="center" valign="middle" >3.4916e+01</td><td align="center" valign="middle" >1.0086e+02</td><td align="center" valign="middle" >1.3747e+02</td></tr><tr><td align="center" valign="middle" >C05</td><td align="center" valign="middle" >3.8795e−04</td><td align="center" valign="middle" >5.4388e−03</td><td align="center" valign="middle" >2.9752e+00</td><td align="center" valign="middle" >4.0586e+00</td><td align="center" valign="middle" >1.3716e+04</td><td align="center" valign="middle" >3.6528e+04</td></tr><tr><td align="center" valign="middle" >C06</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9903e−01</td><td align="center" valign="middle" >1.6082e+02</td><td align="center" valign="middle" >3.7367e+02</td><td align="center" valign="middle" >2.1652e+02</td><td align="center" valign="middle" >3.0200e+02</td></tr><tr><td align="center" valign="middle" >C07</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−2.1798e+02</td><td align="center" valign="middle" >−5.9272e+00</td><td align="center" valign="middle" >−4.0431e+02</td><td align="center" valign="middle" >−3.5367e+02</td></tr><tr><td align="center" valign="middle" >C08</td><td align="center" valign="middle" >1.2499e+00</td><td align="center" valign="middle" >2.6492e+00</td><td align="center" valign="middle" >1.5861e−02</td><td align="center" valign="middle" >8.6148e−02</td><td align="center" valign="middle" >−9.0367e+01</td><td align="center" valign="middle" >−9.0367e+01</td></tr><tr><td align="center" valign="middle" >C09</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−4.9730e−03</td><td align="center" valign="middle" >1.8271e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td></tr><tr><td align="center" valign="middle" >C10</td><td align="center" valign="middle" >1.0175e+01</td><td align="center" valign="middle" >1.5753e+01</td><td align="center" valign="middle" >8.7000e−05</td><td align="center" valign="middle" >4.6556e−03</td><td align="center" valign="middle" >−5.9754e+01</td><td align="center" valign="middle" >−5.9754e+01</td></tr></tbody></table></table-wrap><p>表6. ABCCC与CLSHADE和UDE算法的比较结果</p><p>人工蜂群算法在后来的研究中被许多研究者提出了一些变体，比如CABC和GABC，因此该章节也将ABC算法替换为CABC和GABC，将这些算法进行了比较，结果如表7所示。除了测试函数C01，C08和C10外，ABCCC在其他测试函数中均能够找到最优解。而函数C01和C08的最优解由GABCCC找到，对于C10，则是CABCCC获得了最小值。究其原因，GABCCC利用全局最优值在搜索周期中对个体进行变异，对结果的影响较大。虽然CABCCC基于随机选择的某个维度对每个个体进行变异操作，但也降低了收敛速度，导致搜索周期变长。</p><table-wrap id="table7" ><label><xref ref-type="table" rid="table7">Table 7</xref></label><caption><title> Comparison results of ABCCC, CABCCC and GABCC</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  rowspan="2"  ></th><th align="center" valign="middle"  colspan="2"  >ABCCC</th><th align="center" valign="middle"  colspan="2"  >CABCCC</th><th align="center" valign="middle"  colspan="2"  >GABCCC</th></tr></thead><tr><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td><td align="center" valign="middle" >best</td><td align="center" valign="middle" >mean</td></tr><tr><td align="center" valign="middle" >C01</td><td align="center" valign="middle" >4.3422e−01</td><td align="center" valign="middle" >1.0276e+00</td><td align="center" valign="middle" >4.0138e+02</td><td align="center" valign="middle" >1.1968e+03</td><td align="center" valign="middle" >2.7349e−01</td><td align="center" valign="middle" >8.8519e−01</td></tr><tr><td align="center" valign="middle" >C02</td><td align="center" valign="middle" >1.1917e−01</td><td align="center" valign="middle" >5.6705e−01</td><td align="center" valign="middle" >1.9751e+02</td><td align="center" valign="middle" >8.9848e+02</td><td align="center" valign="middle" >1.7921e−01</td><td align="center" valign="middle" >1.7533e+00</td></tr><tr><td align="center" valign="middle" >C03</td><td align="center" valign="middle" >2.6169e−01</td><td align="center" valign="middle" >7.2534e−01</td><td align="center" valign="middle" >3.8785e+02</td><td align="center" valign="middle" >7.8629e+02</td><td align="center" valign="middle" >2.8725e−01</td><td align="center" valign="middle" >1.2546e+00</td></tr><tr><td align="center" valign="middle" >C04</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >6.3515e+01</td><td align="center" valign="middle" >7.9414e+01</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9362e−14</td></tr><tr><td align="center" valign="middle" >C05</td><td align="center" valign="middle" >3.8795e−04</td><td align="center" valign="middle" >5.4388e−03</td><td align="center" valign="middle" >7.5505e+02</td><td align="center" valign="middle" >9.1375e+03</td><td align="center" valign="middle" >4.9405e−04</td><td align="center" valign="middle" >3.8794e−02</td></tr><tr><td align="center" valign="middle" >C06</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >1.9903e−01</td><td align="center" valign="middle" >1.0994e+02</td><td align="center" valign="middle" >1.7150e+02</td><td align="center" valign="middle" >0.0000e+00</td><td align="center" valign="middle" >4.5917e+00</td></tr><tr><td align="center" valign="middle" >C07</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−5.2474e+02</td><td align="center" valign="middle" >−4.2280e+02</td><td align="center" valign="middle" >−3.8719e+02</td><td align="center" valign="middle" >−5.2446e+02</td><td align="center" valign="middle" >−5.2152e+02</td></tr><tr><td align="center" valign="middle" >C08</td><td align="center" valign="middle" >1.2499e+00</td><td align="center" valign="middle" >2.6492e+00</td><td align="center" valign="middle" >5.3728e+00</td><td align="center" valign="middle" >1.2295e+01</td><td align="center" valign="middle" >1.1618e+00</td><td align="center" valign="middle" >2.3740e+00</td></tr><tr><td align="center" valign="middle" >C09</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >1.8960e−01</td><td align="center" valign="middle" >−6.0917e−01</td><td align="center" valign="middle" >−6.0917e−01</td></tr><tr><td align="center" valign="middle" >C10</td><td align="center" valign="middle" >1.0175e+01</td><td align="center" valign="middle" >1.5753e+01</td><td align="center" valign="middle" >7.7372e+00</td><td align="center" valign="middle" >1.5545e+01</td><td align="center" valign="middle" >9.8156e+00</td><td align="center" valign="middle" >1.6622e+01</td></tr></tbody></table></table-wrap><p>表7. ABCCC与CABCCC和GABCCC算法的比较结果</p></sec></sec><sec id="s10"><title>6. 结论</title><p>在过去的几十年里，许多进化算法被引入来解决约束优化问题。然而，在进化优化中缺乏有效的约束处理机制。在本研究中，基于约束一致策略的有效性，提出了一种新的人工蜂群算法。为了使计算时间最小化并保持种群内良好的多样性，对每代不可行个体采用基于约束一致方法的更新策略，剩余个体(包括可行个体和不可行个体)采用人工蜂群算法进行演化。</p><p>该算法在一组约束问题上进行了测试。实验还比较了ABCCC与DECC和PSOCC的性能。结果表明，在大多数情况下，ABCCC算法比其他两种算法都能获得更好的结果和更快的收敛速度。该算法还与CLSHADE、UDE等算法进行了比较，实验结果表明，ABCCC算法性能良好，能得到最优解。此外，与采用CC策略的ABC的变体相比，我们的ABCCC算法的结果优于其他算法。</p><p>在未来的工作中，我们还将分析不同参数值对该算法性能的影响，并尝试进一步改进所提出的算法。</p></sec><sec id="s11"><title>文章引用</title><p>吴钰晗,梁晓丹. 基于约束一致策略的人工蜂群算法 Artificial Bee Colony Algorithm Based on Constrained Consistent Strategy[J]. 计算机科学与应用, 2020, 10(11): 2034-2048. https://doi.org/10.12677/CSA.2020.1011215</p></sec><sec id="s12"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.38770-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Antoniou, A. and Lu, W.S. (2010) Practical Optimization: Algorithms and Engineering Applications. In: Practical Opti-mization: Algorithms and Engineering Applications, Springer Publishing Company, Incorporated.</mixed-citation></ref><ref id="hanspub.38770-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Karaboga, D. and Basturk, B. (2008) On the Performance of Artificial Bee Colony (ABC) Algorithm. Applied Soft Computing, 8, 687-697. &lt;br&gt;https://doi.org/10.1016/j.asoc.2007.05.007</mixed-citation></ref><ref id="hanspub.38770-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Smith, L., Chinneck, J. and Aitken, V. (2013) Improved Constraint Consensus Methods for Seeking Feasibility in Nonlinear Programs. Computational Optimization &amp; Applica-tions, 54, 555-578.  
&lt;br&gt;https://doi.org/10.1007/s10589-012-9473-z</mixed-citation></ref><ref id="hanspub.38770-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Zamuda, A. (2017) Adaptive Constraint Handling and Success History Differential Evolution for CEC 2017 Constrained Real-Parameter Optimization. 2017 IEEE Congress on Evolu-tionary Computation (CEC), San Sebastian, 5-8 June 2017, 2443-2450. &lt;br&gt;https://doi.org/10.1109/CEC.2017.7969601</mixed-citation></ref><ref id="hanspub.38770-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Trivedi, A., Sanyal, K., Verma, P., et al. (2017) A Unified Dif-ferential Evolution Algorithm for Constrained Optimization Problems. 2017 IEEE Congress on Evolutionary Computa-tion (CEC), San Sebastian, 5-8 June 2017, 1231-1238.  
&lt;br&gt;https://doi.org/10.1109/CEC.2017.7969446</mixed-citation></ref><ref id="hanspub.38770-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Gao, W., Liu, S. and Huang, L. (2013) A Novel Artificial Bee Colony Algorithm Based on Modified Search Equation and Orthogonal Learning. IEEE Transactions on Cybernetics, 43, 1011-1024.  
&lt;br&gt;https://doi.org/10.1109/TSMCB.2012.2222373</mixed-citation></ref><ref id="hanspub.38770-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Zhu, G. and Kwong, S. (2010) Gbest-Guided Artificial Bee Colony Algorithm for Numerical Function Optimization. Applied Mathematics &amp; Computation, 217, 3166-3173. &lt;br&gt;https://doi.org/10.1016/j.amc.2010.08.049</mixed-citation></ref><ref id="hanspub.38770-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Smith, L., Chinneck, J. and Aitken, V. (2013) Constraint Consen-sus Concentration for Identifying Disjoint Feasible Regions in Nonlinear Programmes. Optimization Methods and Soft-ware, 28, 339-363.  
&lt;br&gt;https://doi.org/10.1080/10556788.2011.647818</mixed-citation></ref><ref id="hanspub.38770-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Hamza, N.M., Essam, D.L. and Sarker, R.A. (2015) Con-straint Consensus Mutation Based Differential Evolution for Constrained Optimization. IEEE Transactions on Evolu-tionary Computation, 20, 447-459.  
&lt;br&gt;https://doi.org/10.1109/TEVC.2015.2477402</mixed-citation></ref><ref id="hanspub.38770-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Hamza, N.M., Elsayed, S.M., Essam, D.L., et al. (2011) Dif-ferential Evolution Combined with Constraint Consensus for Constrained Optimization. IEEE Congress on Evolutionary Computation, 30, 865-872.  
&lt;br&gt;https://doi.org/10.1109/CEC.2011.5949709</mixed-citation></ref><ref id="hanspub.38770-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">Ibrahim, W. and Chinneck, J.W. (2008) Improving Solver Suc-cess in Reaching Feasibility for Sets of Nonlinear Constraints. Computers &amp; Operations Research, 35, 1394-1411. &lt;br&gt;https://doi.org/10.1016/j.cor.2006.08.002</mixed-citation></ref><ref id="hanspub.38770-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">El-Abd, M. (2010) A Cooperative Approach to the Artificial Bee Colony Algorithm. Proceedings of the IEEE Congress on Evolutionary Computation CEC 2010, Barcelona, Spain, 18-23 July 2010, 1-5.  
&lt;br&gt;https://doi.org/10.1109/CEC.2010.5586007</mixed-citation></ref><ref id="hanspub.38770-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">Ma, L., Hu, K., Zhu, Y., et al. (2014) Cooperative Artificial Bee Colony Algorithm for Multi-Objective RFID Network Planning. Journal of Network and Computer Applications, 42, 143-162. &lt;br&gt;https://doi.org/10.1016/j.jnca.2014.02.012</mixed-citation></ref><ref id="hanspub.38770-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">Wu, G.H., Mallipeddi, R. andSuganthan, P.N. (2010) Problem Definitions and Evaluation Criteria for the CEC 2017 Competition on Constrained Real-Parameter Optimization Technology.</mixed-citation></ref></ref-list></back></article>