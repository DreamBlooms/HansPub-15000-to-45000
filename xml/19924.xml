<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">AAM</journal-id><journal-title-group><journal-title>Advances in Applied Mathematics</journal-title></journal-title-group><issn pub-type="epub">2324-7991</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/AAM.2017.62013</article-id><article-id pub-id-type="publisher-id">AAM-19924</article-id><article-categories><subj-group subj-group-type="heading"><subject>AAM20170200000_64460575.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>数学与物理</subject></subj-group></article-categories><title-group><article-title>
 
 
  基于MPI的一种有限并行差分格式求解四阶抛物方程
  A Finite Difference Parallel Scheme Based on MPI Implementation for Fourth Order Parabolic Equations
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>高</surname><given-names>玉羊</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>顾</surname><given-names>海明</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><addr-line>青岛科技大学，山东 青岛</addr-line></aff><aff id="aff2"><addr-line>null</addr-line></aff><author-notes><corresp id="cor1">* E-mail:<email>crazy3435@163.com(高玉)</email>;</corresp></author-notes><pub-date pub-type="epub"><day>21</day><month>03</month><year>2017</year></pub-date><volume>06</volume><issue>02</issue><fpage>114</fpage><lpage>126</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
  在大规模的科学与工程计算问题中，并行计算能够节省大量的时间，本文针对一维四阶抛物方程给出了一类并行差分格式。利用Saul’yev非对称格式进行恰当的组合，形成求解抛物方程的四点格式。四点格式是显式求解的，因此可以将空间区域分为若干子区域，每个子区域独立计算。验证分析表明，该格式是绝对稳定的。随后本文着重介绍了在MPI并行环境下对该格式进行数值计算，构建了两种不同的MPI并行算法并与串行状态下的有限差分格式做出比较，即阻塞通信(等待通信)和非阻塞通信(非等待通信)模式。相对于串行算法运用四点格式求解四阶抛物方程，两种并行通信模式都表现出极好的效果，而且，非阻塞通信模式下的计算由于相对减少了一部分数据的通信等待时间，使得相对于阻塞通信模式，非阻塞通信模式表现出较好的并行效率。
   Parallel computing can save a lot of time in the field of large-scale scientific computing. In this paper, the main idea is that a finite difference parallel scheme for fourth order parabolic equations. The scheme is constructed by Saul’yev asymmetric difference schemes which called the four-point scheme. It’s one explicit difference scheme, the computational domain can be divided into a number of large areas; each sub-region computes themselves, and the parallel scheme is unconditionally stable. Then, the paper focuses on the numerical calculation of the four-point scheme in MPI parallel environment. Two different MPI parallel algorithms are constructed, one is blocking com- munication (wait communication) mode, and the other is non-blocking communication (non-wait communication) mode. These two parallel algorithms both better than serial algorithm to calculate numerical solutions use four-point scheme, and the non-blocking communication mode is higher computational than the other, because the wait time in non-blocking communication mode is less than blocking communication mode.
 
</p></abstract><kwd-group><kwd>四阶抛物方程，有限并行差分法，Message Passing Interface, Fourth Order Parabolic Equations</kwd><kwd> Finite Difference Parallel Scheme</kwd><kwd> MPI (Message Passing 
Interface)</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>基于MPI的一种有限并行差分格式求解四阶抛物方程<sup> </sup></title><p>高玉羊，顾海明</p><p>青岛科技大学，山东 青岛</p><p>收稿日期：2017年2月27日；录用日期：2017年3月18日；发布日期：2017年3月21日</p><disp-formula id="hanspub.19924-formula50"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>在大规模的科学与工程计算问题中，并行计算能够节省大量的时间，本文针对一维四阶抛物方程给出了一类并行差分格式。利用Saul’yev非对称格式进行恰当的组合，形成求解抛物方程的四点格式。四点格式是显式求解的，因此可以将空间区域分为若干子区域，每个子区域独立计算。验证分析表明，该格式是绝对稳定的。随后本文着重介绍了在MPI并行环境下对该格式进行数值计算，构建了两种不同的MPI并行算法并与串行状态下的有限差分格式做出比较，即阻塞通信(等待通信)和非阻塞通信(非等待通信)模式。相对于串行算法运用四点格式求解四阶抛物方程，两种并行通信模式都表现出极好的效果，而且，非阻塞通信模式下的计算由于相对减少了一部分数据的通信等待时间，使得相对于阻塞通信模式，非阻塞通信模式表现出较好的并行效率。</p><p>关键词 :四阶抛物方程，有限并行差分法，Message Passing Interface</p><disp-formula id="hanspub.19924-formula51"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2017 by authors and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="http://image.hanspub.org:8080\Html/htmlimages\1-2890033x\e70a10f1-7c93-45ea-9603-062237856e4b.png" /><img src="http://image.hanspub.org:8080\Html\htmlimages\1-2890033x\e898c85e-ffc4-45c9-b817-14224a4d6960.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>在自然科学和工程技术领域中，尤其是以物理学、化学、生物学等为主的学科引领了现代科学技术的快速发展，而这些学科自身的精确化又是他们取得进展的重要保证。其中，很多问题可以描述为偏微分方程或方程组的形式，因此，运用有限差分方法数值求解偏微分方程问题具有很多重要的理论意义与应用价值。</p><p>随着科学计算问题的规模不断扩大，并行计算越来越受到人们的重视，其中，高性能并行计算机的快速发展也促进了偏微分方程并行数值算法的研究。MPI是当今最重要的并行编程工具之一，MPI是一个信息传递应用程序接口，包括协议和语义说明，MPI的目标是高性能，大规模性，和可移植性。大部分的MPI实现由一些指定惯例集(API)组成，可由C，C++，Fortran，或者有此类库的语言比如C#, Java or Python直接调用。MPI优于老式信息传递库是因为他的可移植性和速度。MPI为并行算法提供了多种通信模式，其中，一般的阻塞通讯(等待通讯)模式即可满足大多数并行算法，非阻塞通讯(非等待通讯)相对减少了各并行模块之间的通讯时间，从而使得并行计算模式的效率得到提升。</p><p>关于求解二阶抛物偏微分方程的并行差分格式，已经有了很多的研究(文献 [<xref ref-type="bibr" rid="hanspub.19924-ref1">1</xref>] )，D. J. Evans和A. R. Abdullah在文献 [<xref ref-type="bibr" rid="hanspub.19924-ref2">2</xref>] 中巧妙的利用Saul’yev非对称格式(文献 [<xref ref-type="bibr" rid="hanspub.19924-ref3">3</xref>] )构造了交替分组显式(AGE)方法，以及在近年来，Evans等陆续基于AGE方法经过变换扩展到其他方面(见文献 [<xref ref-type="bibr" rid="hanspub.19924-ref4">4</xref>] ， [<xref ref-type="bibr" rid="hanspub.19924-ref5">5</xref>] ， [<xref ref-type="bibr" rid="hanspub.19924-ref6">6</xref>] )。在文献 [<xref ref-type="bibr" rid="hanspub.19924-ref7">7</xref>] 中，作者运用分组显式的方法求解了四阶椭圆方程，并应用于MPI并行计算。文献 [<xref ref-type="bibr" rid="hanspub.19924-ref8">8</xref>] ， [<xref ref-type="bibr" rid="hanspub.19924-ref9">9</xref>] 中，作者改进了AGE方法，得到交替分段方法，使数值结果更加精确。实际上，四阶抛物偏微分方程相对于二阶方程的求解有更大的困难，一般的显式格式的稳定性条件比二阶抛物方程更加苛刻，一般四阶抛物方程的隐格式形成的代数方程组的系数矩阵比二阶方程占据更大运算空间，因此，四阶抛物方程在数值求解的规模上要远远大于二阶方程。</p><p>本文在探究四阶抛物方程的并行有限差分格式时，主要借鉴于求解二阶抛物方程的差分方法，运用不同类型的Saul’yev非对称格式进行恰当的组合，对少部分点的求解形成代数方程组，从而构造出方程的显式差分格式，由于显式格式不必要求规模庞大的代数方程组，因而可以适用于并行计算。单独使用一种非对称差分格式会使误差偏上或偏下(文献 [<xref ref-type="bibr" rid="hanspub.19924-ref10">10</xref>] )，因此在时间层上交替的使用不同的非对称格式，可以使每层产生的误差抵消，从而使方程数值解的精度得到提高。</p></sec><sec id="s4"><title>2. 四阶抛物方程的非对称差分格式</title><p>考虑如下四阶抛物方程以及初边值问题，</p><disp-formula id="hanspub.19924-formula52"><label>(1)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x9_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula53"><label>(2)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x11_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula54"><label>(3)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x12_hanspub.png"  xlink:type="simple"/></disp-formula><p>建立差分格式之前，不妨设<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x13_hanspub.png" xlink:type="simple"/></inline-formula>为精确解。对求解区域<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x14_hanspub.png" xlink:type="simple"/></inline-formula>进行网格剖分，空间步长为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x15_hanspub.png" xlink:type="simple"/></inline-formula>，时间步长为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x16_hanspub.png" xlink:type="simple"/></inline-formula>。<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x17_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x18_hanspub.png" xlink:type="simple"/></inline-formula>，其中<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x19_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x20_hanspub.png" xlink:type="simple"/></inline-formula>是自然数。</p><disp-formula id="hanspub.19924-formula55"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x21_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula56"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x22_hanspub.png"  xlink:type="simple"/></disp-formula><p>将求解区域分割成矩形网格，网格节点为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x23_hanspub.png" xlink:type="simple"/></inline-formula>，为方便起见，记<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x24_hanspub.png" xlink:type="simple"/></inline-formula>为节点处的值。将<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x25_hanspub.png" xlink:type="simple"/></inline-formula>记为初边值问题(1)，(2)，(3)在网格节点<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x26_hanspub.png" xlink:type="simple"/></inline-formula>的数值解，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x27_hanspub.png" xlink:type="simple"/></inline-formula>为网格比。</p><sec id="s4_1"><title>2.1. 四阶抛物方程的显格式</title><p>易知，</p><disp-formula id="hanspub.19924-formula57"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x28_hanspub.png"  xlink:type="simple"/></disp-formula><p>方程(1)可以写成下面的形式</p><disp-formula id="hanspub.19924-formula58"><label>(4)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x29_hanspub.png"  xlink:type="simple"/></disp-formula><p>将二阶差商化为一阶得</p><disp-formula id="hanspub.19924-formula59"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x30_hanspub.png"  xlink:type="simple"/></disp-formula><p>用<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x31_hanspub.png" xlink:type="simple"/></inline-formula>代替<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x32_hanspub.png" xlink:type="simple"/></inline-formula>，舍弃无穷小项化简后可以得到</p><disp-formula id="hanspub.19924-formula60"><label>(5)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x33_hanspub.png"  xlink:type="simple"/></disp-formula><p>运用Fourier方法可以证明四阶抛物方程的显式格式是条件稳定的，此处不再赘述，稳定性条件是<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x34_hanspub.png" xlink:type="simple"/></inline-formula>，截断误差为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x35_hanspub.png" xlink:type="simple"/></inline-formula>。</p></sec><sec id="s4_2"><title>2.2. 四阶抛物方程的隐格式</title><p>易知，</p><disp-formula id="hanspub.19924-formula61"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x36_hanspub.png"  xlink:type="simple"/></disp-formula><p>方程(1)可以写成如下形式</p><disp-formula id="hanspub.19924-formula62"><label>(6)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x37_hanspub.png"  xlink:type="simple"/></disp-formula><p>舍弃无穷小，用<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x38_hanspub.png" xlink:type="simple"/></inline-formula>代替<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x39_hanspub.png" xlink:type="simple"/></inline-formula>，化简后得到</p><disp-formula id="hanspub.19924-formula63"><label>(7)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x40_hanspub.png"  xlink:type="simple"/></disp-formula><p>可以证明四阶方程的隐式格式是绝对稳定的，且局部截断误差为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x41_hanspub.png" xlink:type="simple"/></inline-formula>。</p></sec><sec id="s4_3"><title>2.3. 四阶抛物方程的非对称格式</title><p>由中值定理可以得到，</p><disp-formula id="hanspub.19924-formula64"><label>(8)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x42_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula65"><label>(9)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x43_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula66"><label>(10)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x44_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula67"><label>(11)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x45_hanspub.png"  xlink:type="simple"/></disp-formula><p>其中，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x46_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x47_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>类似于二阶抛物方程的非对称差分格式的构造(文献 [<xref ref-type="bibr" rid="hanspub.19924-ref3">3</xref>] )，尝试构造四阶抛物方程的非对称差分格式，将(8)代入方程(4)，可以得到</p><disp-formula id="hanspub.19924-formula68"><label>(12)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x48_hanspub.png"  xlink:type="simple"/></disp-formula><p>舍去无穷小项<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x49_hanspub.png" xlink:type="simple"/></inline-formula>和<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x50_hanspub.png" xlink:type="simple"/></inline-formula>，得到网格方程</p><disp-formula id="hanspub.19924-formula69"><label>(13)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x51_hanspub.png"  xlink:type="simple"/></disp-formula><p>即得到四阶抛物方程的一个非对称差分格式。</p><p>运用同样的方法，分别将(9)，(10)，(11)代入等式(6)，(4)，(6)，可以得到</p><disp-formula id="hanspub.19924-formula70"><label>(14)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x52_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula71"><label>(15)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x53_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula72"><label>(16)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x54_hanspub.png"  xlink:type="simple"/></disp-formula><p>上述四个非对称网格方程的局部截断误差为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x55_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>利用方程(13)~(16)可以构造出求解方程(1)的显式四点格式，即将其联立，可以得到一组差分方程</p><disp-formula id="hanspub.19924-formula73"><label>(17)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x56_hanspub.png"  xlink:type="simple"/></disp-formula><p>四点格式所涉及到的网格节点如图1所示。</p><p>可以将方程组(17)写成矩阵的形式，如下</p><disp-formula id="hanspub.19924-formula74"><label>(18)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x57_hanspub.png"  xlink:type="simple"/></disp-formula><p>为了求解初边值问题(1)，(2)，(3)，假设网格的剖分节点是<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x58_hanspub.png" xlink:type="simple"/></inline-formula>(<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x59_hanspub.png" xlink:type="simple"/></inline-formula>是自然数)，则内部节点数为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x60_hanspub.png" xlink:type="simple"/></inline-formula>。因此共有<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x61_hanspub.png" xlink:type="simple"/></inline-formula>个需要计算的内点，共有<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x62_hanspub.png" xlink:type="simple"/></inline-formula>个四点组使用方程组(17)计算，可以明显的看到，还有两个单独的内点无法使用四点方法计算，可以考虑将两个内点放在计算区域的最左端或者最右端，使用方程(13)和(16)处理右边界临近的内点，方程(14)，(15)处理左端边界临近的内点，这两种不同的方法与四点方法组合可以得到一种新的方法。</p><p>图1. 四点格式涉及节点</p><p>考虑右边界的两点格式，</p><disp-formula id="hanspub.19924-formula75"><label>(19)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x64_hanspub.png"  xlink:type="simple"/></disp-formula><p>将初边值条件，即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x65_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x66_hanspub.png" xlink:type="simple"/></inline-formula>代入上式，可得</p><disp-formula id="hanspub.19924-formula76"><label>(20)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x67_hanspub.png"  xlink:type="simple"/></disp-formula><p>同理，考虑左边界的两点格式，得到方程组</p><disp-formula id="hanspub.19924-formula77"><label>(21)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x68_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s4_4"><title>2.4. GER和GEL格式</title><p>当临近右边界的两点采用两点格式(20)，其余内点采用四点格式，即可得到右端分组显式(GER)格式。写成矩阵的形式为</p><disp-formula id="hanspub.19924-formula78"><label>(22)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x69_hanspub.png"  xlink:type="simple"/></disp-formula><disp-formula id="hanspub.19924-formula79"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x70_hanspub.png"  xlink:type="simple"/></disp-formula><p>与GER格式相似，在临近左边界的两个内点采用方程(21)，其余内点可以分成<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x71_hanspub.png" xlink:type="simple"/></inline-formula>个四点组，使用方程组(17)计算，可以得到左端分组显式(GEL)格式，方程如下，</p><disp-formula id="hanspub.19924-formula80"><label>(23)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x72_hanspub.png"  xlink:type="simple"/></disp-formula><p>下面对GER格式进行稳定性分析。</p><p>Kellogg引理(文献 [<xref ref-type="bibr" rid="hanspub.19924-ref10">10</xref>] )：设<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x73_hanspub.png" xlink:type="simple"/></inline-formula>，如果<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x74_hanspub.png" xlink:type="simple"/></inline-formula>为非负定实阵，即满足<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x75_hanspub.png" xlink:type="simple"/></inline-formula>非负定，则<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x76_hanspub.png" xlink:type="simple"/></inline-formula>存在，且<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x77_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>在上述引理条件下，可以得到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x78_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>方程(22)，(23)可以写成<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x79_hanspub.png" xlink:type="simple"/></inline-formula>的形式，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x80_hanspub.png" xlink:type="simple"/></inline-formula>。因<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x81_hanspub.png" xlink:type="simple"/></inline-formula>为非负定矩阵，可以得到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x82_hanspub.png" xlink:type="simple"/></inline-formula>。再由<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x83_hanspub.png" xlink:type="simple"/></inline-formula>的对称性以及特征值与范数的关系可以得到，</p><disp-formula id="hanspub.19924-formula81"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x84_hanspub.png"  xlink:type="simple"/></disp-formula><p>所以，只要<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x85_hanspub.png" xlink:type="simple"/></inline-formula>，就能得到<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x86_hanspub.png" xlink:type="simple"/></inline-formula>。因此，GER或者GEL格式是条件稳定的，稳定条件为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x87_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>条件稳定的局限性并不能满足高效的求解微分方程，因此，在下面给出了分层交替方法，使稳定性得到本质的改善。</p></sec><sec id="s4_5"><title>2.5. 分组交替方法(AGE方法)</title><p>考虑上述的GER和GEL格式，在不同的时间层上分别交替的使用两种格式，写成方程组的形式为</p><disp-formula id="hanspub.19924-formula82"><label>(24)</label><graphic position="anchor" xlink:href="http://html.hanspub.org/file/2-2620378x88_hanspub.png"  xlink:type="simple"/></disp-formula><p>其中<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x89_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x90_hanspub.png" xlink:type="simple"/></inline-formula>已在上文中定义，增长矩阵为</p><disp-formula id="hanspub.19924-formula83"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x91_hanspub.png"  xlink:type="simple"/></disp-formula><p>利用Kellogg引理，容易得到</p><disp-formula id="hanspub.19924-formula84"><graphic xlink:href="http://html.hanspub.org/file/2-2620378x92_hanspub.png"  xlink:type="simple"/></disp-formula><p>即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x93_hanspub.png" xlink:type="simple"/></inline-formula>，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x94_hanspub.png" xlink:type="simple"/></inline-formula>，即可以得到，四阶抛物方程的分层交替方法是绝对稳定的。</p></sec></sec><sec id="s5"><title>3. MPI并行算法</title><p>在本文中，所涉及到的并行算法都是基于上文中给出分组交替方法，GER方法，GEL方法实现的，在并行计算之前，首先，将求解区域<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x95_hanspub.png" xlink:type="simple"/></inline-formula>划分为若干大的区域，例如，若将抛物方程(1)进行4进程并行计算，则将求解区域分割成四条带状的区域，每个进程负责一条带状计算区域，并在时间层上逐次计算。为了实现高效计算，比较适宜的做法是为每一条进程分配大约相等的任务量，即保证在空间方向上分割的带状区域大小几乎是一致的。在进行每一时间层上的计算时，每两两相邻进程之间进行数据通信，当前时间层上的通信与计算完毕后，即进入下一时间层的计算。下文中，给出了两种不同的通信模式，即阻塞通信与非阻塞通信。一般情况下，这两种通讯模式即可满足大多数的并行计算任务。然后针对上文中论述的多种显示差分方法构造了相适应的并行处理框架，随后对其进行了并行运算。阻塞通信模式流程如表1所示。</p><p>考虑问题(1) (2) (3)，如上文，网格划分后，单一时间层上的内部节点数为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x96_hanspub.png" xlink:type="simple"/></inline-formula>(即<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x97_hanspub.png" xlink:type="simple"/></inline-formula>)，通过合适的划分网格，可以选择不同数目的进程进行计算，不失一般性，对上述三种差分格式考虑在4条进程下完成计算。首先，将整个求解区域大约的划分为四个部分，考虑GEL格式，在进程0中，前两个内部节点使用方程组(21)计算，进程0的其他内点以及其他进程的内部节点使用方程(17)计算。由于各相邻进程之间需要数据通信，此处以0号进程与1号进程之间的通信传递说明，不妨假设已知第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x98_hanspub.png" xlink:type="simple"/></inline-formula>层上的数据，求解第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x99_hanspub.png" xlink:type="simple"/></inline-formula>层上的数据，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x100_hanspub.png" xlink:type="simple"/></inline-formula>层上的动作：进程0右端的两个点的数据发送至进程1，进程1左</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> The step of blocking communication mod</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >进程0</th><th align="center" valign="middle" >其他进程</th></tr></thead><tr><td align="center" valign="middle" >步骤1</td><td align="center" valign="middle" >获得本进程的所负责的计算区间</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤2</td><td align="center" valign="middle" >读入本进程的计算数据</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤3</td><td align="center" valign="middle" >发送数据到其他进程或从其他进程接收数据</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤4</td><td align="center" valign="middle" >将数据带入差分格式并进行计算</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤5</td><td align="center" valign="middle" >进入下一时间层的计算，转到步骤3</td><td align="center" valign="middle" >同0进程</td></tr></tbody></table></table-wrap><p>表1. 阻塞通信模式下并行详细步骤</p><p>端的两内点数据发送至进程0。<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x101_hanspub.png" xlink:type="simple"/></inline-formula>层上的动作：进程0和进程1接收来自对方的数据，并运用于计算。其他进程之间的通讯也是如此，通信模式简图见图2。</p><p>在使用GER格式计算的情况下，与GEL格式类似，两点组的内部节点由最后一个进程计算，即最右端进程的最右端的两个内部节点由方程组(21)计算，其他内部节点由四点方法进行计算。与GEL格式一致，相邻进程的附近节点进行数据通信，见图3。</p><p>在使用分组交替格式计算的情况下，与GER，GEL格式有些不同之处，首先考虑在时间层第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x102_hanspub.png" xlink:type="simple"/></inline-formula>层使用GEL格式，第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x103_hanspub.png" xlink:type="simple"/></inline-formula>层使用GER格式，第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x104_hanspub.png" xlink:type="simple"/></inline-formula>层上的通讯与计算与普通的GEL格式一样，在进行第<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x105_hanspub.png" xlink:type="simple"/></inline-formula>时间层上的GER格式的计算时，在<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x106_hanspub.png" xlink:type="simple"/></inline-formula>层上，相邻两个进程的最初与最后四个内部节点的数据分别向前一个进程与后一个进程发送。通讯简图如图4所示。</p><p>在MPI并行环境下，阻塞通信模式下用到的计算与通讯过程中的命令，如下，</p><p>MPI_Send(void* buf,int count,MPI_Datatype,int destination,int tag,MPI_Comm comm)</p><p>MPI_Recv(void* buf,int count,MPI_Datatype,int source,int tag,MPI_Comm comm, MPI_Status*status)</p><p>非阻塞通信模式下三种差分格式的通信和计算与阻塞通信模式下的基本一致，差异之处在于各个进程之间的通讯可能尚未结束时，就已经在进行数据的计算，这样往往可以使CPU在各个核心在通讯的过程中，仍然满载运行，从而减少程序运行的时间，达到并行计算效率的提升。但非阻塞通讯同样带来程序实现成本的上升。非阻塞通信模式流程如表2所示。</p><p>在MPI并行环境下，非阻塞通信模式下用到的计算与通讯过程中的命令，如下</p><p>MPI_Isend(void* buf,int count,MPI_Datatype,int destination,int tag,MPI_Comm comm, MPI_Request*request)</p><p>MPI_Irecv(void* buf,int count,MPI_Datatype,int source,int tag,MPI_Comm comm, MPI_Request*request)</p><p>MPI_Waitall(int count,MPI_Request*request,MPI_Status*status)</p></sec><sec id="s6"><title>4. 数值并行计算</title><p>为了验证分层交替格式的稳定性及误差情况，以及并行效率的提升情况。作如下数值运算。对方程(1)，考虑初始条件，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x107_hanspub.png" xlink:type="simple"/></inline-formula>为初值，此时，问题(1)的精确解为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x108_hanspub.png" xlink:type="simple"/></inline-formula>。</p><p>表3为<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x109_hanspub.png" xlink:type="simple"/></inline-formula>所给出的近似解及误差情况，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x110_hanspub.png" xlink:type="simple"/></inline-formula>为绝对误差，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x111_hanspub.png" xlink:type="simple"/></inline-formula>为相对误差，<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x112_hanspub.png" xlink:type="simple"/></inline-formula>为最终计算时间。</p><p>下文中给出的数值计算结果是在ACER双核四线程计算机，处理器i3-2350M进行并行计算，定义内部节点数为40002，时间层为2000，时间步长<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x113_hanspub.png" xlink:type="simple"/></inline-formula>，针对分组交替格式，分别给出了在1、2、4、</p><p>图2. GEL格式通讯简图</p><p>图3. GER格式通讯简图</p><p>图4. AGE格式通讯简图</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> The step of non-blocking communication mod</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >进程0</th><th align="center" valign="middle" >其他进程</th></tr></thead><tr><td align="center" valign="middle" >步骤1</td><td align="center" valign="middle" >获得本进程的所负责的计算区间，并读取本进程的计算数据</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤2</td><td align="center" valign="middle" >发送数据到其他进程或从其他进程接收数据</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤3</td><td align="center" valign="middle" >非通信区域的数据计算</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤4</td><td align="center" valign="middle" >等待通信完成，计算通信区域的数据</td><td align="center" valign="middle" >同0进程</td></tr><tr><td align="center" valign="middle" >步骤5</td><td align="center" valign="middle" >进入下一时间层的计算，转到步骤2</td><td align="center" valign="middle" >同0进程</td></tr></tbody></table></table-wrap><p>表2. 非阻塞通信模式下并行详细步骤</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> The comparison of exact solution and approximate solutio</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x117_hanspub.png" xlink:type="simple"/></inline-formula></th><th align="center" valign="middle" >Exact solution <inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x118_hanspub.png" xlink:type="simple"/></inline-formula></th><th align="center" valign="middle" >Approximate solution<inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x119_hanspub.png" xlink:type="simple"/></inline-formula></th><th align="center" valign="middle" ><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x120_hanspub.png" xlink:type="simple"/></inline-formula></th><th align="center" valign="middle" ><inline-formula><inline-graphic xlink:href="http://html.hanspub.org/file/2-2620378x121_hanspub.png" xlink:type="simple"/></inline-formula></th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >0.07053</td><td align="center" valign="middle" >0.07023</td><td align="center" valign="middle" >0.00031</td><td align="center" valign="middle" >4.34677</td></tr><tr><td align="center" valign="middle" >40</td><td align="center" valign="middle" >2.77583</td><td align="center" valign="middle" >2.76178</td><td align="center" valign="middle" >0.01405</td><td align="center" valign="middle" >5.06082</td></tr><tr><td align="center" valign="middle" >80</td><td align="center" valign="middle" >5.28394</td><td align="center" valign="middle" >5.25725</td><td align="center" valign="middle" >0.02669</td><td align="center" valign="middle" >5.05077</td></tr><tr><td align="center" valign="middle" >123</td><td align="center" valign="middle" >7.40600</td><td align="center" valign="middle" >7.36869</td><td align="center" valign="middle" >0.03731</td><td align="center" valign="middle" >5.03791</td></tr><tr><td align="center" valign="middle" >163</td><td align="center" valign="middle" >8.64347</td><td align="center" valign="middle" >8.59988</td><td align="center" valign="middle" >0.04359</td><td align="center" valign="middle" >5.04310</td></tr><tr><td align="center" valign="middle" >203</td><td align="center" valign="middle" >9.04730</td><td align="center" valign="middle" >9.04019</td><td align="center" valign="middle" >0.04561</td><td align="center" valign="middle" >5.04158</td></tr><tr><td align="center" valign="middle" >243</td><td align="center" valign="middle" >8.57855</td><td align="center" valign="middle" >8.53531</td><td align="center" valign="middle" >0.04325</td><td align="center" valign="middle" >5.04139</td></tr><tr><td align="center" valign="middle" >283</td><td align="center" valign="middle" >7.28243</td><td align="center" valign="middle" >7.24570</td><td align="center" valign="middle" >0.03673</td><td align="center" valign="middle" >5.04308</td></tr><tr><td align="center" valign="middle" >323</td><td align="center" valign="middle" >5.28394</td><td align="center" valign="middle" >5.25727</td><td align="center" valign="middle" >0.02667</td><td align="center" valign="middle" >5.04770</td></tr><tr><td align="center" valign="middle" >363</td><td align="center" valign="middle" >2.77583</td><td align="center" valign="middle" >2.76185</td><td align="center" valign="middle" >0.01398</td><td align="center" valign="middle" >5.03600</td></tr><tr><td align="center" valign="middle" >402</td><td align="center" valign="middle" >0.07053</td><td align="center" valign="middle" >0.07018</td><td align="center" valign="middle" >0.00035</td><td align="center" valign="middle" >4.95515</td></tr></tbody></table></table-wrap><p>表3. 数值解与解析解及误差对比</p><p>8条进程下的程序运行时间，在多核并行运算的程序中，也给出了阻塞通信模式与非阻塞通信模式的时间效率的对比，并以图表的方式给予了清晰的展示。非阻塞通信相对于阻塞通信来说，并未改变算法的逻辑结构，非阻塞通信只是降低了通信过程中消息传递的成本，因此阻塞通信与非阻塞通信在最终数值结果上是一致的。表4~7展现了不同进程数目下的并行运算时间。表8给出不同进程数目下的并行加速比。图5~7展示了表4中时间数据的柱状图，使并行效率得到了更清晰的展示。</p></sec><sec id="s7"><title>5. 总结</title><p>在上述数值模拟计算的数据表格中，可以看出多条进程下，运用分组交替格式数值计算四阶抛物方程要比一个进程拥有更快的效率，多次试验数据表明，2条进程运算时间约是1条进程的1/2，4条进程运算时间约是1条进程的1/3，8条进程运算的时间约是一条进程的1/3，可以看到，随着进程数量的增多，程序运算的时间并没有随之线性下降，可以在表7中看到，在程序运行中，大量的时间用于各个进程之间的通信，从而导致计算效率相对于4条进程执行并未得到明显的提高。产生这种问题的原因一方面是由于进程总数过多，导致各个进程之间的通讯变得复杂。另一方面的原因是进程总数超过了计算机CPU的硬件核心总数，一个核心不再单独的只负责一个进程。所以，要达到完美的并行效果，就尽量要求进程总数与并行计算系统的计算核心总数相持平或小于CPU核心数。</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> The executive time of 4 processes in blocking and non-blocking communication mode (sec.</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >进程0</th><th align="center" valign="middle" >进程1</th><th align="center" valign="middle" >进程2</th><th align="center" valign="middle" >进程3</th><th align="center" valign="middle" >单个进程</th></tr></thead><tr><td align="center" valign="middle" >AGE阻塞通信模式计算时间</td><td align="center" valign="middle" >58.505</td><td align="center" valign="middle" >58.968</td><td align="center" valign="middle" >61.701</td><td align="center" valign="middle" >65.237</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >AGE阻塞通信模式总时间</td><td align="center" valign="middle" >81.389</td><td align="center" valign="middle" >81.360</td><td align="center" valign="middle" >81.358</td><td align="center" valign="middle" >81.359</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >AGE单进程运算执行时间</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >220.363</td></tr><tr><td align="center" valign="middle" >AGE非阻塞通信模式计算时间</td><td align="center" valign="middle" >64.990</td><td align="center" valign="middle" >63.319</td><td align="center" valign="middle" >66.774</td><td align="center" valign="middle" >63.720</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >AGE非阻塞通信模式总时间</td><td align="center" valign="middle" >76.650</td><td align="center" valign="middle" >76.709</td><td align="center" valign="middle" >76.741</td><td align="center" valign="middle" >76.675</td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >AGE非阻塞通信模式等待通信时间</td><td align="center" valign="middle" >10.529</td><td align="center" valign="middle" >11.895</td><td align="center" valign="middle" >7.635</td><td align="center" valign="middle" >8.703</td><td align="center" valign="middle" ></td></tr></tbody></table></table-wrap><p>表4. 4进程阻塞通信与非阻塞通信模式的程序运算时间比较(单位/秒)</p><table-wrap id="table5" ><label><xref ref-type="table" rid="table5">Table 5</xref></label><caption><title> The executive time of 2 processes in blocking and non-blocking communication mode for AGE scheme (sec.</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >非阻塞通信模式等待时间</th><th align="center" valign="middle" >计算时间</th><th align="center" valign="middle" >程序合计用时</th></tr></thead><tr><td align="center" valign="middle" >阻塞通信0号进程</td><td align="center" valign="middle" >Nan</td><td align="center" valign="middle" >114.011</td><td align="center" valign="middle" >121.827</td></tr><tr><td align="center" valign="middle" >阻塞通信1号进程</td><td align="center" valign="middle" >Nan</td><td align="center" valign="middle" >119.580</td><td align="center" valign="middle" >121.828</td></tr><tr><td align="center" valign="middle" >非阻塞通信0号进程</td><td align="center" valign="middle" >0.4858</td><td align="center" valign="middle" >112.353</td><td align="center" valign="middle" >113.167</td></tr><tr><td align="center" valign="middle" >非阻塞通信1号进程</td><td align="center" valign="middle" >0.4295</td><td align="center" valign="middle" >112.446</td><td align="center" valign="middle" >113.206</td></tr></tbody></table></table-wrap><p>表5. AGE格式下2进程阻塞通信与非阻塞通信模式的程序运算时间比较(单位/秒)</p><table-wrap id="table6" ><label><xref ref-type="table" rid="table6">Table 6</xref></label><caption><title> The executive time of 8 processes in blocking communication mode for AGE scheme (sec.</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >进程0</th><th align="center" valign="middle" >进程1</th><th align="center" valign="middle" >进程2</th><th align="center" valign="middle" >进程3</th><th align="center" valign="middle" >进程4</th><th align="center" valign="middle" >进程5</th><th align="center" valign="middle" >进程6</th><th align="center" valign="middle" >进程7</th></tr></thead><tr><td align="center" valign="middle" >计算时间</td><td align="center" valign="middle" >35.182</td><td align="center" valign="middle" >31.825</td><td align="center" valign="middle" >29.418</td><td align="center" valign="middle" >33.193</td><td align="center" valign="middle" >35.810</td><td align="center" valign="middle" >35.380</td><td align="center" valign="middle" >37.449</td><td align="center" valign="middle" >34.668</td></tr><tr><td align="center" valign="middle" >程序合计用时</td><td align="center" valign="middle" >71.437</td><td align="center" valign="middle" >71.439</td><td align="center" valign="middle" >71.434</td><td align="center" valign="middle" >71.433</td><td align="center" valign="middle" >71.448</td><td align="center" valign="middle" >71.442</td><td align="center" valign="middle" >71.416</td><td align="center" valign="middle" >71.388</td></tr></tbody></table></table-wrap><p>表6. AGE格式下8进程阻塞通信程序运算时间(单位/秒)</p><table-wrap id="table7" ><label><xref ref-type="table" rid="table7">Table 7</xref></label><caption><title> The executive time of 8 processes in non-blocking communication mode for AGE scheme (sec.</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >进程0</th><th align="center" valign="middle" >进程1</th><th align="center" valign="middle" >进程2</th><th align="center" valign="middle" >进程3</th><th align="center" valign="middle" >进程4</th><th align="center" valign="middle" >进程5</th><th align="center" valign="middle" >进程6</th><th align="center" valign="middle" >进程7</th></tr></thead><tr><td align="center" valign="middle" >通信等待时间</td><td align="center" valign="middle" >28.775</td><td align="center" valign="middle" >25.150</td><td align="center" valign="middle" >32.126</td><td align="center" valign="middle" >18.025</td><td align="center" valign="middle" >32.614</td><td align="center" valign="middle" >19.151</td><td align="center" valign="middle" >36.485</td><td align="center" valign="middle" >32.107</td></tr><tr><td align="center" valign="middle" >计算时间</td><td align="center" valign="middle" >38.148</td><td align="center" valign="middle" >39.938</td><td align="center" valign="middle" >35.049</td><td align="center" valign="middle" >45.287</td><td align="center" valign="middle" >33.652</td><td align="center" valign="middle" >40.086</td><td align="center" valign="middle" >30.537</td><td align="center" valign="middle" >35.573</td></tr><tr><td align="center" valign="middle" >程序合计用时</td><td align="center" valign="middle" >68.250</td><td align="center" valign="middle" >68.235</td><td align="center" valign="middle" >68.217</td><td align="center" valign="middle" >68.226</td><td align="center" valign="middle" >68.261</td><td align="center" valign="middle" >68.276</td><td align="center" valign="middle" >68.261</td><td align="center" valign="middle" >68.245</td></tr></tbody></table></table-wrap><p>表7. AGE格式下8进程非阻塞通信程序运算时间(单位/秒)</p><table-wrap id="table8" ><label><xref ref-type="table" rid="table8">Table 8</xref></label><caption><title> Comparison of the parallel efficiency in different processe</title></caption><table><tbody><thead><tr><th align="center" valign="middle" ></th><th align="center" valign="middle" >总时间(单位/秒)</th><th align="center" valign="middle" >加速比</th><th align="center" valign="middle" >并行效率</th></tr></thead><tr><td align="center" valign="middle" >非并行时</td><td align="center" valign="middle" >220.363</td><td align="center" valign="middle" >-----</td><td align="center" valign="middle" >-----</td></tr><tr><td align="center" valign="middle" >2进程阻塞通信</td><td align="center" valign="middle" >121.828</td><td align="center" valign="middle" >1.81</td><td align="center" valign="middle" >0.905</td></tr><tr><td align="center" valign="middle" >2进程非阻塞通信</td><td align="center" valign="middle" >113.206</td><td align="center" valign="middle" >1.95</td><td align="center" valign="middle" >0.975</td></tr><tr><td align="center" valign="middle" >4进程阻塞通信</td><td align="center" valign="middle" >81.389</td><td align="center" valign="middle" >2.71</td><td align="center" valign="middle" >0.678</td></tr><tr><td align="center" valign="middle" >4进程非阻塞通信</td><td align="center" valign="middle" >76.741</td><td align="center" valign="middle" >2.87</td><td align="center" valign="middle" >0.716</td></tr><tr><td align="center" valign="middle" >8进程阻塞通信</td><td align="center" valign="middle" >71.448</td><td align="center" valign="middle" >3.08</td><td align="center" valign="middle" >0.385</td></tr><tr><td align="center" valign="middle" >8进程非阻塞通信</td><td align="center" valign="middle" >68.276</td><td align="center" valign="middle" >3.23</td><td align="center" valign="middle" >0.404</td></tr></tbody></table></table-wrap><p>表8. 不同进程数下并行效率比较</p><p>图5. AGE阻塞通信模式下四进程并行计算与单进程计算的计算时间柱状图</p><p>图6. AGE非阻塞通信模式下四进程并行计算与单进程计算的计算时间柱状图</p><p>在表4~7与图7中，可以看到非阻塞通信相对于阻塞通信模式的优势。以4条进程运算为例，非阻塞通信程序的总时间相对于阻塞通信程序的总时间是减少的。在信息传递过程中，当数据发送操作已完成，非阻塞通信模式即开始数据的计算，阻塞通信模式需要等待各个进程间的通信完成，因而，非阻塞通信降低了程序的运算时间。在表8和图5，图6中，可以看到，多进程计算相当于单进程计算时是极有优势的。在表8中，随着进程总数的增加，加速比是不断提高的，但并行的效率却逐渐下降，这也从</p><p>图7. 四进程下AGE阻塞通信模式与非阻塞通信模式下时间柱状图</p><p>侧面论证了进行多进程并行运算时，要选择恰当的进程总数。在表8中，还可以看到非阻塞通信相对于阻塞通信的优势，即在相同的进程数目下，无论是加速比还是并行效率，非阻塞通信都要高于阻塞通信。</p></sec><sec id="s8"><title>文章引用</title><p>高玉羊,顾海明. 基于MPI的一种有限并行差分格式求解四阶抛物方程 A Finite Difference Parallel Scheme Based on MPI Implementation for Fourth Order Parabolic Equations[J]. 应用数学进展, 2017, 06(02): 114-126. http://dx.doi.org/10.12677/AAM.2017.62013</p></sec><sec id="s9"><title>参考文献 (References)</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.19924-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Vabishchevich, P.N. (2015) Explicit Schemes for Parabolic and Hyperbolic Equations. Applied Mathematics and Com- putation, 250, 424-431.</mixed-citation></ref><ref id="hanspub.19924-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Evans, D.J. and Abdullah, A.R. (1983) Group Explicit Methods for Parabolic Equations. International Journal Computer Mathematics, 14, 73-105. &lt;br&gt;https://doi.org/10.1080/00207168308803377</mixed-citation></ref><ref id="hanspub.19924-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Saul’yev, V.K. (1965) Integration of Equations of Parabolic Type by the Method of Nets. Proceedings of the Edinburgh Mathematical Society, 14, 247-248. &lt;br&gt;https://doi.org/10.1017/S0013091500008890</mixed-citation></ref><ref id="hanspub.19924-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Evans, D.J. and Abdullah, A.R. (1985) A New Explicit Method for the Diffusion-Convection Equation. Computers and Mathematics with Applications, 11, 145-154.</mixed-citation></ref><ref id="hanspub.19924-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Abdullah, A.R. (1991) The Four Point Explicit Decoupled Group (EDG) Method: A Fast Poisson Solver. International Journal of Computer Mathematics, 38, 61-70. &lt;br&gt;https://doi.org/10.1080/00207169108803958</mixed-citation></ref><ref id="hanspub.19924-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Evans, D.J. (1985) Alternating Group Explicit Method for the Diffusion Equations. Applied Mathematical Modelling, 9, 201-206.</mixed-citation></ref><ref id="hanspub.19924-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Ali, M., Hj, N., Teong, K. and Khoo (2010) Numerical Performance of Parallel Group Explicit Solvers for the Solution of Fourth Order Elliptic Equations. Applied Mathematics and Computation, 217, 2737-2749.</mixed-citation></ref><ref id="hanspub.19924-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Zhang, B.L. and Li, W.Z. (1994) One Alternating Segment Crank-Nicolson Scheme. Parallel Computing, 20, 897-902.</mixed-citation></ref><ref id="hanspub.19924-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">张宝琳. 求解扩散方程的交替分段显–隐式方法[J]. 数值计算与计算机应用, 1991(4): 245-253.</mixed-citation></ref><ref id="hanspub.19924-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Kellogg, R.B. (1964) An Alternating Direction Method for Operator Equations. Journal of the Society of Industrial and Applied Mathematics, 12, 7. &lt;br&gt;https://doi.org/10.1137/0112072</mixed-citation></ref></ref-list></back></article>