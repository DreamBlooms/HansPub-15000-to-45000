<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2019.97147</article-id><article-id pub-id-type="publisher-id">CSA-31311</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20190700000_65149533.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  工件具有相似加工时长时两台机上
  LPT算法的性能分析
  Performance Analysis of 
  LPT Algorithm for Jobs with Similar Sizes on Two Machines
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>王</surname><given-names>凤</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>李</surname><given-names>荣珩</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>周</surname><given-names>云霞</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>湖南师范大学数学与统计学院，计算与随机数学教育部重点实验室，湖南 长沙</addr-line></aff><aff id="aff3"><addr-line>湖南师范大学信息科学与工程学院，湖南 长沙</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>11</day><month>07</month><year>2019</year></pub-date><volume>09</volume><issue>07</issue><fpage>1309</fpage><lpage>1316</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   本文研究了工件具有相似加工时长时2台同类型平行机上LPT算法的最坏性能比。目标函数是使所有机器的最大完工时间达到最小。若工件序列L={J<sub>1</sub>,J<sub>2</sub>,...,J<sub>n</sub>}中的工件满足p<sub>j</sub>∈[1,r](r≥1)，证明了LPT算法的最坏性能比为r的分段线性函数，此结论改进了已有的最好结论，并且是不能再改进的最好结论。 In this paper, LPT algorithm is considered for the scheduling problem in which the processing times of jobs are similar on two machines. The objective function is to minimize the maximum completion time of all machines. The worst performance ratio of the LPT algorithm is given as a piecewise linear function of r if job list L={J<sub>1</sub>,J<sub>2</sub>,...,J<sub>n</sub>} satisfies p<sub>j</sub>∈[1,r](r≥1). Our result improves the best existing result. Furthermore, the ratio given here is the best. That means our result cannot be improved any more. 
  
 
</p></abstract><kwd-group><kwd>排序问题，平行机，LPT算法，最坏性能比, Scheduling Problem</kwd><kwd> Identical Machine</kwd><kwd> LPT Algorithm</kwd><kwd> Worst Performance Ratio</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>工件具有相似加工时长时两台机上LPT算法的性能分析<sup> </sup></title><p>王凤<sup>1</sup>，李荣珩<sup>1*</sup>，周云霞<sup>2</sup></p><p><sup>1</sup>湖南师范大学数学与统计学院，计算与随机数学教育部重点实验室，湖南 长沙</p><p><sup>2</sup>湖南师范大学信息科学与工程学院，湖南 长沙</p><disp-formula id="hanspub.31311-formula12"><graphic xlink:href="//html.hanspub.org/file/11-1541458x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>收稿日期：2019年6月30日；录用日期：2019年7月11日；发布日期：2019年7月18日</p><disp-formula id="hanspub.31311-formula13"><graphic xlink:href="//html.hanspub.org/file/11-1541458x8_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>本文研究了工件具有相似加工时长时2台同类型平行机上LPT算法的最坏性能比。目标函数是使所有机器的最大完工时间达到最小。若工件序列 L = { J 1 , J 2 , ⋯ , J n } 中的工件满足 p j ∈ [ 1 , r ] ( r ≥ 1 ) ，证明了LPT算法的最坏性能比为r的分段线性函数，此结论改进了已有的最好结论，并且是不能再改进的最好结论。</p><p>关键词 :排序问题，平行机，LPT算法，最坏性能比</p><disp-formula id="hanspub.31311-formula14"><graphic xlink:href="//html.hanspub.org/file/11-1541458x11_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2019 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/11-1541458x12_hanspub.png" /> <img src="//html.hanspub.org/file/11-1541458x13_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>排序问题是组合优化的重要分支之一，在生产管理、计算机信息技术处理等方面具有广泛的应用背景。自从Graham [<xref ref-type="bibr" rid="hanspub.31311-ref1">1</xref>] 在1969年首次提出排序问题以来，这个问题一直是最活跃的研究领域之一。经典排序问题是将n个独立工件 J 1 , J 2 , ⋯ , J n 分配到m台具有同样性能的机器 M 1 , M 2 , ⋯ , M m 上加工，每一个工件只需在其中一台机器上加工一次就能完工，每台机器每次只能加工一个工件。工件 J 1 , J 2 , ⋯ , J n 之间没有先后的依存关系，且 J i 的加工时间为 p i ，目标是使所有工件在最早时间内完成全部加工，也就是使得所有机器中最大完工时间达到最小。由于排序问题是NP-困难问题，我们目前只能研究多项式时间近似算法。LPT (Largest Processing time)算法是Graham [<xref ref-type="bibr" rid="hanspub.31311-ref2">2</xref>] 提出的著名近似算法。该算法首先将工件排序使其满足 p 1 ≥ p 2 ≥ ⋯ ≥ p n ，然后依次安排每个工件，每次总是把尚未投入加工的工件中编号最小者(即加工时</p><p>长最大的)送到最早空闲的机器上进行加工。LPT算法的最坏性能比是 4 3 − 1 3 m 。</p><p>在经典排序问题的算法性能比分析中是假设工件的加工时长是任意的，但实际情况中，工件的加工时长不会太小，也不会太大。为了更符合实际，也为了改进算法的性能比，促使研究工作者对工件加工时长做出适当假设。工件加工时长具有相似加工长度(即假设工件加工时长在区间[1, r]内，其中 r ≥ 1 )是常用假设之一 [<xref ref-type="bibr" rid="hanspub.31311-ref3">3</xref>] - [<xref ref-type="bibr" rid="hanspub.31311-ref8">8</xref>] ，也有假设工件最大时长已知的 [<xref ref-type="bibr" rid="hanspub.31311-ref9">9</xref>] 及假设所有工件加工时长总和是已知的 [<xref ref-type="bibr" rid="hanspub.31311-ref6">6</xref>] 。</p><p>H. Kellerer [<xref ref-type="bibr" rid="hanspub.31311-ref10">10</xref>] 给出了在m台同类型平行机上当工件具有相似的加工时长时LPT算法的性能比的上界为</p><p>R ( m , L P T , μ ) ≤ { m ( 2 k − 2 ) − μ ( k − 2 ) k m                       for   μ ∈ [ 1 + m ( k − 3 ) k − 2 , m ( k 2 − 2 k − 2 ) + k ( k − 2 ) ( k + 1 ) ] ( k + 2 ) m − 1 ( k + 1 ) m                                                                                             for   μ ∈ [ m ( k 2 − 2 k − 2 ) + k ( k − 2 ) ( k + 1 ) , 1 + m ( k − 2 ) k − 1 ]</p><p>其中 k ≥ 3 ，k为整数， p 1 p n = 2 − μ m , ( 1 ≤ μ &lt; m , μ ∈ R ) ，m表示机器数。当 μ ≤ m + 3 4 ( k = 3 ) 时， 4 m − μ 3 m 是紧的，其它区间不是紧界。</p><p>本文考虑两台机情形，即 m = 2 ，证明了LPT算法的最坏性能比为</p><p>R ( 2 , L P T , r ) = { 7 6 ,                                                                   r ≥ 3 2 , k r + k + 1 2 k + 1 ,                                           1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r &lt; 1 + 1 2 k , 4 k + 7 4 k + 6 ,                                                               1 + 1 2 k + 2 ≤ r &lt; 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                                                       r = 1.</p><p>其中 k ≥ 1 ，k为整数。</p><p>当 11 8 ≤ r ≤ 3 2 时(相当于 [<xref ref-type="bibr" rid="hanspub.31311-ref10">10</xref>] 里的 μ ∈ [ 1 , 5 4 ] ，我们得到的性能比和 [<xref ref-type="bibr" rid="hanspub.31311-ref10">10</xref>] 一样。当 r &lt; 11 8 时，我们得到的</p><p>最坏性能比比 [<xref ref-type="bibr" rid="hanspub.31311-ref10">10</xref>] 的更小。</p></sec><sec id="s4"><title>2. 定义符号</title><p>在本文中我们引入下面记号：</p><p>1) L = { J 1 , J 2 , ⋯ , J n } 为一个工件序列，其中每个工件J<sub>j</sub>的加工长度为 p j , j = 1 , 2 , ⋯ , n ；</p><p>2) p i ( j ) 表示第i台机器上的第j个工件的加工时长；</p><p>3) L i ( i = 1 , 2 , ⋯ , m ) 表示在LPT算法下最后一个工件J<sub>n</sub>被安排之前机器M<sub>i</sub>上所安排的所有工件加工时长的总和。并且我们将机器重新编号，使之满足 L 1 ≤ L 2 ≤ ⋯ ≤ L m ；</p><p>4) 设A是任一算法， C max A ( L ) 表示工件集L在算法A下所有机器的最大完工时间；</p><p>5) OPT表示最优算法。</p><p>定义1：算法A是一个近似算法， C max A ( L ) 和 C max O P T ( L ) 分别表示在A算法和最优算法下该工件序列的</p><p>最大完工时间。定义</p><p>R ( m , A ) = sup L C max A ( L ) C max O P T (L)</p><p>并称其为算法A的最坏性能比，其中 L = { J 1 , J 2 , ⋯ , J n } 为任一符合条件的工件序列。</p><p>下面我们分析LPT算法在两台机上的最坏性能比。</p></sec><sec id="s5"><title>3. 定理及其证明</title><p>对于任意工件序列 L = { J 1 , J 2 , ⋯ , J n } ，易知</p><p>C max O P T ( L ) ≥ ∑ j = 1 n p j m (1)</p><p>其中m为机器台数。</p><p>在没有特别说明的情形下，下面我们总是假设工件序列 L = { J 1 , J 2 , ⋯ , J n } 满足， p i ∈ [ 1 , r ] , p 1 ≥ p 2 ≥ ⋯ ≥ p n ，并且总是假设 m = 2 。</p><p>定理1. 当 m = 2 时，LPT算法的最坏性能比为：</p><p>R ( 2 , L P T , r ) = { 7 6 ,                                   r ≥ 3 2 , k r + k + 1 2 k + 1 ,       1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r &lt; 1 + 1 2 k , 4 k + 7 4 k + 6 , 1 + 1 2 k + 2 ≤ r ≤ 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                   r = 1.</p><p>其中 k ≥ 1 ，k为整数。</p><p>证明： r ≥ 3 2 时的结论即是Graham [<xref ref-type="bibr" rid="hanspub.31311-ref2">2</xref>] 给出的 R ( 2 , L P T ) = 4 3 − 1 3 m 当 m = 2 时的情形。当 r = 1 时，所有工件的加工时长都一样，显然LPT算法也是最优算法，所以结论显然成立。下面讨论 2 k + 3 2 k + 2 ≤ r &lt; 2 k + 1 2 k</p><p>的情形。我们首先证明对任意满足条件的工件序列L，下面不等式成立：</p><p>C max L P T ( L ) C max O P T ( L ) ≤ { k r + k + 1 2 k + 1 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r &lt; 2 k + 1 2 k , 4 k + 7 4 k + 6 2 k + 3 2 k + 2 ≤ r &lt; 1 + 2 k + 1 2 k ( 2 k + 3 ) . (2)</p><p>如果(2)不成立，设 L = { J 1 , J 2 , ⋯ , J n } 是使(2)不成立且工件个数n最小的工件序列，这样的工件序列我们称之为最小反例。对于最小反例，易知最后一个工件J<sub>n</sub>是最后完工的工件，即 C max L P T ( L ) = L 1 + p n 。</p><p>所以当 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r &lt; 2 k + 1 2 k 时，我们有</p><p>k r + k + 1 2 k + 1 &lt; C max L P T ( L ) C max O P T ( L ) = 2 ( L 1 + p n ) 2 C max O P T ( L )   ≤ L 1 + L 2 + 2 p n 2 C max O P T ( L ) = ∑ j = 1 n p j + p n 2 C max O P T ( L ) ≤ 1 + p n 2 C max O P T (L)</p><p>最后不等式由(1)得。即</p><p>C max O P T ( L ) &lt; ( 2 k + 1 ) p n 2 k ( r − 1 ) &lt; ( 2 k + 3 ) p n (3)</p><p>当 2 k + 3 2 k + 2 ≤ r &lt; 1 + 2 k + 1 2 k ( 2 k + 3 ) 时，我们同样可得(3)。因此，对于最小反例L，其总工件个数 n ≤ 4 k + 4 。</p><p>下面我们令</p><p>S i = { j | J j   在 L P T 算 法 下 安 排 在   M i   上 并 且   j ≠ n } , i = 1 , 2 ； S i * = { j | J j   在 O P T 算 法 下 安 排 在   M i   上 } , i = 1 , 2 。</p><p>易知 | S 1 ∪ S 2 | = n − 1 , | S 1 * ∪ S 2 * | = n 。</p><p>为了完成定理1的证明，我们首先给出下面的几个引理。</p><p>引理2. 对最小反例L，在LPT算法下， J 2 i − 1 和 J 2 i 安排在不同机器上 ( i = 1 , 2 , ⋯ , 2 k , 2 k + 1 ) 。</p><p>证明：假设不然，设 i 0 是使 J 2 i − 1 和 J 2 i 为第一对被LPT算法安排在同一台机器上的两个工件，不失一般性，假设都安排在 M 2 上，那么在 J 2 i 0 − 1 和 J 2 i 0 安排之前， M 1 , M 2 上的工件集 S ′ 1 , S ′ 2 满足 | S ′ 1 | = | S ′ 2 | = i 0 − 1 ，</p><p>则由LPT算法规则下面不等式必然成立：</p><p>( i 0 − 1 ) r ≥ ∑ j ∈ S ′ 1 p j ≥ ∑ j ∈ S ′ 2 p j + p 2 i 0 − 1 ≥ i 0</p><p>所以有 r ≥ i 0 i 0 − 1 ≥ 1 + 1 2 k 。这显然与 r &lt; 1 + 1 2 k 矛盾，即引理得证。</p><p>由引理2可以得出，在LPT算法下未安排工件 J 4 k + 4 时，两台机器上的工件个数相差不会超过1。</p><p>引理3. 对最小反例L，若 | S 1 * | ≥ | S 2 * | ，则 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 至少有一个成立。</p><p>证明：若 | S i ∩ S 1 * | &lt; | S i ∩ S 2 * | ( i = 1 , 2 ) 成立，则 | ( S 1 ∪ S 2 ) ∩ S 1 * | ≤ | ( S 1 ∪ S 2 ) ∩ S 2 * | + 2 成立。由定义我们有</p><p>| ( S 1 ∪ S 2 ) ∩ S i * | = { | S i * | n ∉ S i * | S i * | − 1 n ∈ S i *</p><p>这样我们有 | S 1 * | − 1 ≤ | S 2 * | + 2 ( n ∈ S 1 * ) 或者 | S 1 * | ≤ | S 2 * | + 1 ( n ∈ S 2 * ) ，此时都与假设 | S 1 * | ≥ | S 2 * | 矛盾。</p><p>引理4. 设 p , q ∈ { 1 , 2 } ，令 q &#175; = q mod 2 + 1 ，即 q = 1 时 q &#175; = 2 ，而 q = 2 时 q &#175; = 1 。若 | S p | ≤ k 0 ， | S q * | ≥ k 0 + 1 ， | S p ∩ S q * | ≥ | S p ∩ S q &#175; * | 且 k 0 ≤ 2 k ，则有</p><p>C max L P T ( L ) C max O P T ( L ) ≤ k r + k + 1 2 k + 1 (4)</p><p>证明：由 C max L P T ( L ) ≤ ∑ j ∈ S p p j + p n 和 C max O P T ( L ) ≥ ∑ j ∈ S q * p j 得</p><p>C max L P T ( L ) C max O P T ( L ) ≤ ∑ j ∈ S p p j + p n ∑ j ∈ S q * p j = ∑ j ∈ S p ∩ S q &#175; * p j + ∑ j ∈ S p ∩ S q * p j + p n ∑ j ∈ S q * \ S p p j + ∑ j ∈ S p ∩ S q * p j ≤ ∑ j ∈ S p ∩ S q &#175; * p j + | S p ∩ S q * | + 1 ∑ j ∈ S q * \ S p p j + | S p ∩ S q * | ≤ | S p ∩ S q &#175; * | r + | S p ∩ S q * | + 1 | S p ∩ S q * | + | S q * \ S p | = | S p ∩ S q &#175; * | r + | S p ∩ S q * | + | S p ∩ S q &#175; * | r + | S p ∩ S q * | + 2 2 | S q * | ≤ | S p ∩ S q * | r + | S p ∩ S q &#175; * | + | S p ∩ S q &#175; * | r + | S p ∩ S q * | + 2 2 | S q * | ≤ | S p | r + | S p | + 2 2 | S q * | = k 0 r + k 0 + 2 2 k 0 + 2 ≤ k r + k + 1 2 k + 1</p><p>上面第二个不等式是因为 p n ≥ 1 和函数 f ( x ) = a + x b + x ( a ≥ b &gt; 0 ) 在 x ≥ 0 里是x的减函数，第四个不等式由引理3得，最后一个不等式是因为 k 0 ≤ 2 k 和函数 g ( x , y ) = ( r + 1 ) x + 2 2 x + 2 是 x ≥ 0 的增函数。</p><p>引理5. 设 p , q ∈ { 1 , 2 } ，令 q &#175; = q mod 2 + 1 。若 | S P | ≤ 2 k 0 + 1 ， | S q * | ≥ 2 k 0 + 2 且 k 0 ≤ k ，则有(4)。</p><p>证明：与引理4的证明类似可得</p><p>C max L P T ( L ) C max O P T ( L ) ≤ ∑ j ∈ S p ∩ S q &#175; * p j + ∑ j ∈ S p ∩ S q * p j + p n ∑ j ∈ S q * \ S p p j + ∑ j ∈ S p ∩ S q * p j ≤ | S p ∩ S q &#175; * | r + | S p ∩ S q * | + 1 | S p ∩ S q * | + | S q * \ S p | = | S p ∩ S q &#175; * | ( r − 1 ) + | S p | + 1 | S q * | ≤ k 0 r + k 0 + 2 2 k 0 + 2 ≤ k r + k + 1 2 k + 1</p><p>上面最后一个不等式是因为函数 g ( x , y ) = ( r + 1 ) x + y 2 x + y 是 x ≥ 0 的增函数，是 y ≥ 0 的减函数。</p><p>由(3)，我们下面分 n = 2 k ′ + 1 , 2 k ′ + 2 ( k ′ ≤ 2 k ) 和 n = 4 k + 3 , 4 k + 4 这4种情况证明(4)成立。</p><p>情况1. n = 2 k ′ + 1 , k ′ ≤ 2 k 。</p><p>由 | S 1 * | + | S 2 * | = 2 k ′ + 1 不妨设 | S 1 * | ≥ k ′ + 1 。由引理2得 | S 1 | = | S 2 | = k ′ ，由引理3知， | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 至少有一个成立。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 成立。则令 p = 1 , q = 1 , k 0 = k ′ ，由引理4得(4)成立。若 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立。则令 p = 2 , q = 1 , k 0 = k ′ ，由引理4也得(4)成立。</p><p>情况2. n = 2 k ′ + 2 , k ′ ≤ 2 k 。</p><p>由引理2不妨设有 | S 1 | = k ′ , | S 2 | = k ′ + 1 , | S 1 * | ≥ k ′ + 1 。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | ，则令</p><p>p = 1 , q = 1 , k 0 = k ′ ，由引理4得(4)成立。</p><p>若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，此时若有 | S 2 * | ≥ k ′ + 1 ，令 p = 1 , q = 2 , k 0 = k ′ ，由引理4得(4)成立。否则有 | S 2 * | ≤ k ′ ，因而 | S 1 * | ≥ k ′ + 2 。则由引理3知 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立，这时令 p = 2 , q = 1 , k 0 = k ′ + 1 ，由引理4知当 k ′ &lt; 2 k 时(4)成立。</p><p>若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，且 | S 2 * | ≤ k ′ 和 k ′ = 2 k 成立，令 p = 1 , q = 2 , k 0 = k ′ ，由引理5知(4)成立，因为由 | S 1 ∩ S 1 * | ≤ | S 1 ∩ S 2 * | 可得 | S 1 ∩ S 1 * | ≤ k 。</p><p>情况3. n = 4 k + 3 。</p><p>不妨设 | S 1 * | &gt; | S 2 * | 。由引理2及(3)知 | S 1 * | = 2 k + 2 且 | S 1 | = | S 2 | = 2 k + 1 。由引理3知 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 和 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 中至少有一个成立。若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 成立，则有 | S 1 ∩ S 1 * | ≥ k + 1 ， | S 1 ∩ S 2 * | ≤ k 。令 p = 1 , q = 1 , k 0 = k ，则由引理5即得(4)成立。</p><p>若 | S 1 ∩ S 1 * | ≥ | S 1 ∩ S 2 * | 不成立，则必有 | S 2 ∩ S 1 * | ≥ | S 2 ∩ S 2 * | 成立，所以有 | S 2 ∩ S 1 * | ≥ k + 1 ， | S 2 ∩ S 2 * | ≤ k p = 2 , q = 1 , k 0 = k 则由引理5即得(4)成立。</p><p>情况4. n = 4 k + 4 。</p><p>由(3)得 | S 1 * | = | S 2 * | = 2 k + 2 。由引理2可不妨设 | S 1 | = 2 k + 1 , | S 2 | = 2 k + 2 。</p><p>若 | S 1 ∩ S 1 * | ≥ k + 1 成立，则有 | S 1 ∩ S 2 * | ≤ k 这时令 p = 1 , q = 1 , k 0 = k ，则由引理5即得(4)成立。由于 | S 1 ∩ ( S 1 * ∪ S 2 * ) | = 2 k + 1 ，若 | S 1 ∩ S 1 * | ≥ k + 1 不成立，则 | S 1 ∩ S 2 * | ≥ k + 1 成立，因而有 | S 1 ∩ S 1 * | ≤ k ，这时令 p = 1 , q = 2 , k 0 = k ，则由引理5也得(4)成立。</p><p>由上所述可知</p><p>C max L P T ( L ) C max O P T ( L ) ≤ max { k r + k + 1 2 k + 1 , 4 k + 7 4 k + 6 } = { k r + k + 1 2 k + 1 , 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r &lt; 2 k + 1 2 k 4 k + 7 4 k + 6 , 2 k + 3 2 k + 2 ≤ r &lt; 1 + 2 k + 1 2 k ( 2 k + 3 )</p><p>下面我们分别给出上面不等式等号成立的实例：</p><p>当 1 + 2 k + 1 2 k ( 2 k + 3 ) ≤ r ≤ 2 k + 1 2 k 时，我们令 L = { J 1 , J 2 , ⋯ , J 4 k + 1 } ，其相应的加工时长为 { r , r , ⋯ , r , 1 , 1 , ⋯ , 1 } ，其中时长为r和1的工件分别有2k和 2 k + 1 个。在LPT算法下， M 1 上安排时长为r和1的工件各 k , k + 1 个， M 2 上安排时长为r和1的工件各k个，故 C max L P T ( L ) = k r + k + 1 。</p><p>在OPT算法下， M 1 上安排时长为r的工件2k个， M 2 上安排时长为1的工件 2 k + 1 个，故 C max O P T ( L ) = 2 k + 1 ，即</p><p>C max L P T ( L ) C max O P T ( L ) ≤ k r + k + 1 2 k + 1</p><p>当 2 k + 3 2 k + 2 ≤ r &lt; 1 + 2 k + 1 2 k ( 2 k + 3 ) 时，我们分别给出k为奇数和偶数时紧界的实例：</p><p>当k为奇数时，令 L = { J 1 , J 2 , ⋯ , J 4 k + 5 } ，其相应加工时长为 { r , r , ⋯ , r , r ′ , r ′ , ⋯ , r ′ , 1 , 1 , ⋯ , 1 }</p><p>时长为r和 r ′ 的各有 k + 1 个，时长为1的有 2 k + 3 个，并且满足</p><p>1 &lt; r ′ &lt; r , r + r ′ = 2 k + 3 k + 1</p><p>在LPT算法下， M 1 上安排时长为r和 r ′ 的工件各有 k + 1 2 个，安排 k + 2 个时长为1的工件。 M 2 上安排时长分别为r和 r ′ 的工件各 k + 1 2 个，时长为1的工件 k + 1 个。则</p><p>C max L P T ( L ) = ( k + 1 ) ( r + r ′ ) 2 + k + 2</p><p>在OPT算法下， M 1 上安排时长为r和 r ′ 的工件各 k + 1 个， M 2 上安排 2 k + 3 个时长为1的工件，</p><p>则 C max O P T ( L ) = 2 k + 3 ，故</p><p>C max L P T ( L ) C max O P T ( L ) = 4 k + 7 4 k + 6</p><p>当k为偶数时，令 L = { J 1 , J 2 , ⋯ , J 4 k + 5 } ，其相应加工时长为 { r , r , ⋯ , r , r ′ , r ′ , ⋯ , r ′ , r ″ , r ″ , 1 , 1 , ⋯ , 1 } 长分别为r和 r ′ 的各有k个，时长为 r ″ 的工件有2个，时长为1的有 2 k + 3 个，并且满足</p><p>1 &lt; r ″ &lt; r ′ &lt; r , k ( r + r ′ ) + 2 r ″ = 2 k + 3</p><p>在LPT算法下， M 1 上安排时长为r和 r ′ 的工件各 k 2 个，安排1个时长为 r ″ 的工件和 k + 2 个时长为1的工件。 M 2 上安排时长分别为r和 r ′ 的工件各 k 2 个和1个时长为 r ' ' 的工件以及 k + 1 个时长为1的工件。则</p><p>C max L P T ( L ) = k ( r + r ′ ) 2 + r ″ + k + 2</p><p>在OPT算法下， M 1 上安排时长为r和 r ′ 的工件各k个，以及2个 r ″ ，在 M 2 上安排 2 k + 3 个时长为1的工件，则 C max O P T ( L ) = 2 k + 3 故：</p><p>C max L P T ( L ) C max O P T ( L ) = 4 k + 7 4 k + 6</p><p>综上可知，定理1得证。</p></sec><sec id="s6"><title>4. 小结</title><p>本文主要研究了工件具有相似加工时长时，LPT算法在同型平行机上的最坏性能比。证明了当 m = 2 时对于任意的工件序列L，LPT算法的最坏性能比为</p><p>R ( 2 , L P T , r ) = { 7 6 ,                                     r ≥ 3 2 , k r + k + 1 2 k + 1 ,       1 + 1 2 k − 2 2 k ( 2 k + 3 ) ≤ r &lt; 1 + 1 2 k , 4 k + 7 4 k + 6 , 1 + 1 2 k + 2 ≤ r ≤ 1 + 1 2 k − 2 2 k ( 2 k + 3 ) , 1                                     r = 1.</p><p>其中 k ≥ 1 ，k为整数。</p><p>本文成果改进了已有的最好结果，并且这是不能改进的最好结果。本文的分析比较复杂，更有趣的问题是能否改进一般性m台机时的最坏性能比。</p></sec><sec id="s7"><title>基金项目</title><p>本文得到国家自然科学基金(编号11471110)和湖南省教育厅重点课题(编号16A126)资助。</p></sec><sec id="s8"><title>文章引用</title><p>王 凤,李荣珩,周云霞. 工件具有相似加工时长时两台机上LPT算法的性能分析Performance Analysis of LPT Algorithm for Jobs with Similar Sizes on Two Machines[J]. 计算机科学与应用, 2019, 09(07): 1309-1316. https://doi.org/10.12677/CSA.2019.97147</p></sec><sec id="s9"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.31311-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Graham, R.L. (1969) Bounds on Multiprocessing Timing Anomalies. SIAM Journal on Applied Mathematics, 17, 416-429. &lt;br&gt;https://doi.org/10.1137/0117039</mixed-citation></ref><ref id="hanspub.31311-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Graham, R.L. (1976) Bounds on the Performance of Scheduling Algorithms. In: Coffmann, E.G., Ed., Computer and Job-Shop Scheduling Theory, John Wiley Sons, New York, 165-227.</mixed-citation></ref><ref id="hanspub.31311-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Cheng, T.C.E., Kellerer, H. and Kotov, V. (2012) Algorithms Better than LPT for Semi-Online Schedul-ing with Decreasing Processing Times. Operations Research Letters, 40, 349-352. &lt;br&gt;https://doi.org/10.1016/j.orl.2012.05.009</mixed-citation></ref><ref id="hanspub.31311-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">He, Y. and Dòsa, G. (2005) Semi-Online Scheduling Jobs with Tightly-Grouped Processing Times on Three Identical Machines. Discrete Applied Mathematics, 150, 140-159. &lt;br&gt;https://doi.org/10.1016/j.dam.2004.12.005</mixed-citation></ref><ref id="hanspub.31311-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">He, Y. and Zhang, G. (1999) Semi On-Line Scheduling on Two Identical Machines. Computing, 62, 179-187.  
&lt;br&gt;https://doi.org/10.1007/s006070050020</mixed-citation></ref><ref id="hanspub.31311-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Kellerer, H., Kotov, V., Speranza, M.G. and Tuza, Z. (1997) Semi On-Line Algorithms for the Partition Problem. Operations Research Letters, 21, 235-242. &lt;br&gt;https://doi.org/10.1016/S0167-6377(98)00005-4</mixed-citation></ref><ref id="hanspub.31311-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Li, R.H. and Huang, H.C. (2007) List Scheduling for Jobs with Arbitrary Release Times and Similar Lengths. Journal of Scheduling, 10, 365-373. &lt;br&gt;https://doi.org/10.1007/s10951-007-0042-8</mixed-citation></ref><ref id="hanspub.31311-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Lin, L. and Tan, Z. (2014) Inefficiency of Nash Equilibrium for Scheduling Games with Constrained Jobs: A Parametric Analysis. Theoretical Computer Science, 521, 123-134. &lt;br&gt;https://doi.org/10.1016/j.tcs.2013.11.012</mixed-citation></ref><ref id="hanspub.31311-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">He, Y. and Zhang, G. (1999) Semi On-Line Scheduling on Two Identical Machines. Computing, 62, 179-187.  
&lt;br&gt;https://doi.org/10.1007/s006070050020</mixed-citation></ref><ref id="hanspub.31311-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Kellerer, H. (1991) Bounds for Non-Preemptive Scheduling Jobs with Similar Processing Times on Multiprocessor Systems Using LPT-Algorithm. Computing, 46, 183-191. &lt;br&gt;https://doi.org/10.1007/BF02238297</mixed-citation></ref></ref-list></back></article>