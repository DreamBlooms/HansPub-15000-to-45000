<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">AAM</journal-id><journal-title-group><journal-title>Advances in Applied Mathematics</journal-title></journal-title-group><issn pub-type="epub">2324-7991</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/AAM.2020.911220</article-id><article-id pub-id-type="publisher-id">AAM-38616</article-id><article-categories><subj-group subj-group-type="heading"><subject>AAM20201100000_13928798.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>数学与物理</subject></subj-group></article-categories><title-group><article-title>
 
 
  GrO
  <sup style=" margin-left:-10px;">&#168;</sup> bner基方法验证乘法器的Maple实现
  Maple Implementation of Verification Multiplier Based on GrO
  <sup style=" margin-left:-10px;">&#168;</sup> bner Basis
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>刘</surname><given-names>佳姝</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>张</surname><given-names>璇思</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>江</surname><given-names>建国</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>辽宁师范大学数学学院，辽宁 大连</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>10</day><month>11</month><year>2020</year></pub-date><volume>09</volume><issue>11</issue><fpage>1908</fpage><lpage>1915</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
  
    乘法器电路验证问题是一项极其重要而又极具挑战性的难题。当前主流的方法是先将其建模成交换代数中的理想成员问题，然后使用Mathematica、Singular等计算机代数系统中的Gr&#246;bner基方法进行判定。本文使用计算机代数系统Maple对这一方法给出了全新实现并在计算机上进行了对比实验。实验结果表明：Maple的实现在某种程度上具有更高的验证效率，可成为乘法器电路强有力的验证平台。
    The verification of multiplier circuit is a very important and challenging problem. At present, the mainstream method is to model the ideal member problem in commutative algebra, and then use the Gr&#246;bner basis method in Mathematica, Singular and other computer algebra systems to determine. In this paper, a new implementation of this method is given by using the computer algebra system Maple, and a comparative experiment is carried out on the computer. The experimental results show that the implementation of maple has higher verification efficiency to some extent, and can be a powerful verification platform for multiplier circuits. 
  
 
</p></abstract><kwd-group><kwd>乘法器，GrO<sup style=" margin-left:-10px;">&#168;</sup> bner基，形式化方法，Maple, Multiplier</kwd><kwd> GrO<sup style=" margin-left:-10px;">&#168;</sup> bner Basis</kwd><kwd> Formal Method</kwd><kwd> Maple</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>摘要</title><p>乘法器电路验证问题是一项极其重要而又极具挑战性的难题。当前主流的方法是先将其建模成交换代数中的理想成员问题，然后使用Mathematica、Singular等计算机代数系统中的Gr&#246;bner基方法进行判定。本文使用计算机代数系统Maple对这一方法给出了全新实现并在计算机上进行了对比实验。实验结果表明：Maple的实现在某种程度上具有更高的验证效率，可成为乘法器电路强有力的验证平台。</p></sec><sec id="s2"><title>关键词</title><p>乘法器，Gr&#246;bner基，形式化方法，Maple</p></sec><sec id="s3"><title>Maple Implementation of Verification Multiplier Based on Gr&#246;bner Basis<sup> </sup></title><p>Jiashu Liu, Xuansi Zhang, Jianguo Jiang<sup>*</sup></p><p>School of Mathematics, Liaoning Normal University, Dalian Liaoning</p><p><img src="//html.hanspub.org/file/5-2621376x4_hanspub.png" /></p><p>Received: Sep. 25<sup>th</sup>, 2020; accepted: Nov. 10<sup>th</sup>, 2020; published: Nov. 17<sup>th</sup>, 2020</p><p><img src="//html.hanspub.org/file/5-2621376x5_hanspub.png" /></p></sec><sec id="s4"><title>ABSTRACT</title><p>The verification of multiplier circuit is a very important and challenging problem. At present, the mainstream method is to model the ideal member problem in commutative algebra, and then use the Gr&#246;bner basis method in Mathematica, Singular and other computer algebra systems to determine. In this paper, a new implementation of this method is given by using the computer algebra system Maple, and a comparative experiment is carried out on the computer. The experimental results show that the implementation of maple has higher verification efficiency to some extent, and can be a powerful verification platform for multiplier circuits.</p><p>Keywords:Multiplier, Gr&#246;bner Basis, Formal Method, Maple</p><disp-formula id="hanspub.38616-formula19"><graphic xlink:href="//html.hanspub.org/file/5-2621376x7_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2020 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY 4.0).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/5-2621376x8_hanspub.png" /> <img src="//html.hanspub.org/file/5-2621376x9_hanspub.png" /></p></sec><sec id="s5"><title>1. 引言</title><p>乘法器电路是计算机系统、信号处理、密码系统、机器学习等众多现代数字电路系统中的重要组成部分，对其正确性进行验证是必不可少的一个环节 [<xref ref-type="bibr" rid="hanspub.38616-ref1">1</xref>]。传统的模拟仿真技术与形式化验证方法是乘法器电路验证理论中最重要的两类验证方法。</p><p>传统的模拟仿真验证技术原理简单，可操作性强，应用范围广，但无法满足当前乘法器电路设计的巨大验证需求，取而代之的是形式化验证方法 [<xref ref-type="bibr" rid="hanspub.38616-ref2">2</xref>]。例如，结合SAT求解方法与计算机代数方法验证乘法器 [<xref ref-type="bibr" rid="hanspub.38616-ref3">3</xref>]；使用优化乘数的SCA方法验证乘法器 [<xref ref-type="bibr" rid="hanspub.38616-ref4">4</xref>] [<xref ref-type="bibr" rid="hanspub.38616-ref5">5</xref>]。</p><p>近几年来，Gr&#246;bner基方法作为形式化验证方法的一种，越来越受到学术界的广泛关注与认同。</p><p>Ritirc等人提出的逐列检测方法 [<xref ref-type="bibr" rid="hanspub.38616-ref6">6</xref>] 验证乘法器是使用C语言程序设计出相应的验证工具，并使用列式项序将电路逻辑变成切片，通过验证工具调用计算机代数系统Mathematica和Singular应用Gr&#246;bner基方法逐步验证电路每个切片的正确性进而验证乘法器的正确性。该方法在一定程度上降低了归约计算量，同时计算机代数系统Mathematica和Singular的加入，减少了手工操作，提高了其自动化程度。但在中间的约化过程中单项式数目急剧增加，验证耗费时间较长。因此，Ritirc等人在此成果之上又提出了加法器重写的方法 [<xref ref-type="bibr" rid="hanspub.38616-ref7">7</xref>]。加法器重写即提取出电路中的加法器和半加器，约化其Gr&#246;bner基的内部变量。该方法大大的优化了Gr&#246;bner基方法，加快了验证速度，并可在有限时间内验证128位乘法器。</p><p>乘法器电路验证的Gr&#246;bner基方法逐步优化，但可供选择的计算机代数系统却只有Mathematica和Singular。由于各种操作系统优缺点不同，使用不同种方法搭配不同的代数系统，其验证结果和中间可能出现的情况未知，在一定程度上具有局限性。本文使用计算机代数系统Maple对Gr&#246;bner基方法给出了全新实现并在计算机上进行了对比实验，在某种程度上加快了乘法器验证速度，为后续验证方法的优化提供更多计算机代数系统的选择。</p></sec><sec id="s6"><title>2. Gr&#246;bner基理论</title><p>本节介绍Gr&#246;bner基基础理论的关键内容，包括多项式理想、单项式序、Gr&#246;bner基定义和Gr&#246;bner基判定理想成员归属问题，相关证明和基础知识可以参考 [<xref ref-type="bibr" rid="hanspub.38616-ref8">8</xref>] [<xref ref-type="bibr" rid="hanspub.38616-ref9">9</xref>] [<xref ref-type="bibr" rid="hanspub.38616-ref10">10</xref>]。</p><p>定义2.1 设k为任意一个数域， k [ x 1 , ⋯ , x n ] 是数域k上关于变量 x 1 , ⋯ , x n 的n元多项式环，如果非空子集 I ⊆ k [ x 1 , ⋯ , x n ] 满足：</p><p>(1) 0 ∈ I 。</p><p>(2) 对任意的多项式 f ∈ I ， g ∈ I ，都有 f + g ∈ I 。</p><p>(3) 对任意的多项式 f ∈ I ， p ∈ k [ x 1 , ⋯ , x n ] ，都有 p f ∈ I 。</p><p>则称I是一个多项式理想。</p><p>任给有限个多项式 f 1 , ⋯ , f s ∈ k [ x 1 , ⋯ , x n ] ，令</p><p>〈 f 1 , ⋯ , f s 〉 = { ∑ i = 1 s h i f i | h i ∈ k [ x 1 , ⋯ , x n ] }</p><p>易证 〈 f 1 , ⋯ , f s 〉 是 k [ x 1 , ⋯ , x n ] 的多项式理想， f 1 , ⋯ , f s 是 〈 f 1 , ⋯ , f s 〉 的生成元。</p><p>定义 2.2 设N是非负整数集合</p><p>单项式集合 T n = { x β | x β = x 1 β 1 x 2 β 2 ⋯ x n β n , β i ∈ N , i = 1 , 2 , ⋯ , n }</p><p>x α , x β ∈ T n ，如果 T n 上的一个序关系&gt;满足：</p><p>(1) &gt;是一个全序。</p><p>(2) &gt;是一个良序。</p><p>(3) 若 x α &gt; x β ，对所有 x γ ∈ T n ，都有 x α x γ &gt; x β x γ 。</p><p>则序关系&gt;是单项式序。</p><p>多项式环 k [ x 1 , ⋯ , x n ] 中单项式序概念是一个基本概念。给定序关系后，可以将任一多项式 各项按序的大小惟一排列，保证n元多项式除法得到的余式是惟一的。单项式序包括字典序、分级字典序和分级逆字典序等。本文介绍字典序，其他类型项序可以参考 [<xref ref-type="bibr" rid="hanspub.38616-ref9">9</xref>]。</p><p>定义2.3 对单项式 x α , x β ，规定 x α &gt; x β ，如果 α − β 的从左向右第一个非零分量为负数，称这个序为字典序，记为 &gt; l e x 。</p><p>定义2.4 设I是 k [ x 1 , ⋯ , x n ] 的多项式理想。 l t ( g i )   ( i = 1 , 2 , ⋯ , m ) 表示 g i 的首项， 〈 l t ( I ) 〉 是I的所有元素关于字典序 &gt; l e x 的首项生成的理想，若存在I的有限子集 G = { g 1 , ⋯ , g m } 满足</p><p>〈 l t ( g 1 ) , ⋯ , l t ( g m ) 〉 = 〈 l t ( I ) 〉</p><p>则G是I的Gr&#246;bner基。</p><p>每个多项式理想都有一个Gr&#246;bner基，给定多项式理想的任意一个基，Buchberge算法会在有限步之内算出Gr&#246;bner基，具体参见 [<xref ref-type="bibr" rid="hanspub.38616-ref10">10</xref>]。</p><p>定理2.1 设G为多项式理想I的Gr&#246;bner基，多项式 f ∈ k [ x 1 , ⋯ , x n ] ，则 f ∈ I 当且仅当f被G除的余式为0，记为 r e m d ( f , G ) = 0 。</p><p>定理2.1既可以作为Gr&#246;bner基的定义，也可以作为理想成员判定问题的解决方法。</p></sec><sec id="s7"><title>3. 代数模型</title><p>我们验证具有2n个布尔输入 a 0 , ⋯ , a n − 1 , b 0 , ⋯ , b n − 1 和个n布尔输出 s 0 , ⋯ , s n − 1 的乘法器电路，电路的每个内部门(门输出)被一个门变量 g 0 , ⋯ , g k − 1 表示。定义电路变量</p><p>X = a 0 , ⋯ , a n − 1 , b 0 , ⋯ , b n − 1 , g 0 , ⋯ , g k − 1 , s 0 , ⋯ , s n − 1</p><p>我们将门输出(门变量) u与门的输入v，w用如下多项式(3.1)表示：</p><p>u = &#172; v ⇒ − u + 1 − v = 0 u = v ∧ w ⇒ − u + v w = 0 u = v ∨ w ⇒ − u + v + w − v w = 0 u = v ⊕ w ⇒ − u + v + w − 2 v w = 0 (3.1)</p><p>电路中的所有变量均为布尔变量。因此，我们可以得到关系式 u ( u − 1 ) = 0 ，此关系式被称为域多项式F。每个门的输入与输出有相对应的变量，电路中的门被转换成这些变量的多项式关系，即通过多元多项式来模拟电路的运行方式 [<xref ref-type="bibr" rid="hanspub.38616-ref11">11</xref>]。</p></sec><sec id="s8"><title>4. Gr&#246;bner基方法及其优化</title><sec id="s8_1"><title>4.1. Gr&#246;bner基方法</title><p>定义4.1 设C是一个电路， G ⊆ k [ x 1 , ⋯ , x n ] ，G为电路C中每一个门对应的多项式(见(3.1))和输入变量的域多项式 a i ( a i − 1 ) 及 b i ( b i − 1 ) 构成的多项式集合。由G生成的理想记为 J ( C ) 。</p><p>根据Gr&#246;bner基定义结合定义4.1.1可知按照字典项序 &gt; l e x 排列，G为 J ( C ) 的Gr&#246;bner基。</p><p>定义4.2 设C是一个电路，多项式 p ∈ k [ x 1 , ⋯ , x n ] ，如果将</p><p>( a 0 , ⋯ , a n − 1 , b 0 , ⋯ , b n − 1 ) ∈ { 0 , 1 } 2 n</p><p>及由 a 0 , ⋯ , a n − 1 , b 0 , ⋯ , b n − 1 表示的 g 0 , ⋯ , g k − 1 , s 0 , ⋯ , s n − 1 的值代入到多项式p中结果为0，则称多项式p是电路C的规范多项式，记为PPC。电路C的所有PPC构成的集合定义为 I ( C ) 。</p><p>定义4.3 若</p><p>∑ i = 0 2 n − 1 2 i s i − ( ∑ i = 0 n − 1 2 i a i ) ( ∑ i = 0 n − 1 2 i b i )</p><p>是PPC，则电路C是乘法器电路。</p><p>推论4.1 任一多项式 p ∈ k [ x 1 , ⋯ , x n ] ，p是PPC当且仅当 p ∈ J ( C ) 。</p><p>根据以上定义我们可得：检验一个给定电路是否是乘法器可以归结为通过Gr&#246;bner基判定理想成员问题进行验证。即给定一个电路C和其对应的规范多项式p，检验p是否属于 J ( C ) 。若p属于 J ( C ) ，则该电路为乘法器电路，反之不成立。这一部分的理论知识也可以推广到任意非循环算术电路。</p></sec><sec id="s8_2"><title>4.2. 逐位检测方法</title><p>逐位检测方法是使用列式项序将电路逻辑变成切片，应用Gr&#246;bner基方法验证每个电路切片的正确性进而验证乘法器的正确性。将乘法器验证问题分为更小更易于解决的子问题，逐步验证这些子问题进而验证乘法器。</p><p>如图1所示，在逐位检测方法中，每个电路切片包含且仅包含一个输出位。n位乘法器电路有2n个输出位，即有2n个电路切片。</p><p>图1. 3位乘法器的逐位检测方法示意图</p><p>定义4.4 设C是一个n位乘法器电路，有如下定义：</p><p>(1) 电路C的变量X上的一列多项式 C 0 , ⋯ , C 2 n 是进位序列的进位多项式。</p><p>(2) 第i个电路切片部分乘积 P i = ∑ k + l = i a k b l , ( 0 ≤ i ≤ 2 n ) 。</p><p>(3) 第i个电路切片进位递归关系 R i = − C i + 2 C i + 1 + s i − P i , ( 0 ≤ i ≤ 2 n ) 。</p><p>通过这些定义，我们得到一个抽象定理，可以用来验证经过切片处理的乘法器。</p><p>定理4.1 设C是一个所有进位递归关系都成立的电路，若 C 0 − 2 2 n C 2 n ∈ I ( C ) ，则C是乘法器。</p><p>证明</p><p>∑ i = 0 2 n − 1 2 i s i − ( ∑ i = 0 n − 1 2 i a i ) ( ∑ i = 0 2 n − 1 2 i b i ) = ∑ i = 0 2 n − 1 2 i ( P i + C i − 2 C i + 1 ) − ∑ i = 0 2 n − 1 2 i P i = ∑ i = 0 n − 1 ( 2 i C i − 2 i + 1 C i + 1 ) = C 0 − 2 2 n C 2 n (4.1)</p><p>由定义4.3可知只要证明(4.1)是PPC即可证明电路C是乘法器。为了得到逐位检测算法，我们逐步定义切片。对每个切片中的输出 s i ，定义它的输入锥即决定输出 s i 的电路逻辑门(见图1)集合 I i = { 逻 辑 门 g | g 是 输 出 s i 的 输 入 锥 } 。由输入锥可以定义切片</p><p>S 0 = I 0 ， S i + 1 = I i + 1 \ ∪ j = 0 i S j</p><p>切片Gr&#246;bner基 G i 为其切片 S i 中所有门所对应的多项式集合。综上，即可得逐位检测算法：</p><p>在算法1中， C i 是由给定的第i列的部分乘积 P i 、输出位 s i 和进位多项式 C i + 1 唯一确定的，这就保证了进位递归关系 R i 成立。实际上在算法中简单的取边界进位多项式 C 2 n = 0 。从最后一个输出位 s i ( i = 2 n − 1 ) 开始，求 2 C i + 1 + s i − P i 模切片Gr&#246;bner基 G i 和所有域多项式F的余式 C i ，通过余式结果检测每个切片的正确性。若每个电路切片所得余式均为0，则电路C是乘法器电路，进而验证了乘法器的正确性。</p></sec></sec><sec id="s9"><title>5. Maple实现</title><p>Maple是一个具有强大符号计算能力的计算机代数系统，其符号计算能力是MathCAD和Matlab等软件符号处理的核心 [<xref ref-type="bibr" rid="hanspub.38616-ref12">12</xref>]。</p><p>本文验证两种类型的乘法器，分别是btor乘法器和sp-ar-rc乘法器。在Gr&#246;bner基方法验证乘法器的Maple实现流程图中(见图2)，file1.aig为乘法器通过AIGER [<xref ref-type="bibr" rid="hanspub.38616-ref13">13</xref>] 转化得到的AIG文件。下面给出一个AIG文件的例子：</p><p>图2. Gr&#246;bner基方法验证乘法器的Maple实现流程图</p><p>aag 7 2 0 2 3 //标题</p><p>2 //输入a<sub>0</sub></p><p>4 //输入a<sub>1</sub></p><p>6 //输出b<sub>0</sub></p><p>12 //输出b<sub>1</sub></p><p>6 13 15 //与门0</p><p>12 2 4 //与门1</p><p>14 3 5 //与门2</p><p>AIG文件中第一行为标题行，7为最大变量索引，2为输入的个数，0为锁存的个数，2为输出的个数，3为与门的个数。依次列出乘法器的输入，输出和与门。本文所研究的乘法器不包含锁存，故L的值为0。我们重写验证工具AIGMULTOPOLY使其读取AIG文件后通过脚本文件中的命令行“Aigmultopoly $ aig_file $ Maple_script--maple”产生对应乘法器的Maple输出文件，通过脚本文件命令行“maple btori.maplet”使用Maple计算检测。AIGMULTOPOLY输出的 位乘法器Maple文件首先定义乘法器位数 和边界进位多项式 C 2 n ：</p><p>[&gt;] with(Groebner)；</p><p>[&gt;] Size= n；</p><p>[&gt;] Car(2*size)=0;</p><p>定义切片i的变量集M[i]和部分乘积集PP[i]。根据切片Gr&#246;bner基定义得</p><p>G i = { F I , F s [ i − 1 ] , F s [ i ] , C S [ i − 1 ] , C S [ i ] , S i } 。<sub> </sub></p><p>用切片i的规范多项式 p i 归约Gr&#246;bner基 G i ：</p><p>[&gt;] Car[i]=NormalForm(s[i]+2Car(i+1)-PP[i],[op(FI),op(Fs[i-1]),</p><p>op(Fs[i]),op(CS[i-1]),op(CS[i]), op(Si)], plex(op(MS[i])));</p><p>归约通过Maple中Groebner基库的NormalForm函数 [<xref ref-type="bibr" rid="hanspub.38616-ref14">14</xref>] 实现。NormalForm(f, polylist, order)，其中f为被归约多项式，polylist为归约多项式集合，order为变量的序关系，我们使用的是字典序，对应Groebner基库中的plex函数。根据逐位检测算法知若电路所有切片归约得到的余式Car[i]的值均为0，则输入电路为乘法器电路，反之不成立。</p><p>我们使用Maple、Mathematica和Singular三种计算机代数系统分别对乘法器验证的Gr&#246;bner基方法和加法器重写(AR)优化的Gr&#246;bner基方法进行了实验。在我们的实验中，我们将挂钟时间设</p><p>置为1200秒，主内存限制为4 GB。所有实验中的时间都以秒为单位。我们从启动验证工具AIGMULTOPOLY开始计算到Maple、Mathematica和Singular完成计算为止，所包含的时间为AIGMULTOPOLY生成Maple、Mathematica和Singular文件的时间和使用相应计算机代数系统计算的时间。我们通过TO标记未完成的实验，MO标记达到内存限制、EE标记状态错误。实验结果如下表(见表1)所示：</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> The implementation of Gr&#246;bner basis method based on different algebraic system</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  rowspan="2"  >mult</th><th align="center" valign="middle"  rowspan="2"  >n</th><th align="center" valign="middle"  colspan="2"  >Maple</th><th align="center" valign="middle"  colspan="2"  >Mathematica</th><th align="center" valign="middle"  colspan="2"  >Singular</th></tr></thead><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" >AR</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >AR</td><td align="center" valign="middle" ></td><td align="center" valign="middle" >AR</td></tr><tr><td align="center" valign="middle" >btor</td><td align="center" valign="middle" >8</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >btor</td><td align="center" valign="middle" >16</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >4</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >btor</td><td align="center" valign="middle" >32</td><td align="center" valign="middle" >16</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >27</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >20</td><td align="center" valign="middle" >1</td></tr><tr><td align="center" valign="middle" >btor</td><td align="center" valign="middle" >64</td><td align="center" valign="middle" >172</td><td align="center" valign="middle" >17</td><td align="center" valign="middle" >260</td><td align="center" valign="middle" >18</td><td align="center" valign="middle" >MO</td><td align="center" valign="middle" >18</td></tr><tr><td align="center" valign="middle" >btor</td><td align="center" valign="middle" >128</td><td align="center" valign="middle" >TO</td><td align="center" valign="middle" >402</td><td align="center" valign="middle" >TO</td><td align="center" valign="middle" >126</td><td align="center" valign="middle" >EE</td><td align="center" valign="middle" >EE</td></tr><tr><td align="center" valign="middle" >sparrc</td><td align="center" valign="middle" >8</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >sparrc</td><td align="center" valign="middle" >16</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >0</td><td align="center" valign="middle" >6</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >1</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >sparrc</td><td align="center" valign="middle" >32</td><td align="center" valign="middle" >23</td><td align="center" valign="middle" >2</td><td align="center" valign="middle" >42</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >19</td><td align="center" valign="middle" >1</td></tr><tr><td align="center" valign="middle" >sparrc</td><td align="center" valign="middle" >64</td><td align="center" valign="middle" >250</td><td align="center" valign="middle" >18</td><td align="center" valign="middle" >450</td><td align="center" valign="middle" >20</td><td align="center" valign="middle" >MO</td><td align="center" valign="middle" >19</td></tr><tr><td align="center" valign="middle" >sparrc</td><td align="center" valign="middle" >128</td><td align="center" valign="middle" >TO</td><td align="center" valign="middle" >415</td><td align="center" valign="middle" >TO</td><td align="center" valign="middle" >129</td><td align="center" valign="middle" >EE</td><td align="center" valign="middle" >EE</td></tr></tbody></table></table-wrap><p>表1. 基于不同代数系统的Gr&#246;bner基方法的实现</p><p>如表1所示，验证8~64位乘法器时，Maple计算速度较Mathematica相比更快且验证64位乘法器时，Maple不会出现Singular中超出内存限制的情况。验证128位乘法器时，环变量数超过32707个，Singular会出现错误 [<xref ref-type="bibr" rid="hanspub.38616-ref15">15</xref>]，使用Maple可以进行计算验证。但是由于C语言编程的多样性以及不同计算机代数系统不同版本的差异性使得Maple和Mathematica的验证时间略有差异。将来，我们将进一步重写优化验证工具以提高乘法器验证的效率。实验结果表明：Gr&#246;bner基方法验证乘法器通过Maple实现，在某种程度上加快了验证速度，为乘法器电路提供了强有力的验证平台。</p></sec><sec id="s10"><title>6. 结束语</title><p>本文通过Maple实现乘法器验证的Gr&#246;bner基方法，为后续乘法器电路验证方法提供更多的计算机代数系统选择。随着验证方法的逐步优化，期望可以有更多的计算机代数系统可以加入到乘法器电路验证中，进一步提高验证的自动化程度。</p></sec><sec id="s11"><title>文章引用</title><p>刘佳姝,张璇思,江建国. GrO<sup>&#168;</sup> bner基方法验证乘法器的Maple实现Maple Implementation of Verification Multiplier Based on GrO<sup>&#168;</sup> bner Basis[J]. 应用数学进展, 2020, 09(11): 1908-1915. https://doi.org/10.12677/AAM.2020.911220</p></sec><sec id="s12"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.38616-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">许琪, 原巍, 沈绪榜. 一种新的树型乘法器的设计[J]. 西安电子科技大学学报, 2002, 29(5): 805-812.</mixed-citation></ref><ref id="hanspub.38616-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">韩俊刚, 杜敏慧. 数字硬件的形式化验证[M]. 北京: 北京大学出版社, 2001.</mixed-citation></ref><ref id="hanspub.38616-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Kaufmann, D., Biere, A. and Kauers, M. (2019) Verifying Large Multipliers by Combining SAT and Computer Algebra. FMCAD, San Jose, 22-25 October 2019, 28-36. &lt;br&gt;https://doi.org/10.23919/FMCAD.2019.8894250</mixed-citation></ref><ref id="hanspub.38616-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Mahzoon, A., Große, D. and Drechsler, R. (2018) PolyCleaner: Clean Your Polynomials before Backward Rewriting to Verify Million-Gate Multipliers. ICCAD, California, 5-8 November 2018, 129:1-129:8.  
&lt;br&gt;https://doi.org/10.1145/3240765.3240837</mixed-citation></ref><ref id="hanspub.38616-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Mahzoon, A., Große, D. and Drechsler, R. (2020) Towards Formal Verification of Optimized and Industrial Multipliers. DATE, Grenoble, 9-13 March 2020, 544-549. &lt;br&gt;https://doi.org/10.23919/DATE48585.2020.9116485</mixed-citation></ref><ref id="hanspub.38616-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Ritirc, D., Biere, A. and Kauers, M. (2017) Column-Wise Verification of Multipliers Using Computer Algebra. FMCAD, Vienna, 2-6 October 2017, 23-30. &lt;br&gt;https://doi.org/10.23919/FMCAD.2017.8102237</mixed-citation></ref><ref id="hanspub.38616-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Ritirc, D., Biere, A. and Kauers, M. (2018) Improving and Extending the Algebraic Approach for Verifying Gate-Level Multipliers. DATE, Dresden, 19-23 March 2018, 1556-1561.  
&lt;br&gt;https://doi.org/10.23919/DATE.2018.8342263</mixed-citation></ref><ref id="hanspub.38616-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">王东明, 夏壁灿. 计算机代数[M]. 北京: 清华大学出版社, 2003.</mixed-citation></ref><ref id="hanspub.38616-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Becke, T. and Eispfenning, V. (1993) Gröbner Bases. Springer-Verlag, New York.  
&lt;br&gt;https://doi.org/10.1007/978-1-4612-0913-3_6</mixed-citation></ref><ref id="hanspub.38616-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Cox, D., Little, J. and O’Shea, D. (1997) Ideals, Varieties, and Algorithms. Springer-Verlag, New York.  
&lt;br&gt;https://doi.org/10.1007/978-1-4757-2693-0</mixed-citation></ref><ref id="hanspub.38616-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">Keim, M., Dreschlerc, R. and Becker, B. (2003) Polynomial Formal Verification of Multipliers. Formal Methods in System Design, 22, 39-58. &lt;br&gt;https://doi.org/10.1023/A:1021752130394</mixed-citation></ref><ref id="hanspub.38616-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">刘辉, 李海. MAPLE符号处理及应用[M]. 北京: 国防工业出版社, 2000.</mixed-citation></ref><ref id="hanspub.38616-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">Biere, A. (2017) The AIGER And-Inverter Graph (AIG) Format Version.</mixed-citation></ref><ref id="hanspub.38616-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">何青, 王丽芬. Maple教程[M]. 北京: 科学出版社, 2006.</mixed-citation></ref><ref id="hanspub.38616-ref15"><label>15</label><mixed-citation publication-type="other" xlink:type="simple">Decker, W., Greuel, G.M., Pfifister, G. and Schonemann, H. (2016) SINGULAR. http://www.singular.uni-kl.de</mixed-citation></ref></ref-list></back></article>