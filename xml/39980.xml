<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2021.111012</article-id><article-id pub-id-type="publisher-id">CSA-39980</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20210100000_70044218.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  大规模在线实训环境下的快速容器并发启动研究
  Research on Container Concurrent Initiation under Large-Scale Online Training Environment
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>毕</surname><given-names>枫林</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>田</surname><given-names>春岐</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>王</surname><given-names>伟</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>唐</surname><given-names>骏</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>同济大学，电子与信息工程学院，上海</addr-line></aff><aff id="aff3"><addr-line>华东师范大学，数据科学与工程学院，上海</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>08</day><month>01</month><year>2021</year></pub-date><volume>11</volume><issue>01</issue><fpage>101</fpage><lpage>112</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   随着在线教育业务的快速增长，需要越来越多的技术来支撑在线教育的不同场景。本文进行了在大规模在线实训环境下的虚拟化技术的可行性探索，得出了容器技术符合在线实训环境的需求的结果，并且得出以下结论：1) 确定数学模型来选择与Docker通信的最佳方式；2) 对大规模在线实训环境下的容器并发启动场景进行了研究，总结出了CPU是影响容器并发启动时延的主要因素；3) 容器镜像大小对容器并发启动影响较小；4) 容器并发启动性能消耗主要阶段在容器启动阶段。 With the rapid growth of online education, more and more technologies are needed to support different scenarios of online education. This paper explores the feasibility of virtualization technology in large-scale online training environment, and concludes that container technology meets the requirements of online training environment. The following conclusions are drawn: 1) the mathematical model is determined to choose the best way of communication with Docker; 2) the container concurrent startup scenario under large-scale online training environment is studied, and it is concluded that CPU is the main factor affecting the container concurrent startup delay; 3) the container image size has little influence on the container concurrent startup; 4) the container concurrent startup performance consumption is mainly in the container startup stage. 
  
 
</p></abstract><kwd-group><kwd>Docker，虚拟化技术，并发，容器，通信方式, Docker</kwd><kwd> Virtualization Technology</kwd><kwd> Concurrent</kwd><kwd> Container</kwd><kwd> Communication Mode</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>摘要</title><p>随着在线教育业务的快速增长，需要越来越多的技术来支撑在线教育的不同场景。本文进行了在大规模在线实训环境下的虚拟化技术的可行性探索，得出了容器技术符合在线实训环境的需求的结果，并且得出以下结论：1) 确定数学模型来选择与Docker通信的最佳方式；2) 对大规模在线实训环境下的容器并发启动场景进行了研究，总结出了CPU是影响容器并发启动时延的主要因素；3) 容器镜像大小对容器并发启动影响较小；4) 容器并发启动性能消耗主要阶段在容器启动阶段。</p></sec><sec id="s2"><title>关键词</title><p>Docker，虚拟化技术，并发，容器，通信方式</p></sec><sec id="s3"><title>Research on Container Concurrent Initiation under Large-Scale Online Training Environment<sup> </sup></title><p>Fenglin Bi<sup>1*</sup>, Chunqi Tian<sup>1</sup>, Wei Wang<sup>2#</sup>, Jun Tang<sup>1</sup></p><p><sup>1</sup>School of Electronics and Information Engineering, Tongji University, Shanghai</p><p><sup>2</sup>School of Data Science &amp; Engineering, East China Normal University, Shanghai</p><p><img src="//html.hanspub.org/file/12-1541975x5_hanspub.png" /></p><p>Received: Dec. 25<sup>th</sup>, 2020; accepted: Jan. 19<sup>th</sup>, 2021; published: Jan. 26<sup>th</sup>, 2021</p><p><img src="//html.hanspub.org/file/12-1541975x6_hanspub.png" /></p></sec><sec id="s4"><title>ABSTRACT</title><p>With the rapid growth of online education, more and more technologies are needed to support different scenarios of online education. This paper explores the feasibility of virtualization technology in large-scale online training environment, and concludes that container technology meets the requirements of online training environment. The following conclusions are drawn: 1) the mathematical model is determined to choose the best way of communication with Docker; 2) the container concurrent startup scenario under large-scale online training environment is studied, and it is concluded that CPU is the main factor affecting the container concurrent startup delay; 3) the container image size has little influence on the container concurrent startup; 4) the container concurrent startup performance consumption is mainly in the container startup stage.</p><p>Keywords:Docker, Virtualization Technology, Concurrent, Container, Communication Mode</p><disp-formula id="hanspub.39980-formula6"><graphic xlink:href="//html.hanspub.org/file/12-1541975x7_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2021 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY 4.0).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/12-1541975x8_hanspub.png" /> <img src="//html.hanspub.org/file/12-1541975x9_hanspub.png" /></p></sec><sec id="s5"><title>1. 引言</title><p>随着容器技术越来越流行，Docker的应用也越来越广泛，不仅仅只有用来更快地开发或者部署应用 [<xref ref-type="bibr" rid="hanspub.39980-ref1">1</xref>]，还有了其他应用场景，比如用来实现Serverless [<xref ref-type="bibr" rid="hanspub.39980-ref2">2</xref>]，利用Docker来管理交换机的存储、计算和网络资源 [<xref ref-type="bibr" rid="hanspub.39980-ref3">3</xref>]，完成高性能多任务计算 [<xref ref-type="bibr" rid="hanspub.39980-ref4">4</xref>] 等等。Docker容器由Docker引擎执行和控制，这与虚拟机(Virtual machine简称VM)的管理程序不同。由于它不包含完整的客户操作系统(Guest OS)，所以Docker容器比VM更小，启动速度更快。Docker容器装载一个单独的根文件系统，其中包含类Unix操作系统的目录结构，以及运行用户应用程序所需的所有配置文件、二进制文件和库 [<xref ref-type="bibr" rid="hanspub.39980-ref5">5</xref>]。可以模拟用户进行学习的实验场景。Docker也被应用于构建大规模在线实训平台，利用Docker轻量级虚拟化技术，并且拥有快速弹性伸缩的特性，能够给予用户一个完整的实训体验。</p><p>在此类场景下特点有：1) 容器生灭快，容器生存周期短。2) 容器操作并发量大。3) 容器镜像稳定，实训环境固定，容器镜像变化不频繁。4) 大量线程跟Docker宿主机进行(Http or Socket)通信，要求网络稳定，网络抖动小。5) 充分利用云平台特性，动态地给予用户云平台资源。6) 不进行高性能计算(HPC)。</p><p>本文主要针对以下问题进行研究：1) 确定高并发容器启动下的容器通信方式，确定一个可靠的数学模型可以进行通信方式选择。2) 确定影响容器并发启动的各个因素，并且确定容器并发启动的性能瓶颈。</p></sec><sec id="s6"><title>2. 研究现状</title><p>Docker是一个新的工具，它可以在Linux容器中自动部署应用程序。它提供了操作系统级虚拟化的抽象层和自动化。容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个独立的进程，不占用比其他任何可执行程序更多的内存，使其轻量级。Docker本身并不是一项新技术，但它是一个高级工具，最初构建在LXC API之上，并提供附加功能。Docker容器由Docker引擎执行和控制，这与VM的管理程序不同。因为它不包括一个完整的客户访问的操作系统(Guest OS) Docker容器比VM更小，启动速度更快 [<xref ref-type="bibr" rid="hanspub.39980-ref4">4</xref>]。</p><p>Docker与VM的不同之处：1) Docker容器由Docker引擎执行和控制，这与VM的管理程序不同。2) 因为它不包括一个完整的客户操作系统(Guest OS) Docker容器比VM更小，启动速度更快 [<xref ref-type="bibr" rid="hanspub.39980-ref6">6</xref>]。见图1。</p><p>针对大规模在线实训平台的场景，我们先比较了各个虚拟化方案：1) 内核虚拟机(Kernel-based Virtual Machine，简称KVM) [<xref ref-type="bibr" rid="hanspub.39980-ref7">7</xref>]：需要消耗的资源太大，过于重量级，不适用于快速生灭的特点。2) 容器 [<xref ref-type="bibr" rid="hanspub.39980-ref8">8</xref>]：是轻量级虚拟化的一种形式，通过对进程制造一定的限制来完成虚拟化工作，容器化的系统都运行在主机的内核上。3) unikernels [<xref ref-type="bibr" rid="hanspub.39980-ref9">9</xref>]：硬件级虚拟化的一种，将简约的LibOS和目标应用程序专门化为在虚拟机监控器(Virtual Machine Monitor，简称VMM)上运行的单一用途虚拟机，不适用于开放式场景。</p><p>通过各个方案比较确定使用容器作为该场景下的虚拟化方案。并且在Http代理场景下，Docker性能要优于KVM [<xref ref-type="bibr" rid="hanspub.39980-ref10">10</xref>]，符合线上运行环境要求。</p><p>图1. Container与VM架构对比</p><sec id="s6_1"><title>2.1. 国外研究现状</title><p>有不少人针对虚拟化技术进行过测评，文献 [<xref ref-type="bibr" rid="hanspub.39980-ref11">11</xref>] 在基于Linux容器的Docker和虚拟机管理程序(Hypervisor)上构建了云环境，分析了它们的大小、启动速度和CPU性能。文献 [<xref ref-type="bibr" rid="hanspub.39980-ref12">12</xref>] 在性能和可伸缩性方面比较了Linux容器和虚拟机。文献[<xref ref-type="bibr" rid="hanspub.39980-ref10">10</xref>]在Http代理场景中提供了两个开源虚拟化解决方案KVM和Docker的性能分析。文献 [<xref ref-type="bibr" rid="hanspub.39980-ref13">13</xref>] 提供了在OpenStack云平台中并发地请求多个运行实例时，对KVM (虚拟机)、Docker (容器)和OSv (Unikernel)的评估。</p><p>还有很多人做了容器相关的测评工作SOCK [<xref ref-type="bibr" rid="hanspub.39980-ref14">14</xref>] 分别对容器存储，逻辑隔离，性能隔离做了测评。SLACKER [<xref ref-type="bibr" rid="hanspub.39980-ref15">15</xref>] 对容器镜像大小，执行需要多少数据，推、拉和运行图像需要多长时间等方面进行了测评。还有一些专注于MYSQL [<xref ref-type="bibr" rid="hanspub.39980-ref16">16</xref>] 或者一些更复杂的网络应用程序，比如安装了Mysql的负载平衡的Wordpress [<xref ref-type="bibr" rid="hanspub.39980-ref17">17</xref>]，文献 [<xref ref-type="bibr" rid="hanspub.39980-ref18">18</xref>] 对Docker容器的网络模式进行了评测。文献 [<xref ref-type="bibr" rid="hanspub.39980-ref5">5</xref>] 对不同容器在HPC平台下的容器性能的评测。</p></sec><sec id="s6_2"><title>2.2. 国内研究现状</title><p>国内对容器的研究也有很多，文献 [<xref ref-type="bibr" rid="hanspub.39980-ref19">19</xref>] [<xref ref-type="bibr" rid="hanspub.39980-ref20">20</xref>] 对Docker本身的网络架构做出了深入研究，利用多种技术和方法来对网络隔离和网络控制做出了改进。文献 [<xref ref-type="bibr" rid="hanspub.39980-ref21">21</xref>] 将依赖库文件与可执行二进制文件单独抽取成层，实现了容器对主机内存资源的最大化共享，以较小的时间延时启动新的容器。国内大多数工作与对容器资源调度有关，提供一个有效的算法模型来提高容器的资源调度，文献 [<xref ref-type="bibr" rid="hanspub.39980-ref22">22</xref>] 将Kubernetes结合已有Openstack云平台，提出一种基于容器的弹性调度策略，建立了一个提高集群资源利用率的优化模型，通过对云平台各个服务器节点四种类型资源的监控和应用队列预设模板匹配，选择调度资源利用率最高的服务器。还有文献 [<xref ref-type="bibr" rid="hanspub.39980-ref23">23</xref>] 提出了一种基于三次指数平滑法和时间卷积网络的云资源预测模型，根据预测值为应用及时、准确、动态地调度和分配资源。</p><p>据我们所知极少人人对容器的并发启动进行过相关的工作，而容器并发启动在很多场景下非常有必要。许多场景下都会需要容器大规模的并发启动。</p></sec></sec><sec id="s7"><title>3. 通讯方式的选择</title><p>Docker deamon是Docker最核心的后台进程，他负责响应来自Docker client的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个API server，负责由Docker client发送的请求；接收到的请求将通过Docker deamon分发调度，再由具体的函数来执行请求 [<xref ref-type="bibr" rid="hanspub.39980-ref24">24</xref>]。</p><p>要与Docker daemon通过rest API通信，有三种通信方式：1) Unix domain socket (简称Unix Socket)，2) Systemd socket activation，3) TCP。其中Systemd socket activation的工作方式是让systemd守护进程代表应用程序打开监听Socket，并且仅在连接进入时才启动它。然后将套接字交给新启动的应用程序，由它负责 [<xref ref-type="bibr" rid="hanspub.39980-ref25">25</xref>]。本质上也是Unix Socket通信。</p><p>为了研究高并发情境下哪种方式与Docker守护进程通信最佳，我们进行了多组实验。</p><sec id="s7_1"><title>3.1. 实验环境</title><p>本文测试环境使用服务器1台，主要是与容器通讯方式的选择和容器并发启动影响的相关因素进行研究，容器版本为Docker18.06.2-ce，服务器配置如表1。为了排除网络带宽限制等影响，我们采用直接请求本机的Docker守护进程，这样不会产生额外的消耗，使Tcp和Unix Socket结果更加真实。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Experimental environmen</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >组件</th><th align="center" valign="middle" >规格</th></tr></thead><tr><td align="center" valign="middle" >CPU</td><td align="center" valign="middle" >8 CPUS x Intel(R) Xeon(R) CPU E5-2630 v4 @ 2.20 GHz</td></tr><tr><td align="center" valign="middle" >内存</td><td align="center" valign="middle" >16G</td></tr><tr><td align="center" valign="middle" >操作系统</td><td align="center" valign="middle" >Ubuntu 16.04.6 LTS</td></tr><tr><td align="center" valign="middle" >Docker版本</td><td align="center" valign="middle" >18.06.2-ce</td></tr></tbody></table></table-wrap><p>表1. 实验环境</p></sec><sec id="s7_2"><title>3.2. 顺序执行</title><p>我们对两种通信方式进行实验，分别顺序执行200次List Images [<xref ref-type="bibr" rid="hanspub.39980-ref26">26</xref>] 方法请求Docker deamon，时延为以向Docker demon发送请求开始到Docker deamon返回数据为止。得到的实验结果中Unix Socket通信响应时间的平均值为2499.73 &#181;s，Tcp通信的平均响应时间为2909.11 &#181;s，如图2。实验结果中Unix Socket与Tcp的传输时延区别不是非常明显，Unix domain socket平均通信时间比Tcp提高了大约10%，不过我们为了测量网络抖动，引用了变异系数来确定网络抖动情况，公式为：</p><p>C = n Σ ​ x 2 − ( Σ ​ x ) 2 n ( n − 1 ) Σ ​ x n (1)</p><p>公式(1)中x为一次请求的延时，n为请求次数。最后得出结果Unix Socket的变异系数为0.002724，Tcp的变异系数0.004679，可见Http通信方式的网络抖动比Unix Socket通信方式高了大约一倍。</p><p>因此我们可以得到结论，在顺序启动容器时与Docker demon进行通信时，Unix Socket的通信延时和网络稳定性都优于Tcp方式。</p><p>图2. Unix Socket与Tcp顺序执行200次请求时延</p><p>图3. Unix Socket与Tcp 1~1000次并发请求时延</p></sec><sec id="s7_3"><title>3.3. 并发执行</title><p>我们对两种通信方式进行实验，分别并发执行1~1000次List Images [<xref ref-type="bibr" rid="hanspub.39980-ref24">24</xref>] 方法请求Docker deamon，时延为以向docker demon发送请求开始到Docker deamon返回数据为止。我们发现，当达到一定并发量时，使用Unix Socket通信方式请求Docker deamon，Docker deamon无法正常响应。图3为Unix Socket与Tcp各并发执行1000次的时延，当Unix sock时延没有数据说明Docker deamon出现无法正常响应的情况，容器也没有启动成功，根据图中数据可以得出当前实验环境下Unix Socket能接受的最大并发请求数为80次左右，而Tcp方式不论并发请求次数多少都可以正常响应。</p><p>表2是不同并发次数的各个数据，为了降低偶然性，我们不同并发次数执行各了10次，然后将10次数据汇总起来一起统计。整体而言在并发情况下，可以看出Unix Socket通信方式响应速度更快，可以承载的并发数量低，网络抖动小。Tcp通信方式响应速度慢，可以承载的并发数量高，网络抖动大。因此我们建立了一个数学模型来确定Unix Socket和Tcp两种方式的优劣</p><p>R = t x − t min t max − t min + c x − c min c max − c min + e r r (2)</p><p>S = min ( R u , R t ) (3)</p><p>公式(2)为计算优劣系数，其中t<sub>x</sub>为平均通信时延，t<sub>min</sub>为通信时延最小值，t<sub>max</sub>为通信时延最大值，c<sub>x</sub>为变异系数值，c<sub>min</sub>为变异系数最小值，c<sub>max</sub>为变异系数最大值。err为请求失败次数。</p><p>公式(3)为取Unix Socket和Tcp两种通信方式计算得出的优劣系数最小的值为最佳通信方式。根据我们的实验结果得出结论并发启动在一定数量之前选择Unix Socket通信方式最佳。在并发启动数量在一定数量之后选择Tcp通信方式最佳。</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Unix Socket and Tcp two kinds of communication statistic</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >通信方式</th><th align="center" valign="middle" >并发次数</th><th align="center" valign="middle" >最大响应时延(ns)</th><th align="center" valign="middle" >最小响应时延(ns)</th><th align="center" valign="middle" >平均通信时延(ns)</th><th align="center" valign="middle" >变异系数</th><th align="center" valign="middle" >异常次数</th></tr></thead><tr><td align="center" valign="middle" >Unix Socket</td><td align="center" valign="middle" >100</td><td align="center" valign="middle" >69</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >29.304</td><td align="center" valign="middle" >0.000478028</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >tcp</td><td align="center" valign="middle" >100</td><td align="center" valign="middle" >88</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >32.916</td><td align="center" valign="middle" >0.000535878</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >Unix Socket</td><td align="center" valign="middle" >200</td><td align="center" valign="middle" >110</td><td align="center" valign="middle" >6</td><td align="center" valign="middle" >59.776</td><td align="center" valign="middle" >0.000201821</td><td align="center" valign="middle" >2</td></tr><tr><td align="center" valign="middle" >tcp</td><td align="center" valign="middle" >200</td><td align="center" valign="middle" >120</td><td align="center" valign="middle" >6</td><td align="center" valign="middle" >63.309</td><td align="center" valign="middle" >0.000194561</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >Unix Socket</td><td align="center" valign="middle" >300</td><td align="center" valign="middle" >180</td><td align="center" valign="middle" >5</td><td align="center" valign="middle" >77.171</td><td align="center" valign="middle" >0.000150895</td><td align="center" valign="middle" >89</td></tr><tr><td align="center" valign="middle" >tcp</td><td align="center" valign="middle" >300</td><td align="center" valign="middle" >197</td><td align="center" valign="middle" >9</td><td align="center" valign="middle" >92.733</td><td align="center" valign="middle" >0.000127485</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >Unix Socket</td><td align="center" valign="middle" >500</td><td align="center" valign="middle" >275</td><td align="center" valign="middle" >12</td><td align="center" valign="middle" >131.661</td><td align="center" valign="middle" >0.000096416879</td><td align="center" valign="middle" >349</td></tr><tr><td align="center" valign="middle" >tcp</td><td align="center" valign="middle" >500</td><td align="center" valign="middle" >303</td><td align="center" valign="middle" >12</td><td align="center" valign="middle" >155.422</td><td align="center" valign="middle" >0.000081914477</td><td align="center" valign="middle" >0</td></tr><tr><td align="center" valign="middle" >Unix Socket</td><td align="center" valign="middle" >1000</td><td align="center" valign="middle" >515</td><td align="center" valign="middle" >3</td><td align="center" valign="middle" >201.462</td><td align="center" valign="middle" >0.000067467604</td><td align="center" valign="middle" >2083</td></tr><tr><td align="center" valign="middle" >tcp</td><td align="center" valign="middle" >1000</td><td align="center" valign="middle" >624</td><td align="center" valign="middle" >28</td><td align="center" valign="middle" >331.870</td><td align="center" valign="middle" >0.000040800157</td><td align="center" valign="middle" >0</td></tr></tbody></table></table-wrap><p>表2. Unix Socket与Tcp两种通信统计</p></sec></sec><sec id="s8"><title>4. 容器并发影响因素</title><sec id="s8_1"><title>4.1. 容器启动过程</title><p>我们测试容器并发启动，因此容器镜像下载的时延不在我们考虑之内，所以我们提前下载好要测试的镜像，确保容器镜像传输不影响容器并发启动实验数据。</p><p>单个容器启动过程如图4，1) Client发送一个创建容器请求。2) Docker deamon接收请求进行处理后调用Linux namespace等命令进行创建容器操作。3) 容器创建成功发送创建成功的响应给Client。4) Client发送容器启动请求给Docker deamon。5) Docker deamon进行启动容器操作。6) Docker demon返回给Client端响应，同时容器进行加载库文件和启动相关服务等操作，为了避免Docker demon没有正常响应请求问题，我们统一采用Tcp方式请求Docker deamon。</p><p>测试容器启动成果条件根据容器镜像类型不同而不同，我们对容器类型进行了分类，如表3。我们利用在容器中运行最简单的任务或等待容器报告就绪来度量启动时间。作为语言类容器，任务就是的编译或者解释一个简单的“hello world”语言程序。Linux发行版的镜像就是运行一个非常简单的shell命令，通常是“echo hello”。对于长时间运行的服务器(尤其是数据库和web服务器)，我们测量到容器输出“ready”的信息的时间。对于一些特别的服务器，将轮询公开端口，直到有响应为止。</p><p>图4. 容器启动流程</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> Container image classificatio</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >类别</th><th align="center" valign="middle" >镜像</th></tr></thead><tr><td align="center" valign="middle" >Linux发行版</td><td align="center" valign="middle" >alpine, busybox, centos, cirros, crux, Debian, fedora, mageia, opensure, oracleLinux, ubuntu, ubuntu-debootstrap, ubuntu-upstart</td></tr><tr><td align="center" valign="middle" >数据库类</td><td align="center" valign="middle" >cassandra, crate, elasticsearch, mariadb, mongo, mysql, percona, postgres, redis, rethinkdb</td></tr><tr><td align="center" valign="middle" >语言类</td><td align="center" valign="middle" >Clojure, gcc, golang, haskell, hylang, java, jruby, julia, mono, perl, php, pypy, python, r-base, rakudo-star, ruby, thrift</td></tr><tr><td align="center" valign="middle" >Web服务器类</td><td align="center" valign="middle" >Glassfish, httpd, jetty, nginx, php-zendserver, tomcat</td></tr><tr><td align="center" valign="middle" >Web框架类</td><td align="center" valign="middle" >Django, iojs, node, rails</td></tr><tr><td align="center" valign="middle" >其他</td><td align="center" valign="middle" >Drupal, ghost, hello-world, jenkins, rabbitmq, registry, sonarqube</td></tr></tbody></table></table-wrap><p>表3. 容器镜像分类</p></sec><sec id="s8_2"><title>4.2. 容器并发启动硬件因素分析</title><p>首先我们对容器并发启动时延进行了测试，启动的镜像为ubuntu。结果如图5，可知容器的平均启动时延与并发启动的次数成正比，平均启动时延随着并发启动次数的增加而增大。</p><p>我们对启动过程影响因素进行了汇总，主要通过容器并发启动时CPU使用率，内存使用情况和磁盘IO值来确定。磁盘IO值使用磁盘工作时间占用总时间的百分比。公式为：</p><p>u t i l = Δ i o Δ t (4)</p><p>公式(4)中为Δ<sub>io</sub>写操作消耗的时间，Δ<sub>t</sub>为采样周期。为了研究并发启动时何种因素对容器启动速度影响最大。我们采集了并发启动数量从1次到10次的数据，每次测试10次取中值。</p><p>图5. 容器1~1000次并发启动时延</p><p>图6. 容器并发启动1~10次CPU使用率</p><p>图6为容器并发启动1~10次CPU使用率，可以看到CPU成线性增长，到最后基本达到饱和状态。图7为容器并发启动的详细时延，可以得到启动时延根据并发启动的数量增加而增加。图8为容器并发启动的内存使用情况，可以看到内存几乎稳定在3000 M到4000 M之间，变化不明显。图9为容器并发启动磁盘IO值，可以看到磁盘IO值为0.10%~0.15%之间，可以认为基本不使用磁盘IO。</p><p>综上可得，影响容器并发启动时延的主要因素为CPU使用率，如果要提高并发性能，可以考虑优化CPU使用率。</p><p>图7. 容器并发启动1~10次详细时延</p><p>图8. 容器并发启动1~10次内存使用</p><p>图9. 容器并发启动1~10次磁盘IO</p></sec><sec id="s8_3"><title>4.3. 容器并发启动镜像因素</title><p>为了确定容器并发启动速度是否和镜像大小相关，我们分别并发启动了1000个镜像大小为78.43 M的ubuntu镜像和1000个镜像大小为908 MB的Node镜像。镜像为Docker hub [<xref ref-type="bibr" rid="hanspub.39980-ref27">27</xref>] 官方镜像，并且对它们的启动时延进行对比。</p><p>结果如图10，发现Ubutu镜像和Node镜像启动时延相差不明显，得出结论镜像大小不是影响并发启动的主要因素。</p><p>图10. 不同镜像大小并发启动时延比较</p></sec><sec id="s8_4"><title>4.4. 预先创建容器</title><p>根据docker容器启动步骤，分别为容器创建过程和容器启动过程 [<xref ref-type="bibr" rid="hanspub.39980-ref1">1</xref>]。因此我们确定容器预先创建好之后是否能提高容器并发启动效果。结果如图11。发现预先启动容器镜像再并发启动时延比正常容器并发启动时延提升了10%，效果不是很明显。所以得出结论预先创建容器对容器并发启动效果提升不明显，容器并发启动最主要的性能损耗在容器启动阶段，不是在容器创建阶段。</p><p>图11. 预先创建容器镜像后并发启动效果对比</p></sec></sec><sec id="s9"><title>5. 未来展望</title><p>针对容器并发启动研究，我们可以根据得出的结论来针对这一特定场景进行专门的优化，来提高容器并发启动性能。可以采用CPU分时计算的思想来提高CPU利用率，根据时间序列预测的方法提前创建容器等操作，也可以进一步细化容器并发启动研究，针对容器启动过程的各个阶段来进行实验得出结果，并且容器并发启动应用环境不只有实训平台下的应用场景，有可能在高性能计算等领域也会出现相关场景，可以根据特定场景的特性来进行针对性研究。</p></sec><sec id="s10"><title>基金项目</title><p>国家自然科学基金(61672384, 61772372)。</p></sec><sec id="s11"><title>文章引用</title><p>毕枫林,田春岐,王 伟,唐 骏. 大规模在线实训环境下的快速容器并发启动研究Research on Container Concurrent Initiation under Large-Scale Online Training Environment[J]. 计算机科学与应用, 2021, 11(01): 101-112. https://doi.org/10.12677/CSA.2021.111012</p></sec><sec id="s12"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.39980-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Docker, M.D. (2014) Lightweight Linux Containers for Consistent Development and Deployment. Linux Journal, 2014, Article No. 2.</mixed-citation></ref><ref id="hanspub.39980-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Akkus, I.E., Chen, R., Rimac, I., et al. (2018) SAND: Towards High-Performance Serverless Com-puting. 2018 USENIX Annual Technical Conference, Boston, 11-13 July 2018, 923-935.</mixed-citation></ref><ref id="hanspub.39980-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Xu, Y., Mahendran, V. and Radhakrishnan, S. (2016) SDN Docker: Enabling Application Auto-Docking/Undocking in Edge Switch. 2016 IEEE Conference on Computer Communications Workshops (INFOCOM WKSHPS), San Francisco, 10-14 April 2016, 864-869. &lt;br&gt;https://doi.org/10.1109/INFCOMW.2016.7562199</mixed-citation></ref><ref id="hanspub.39980-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Azab, A. (2017) Enabling Docker Containers for High-Performance and Many-Task Computing. 2017 IEEE International Conference on Cloud Engineering, Vancouver, 4-7 April 2017, 279-285. &lt;br&gt;https://doi.org/10.1109/IC2E.2017.52</mixed-citation></ref><ref id="hanspub.39980-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Kovács, Á. (2017) Comparison of Different Linux Containers. 2017 40th International Conference on Telecommunications and Signal Processing (TSP), Barcelona, 5-7 July 2017, 47-51. &lt;br&gt;https://doi.org/10.1109/TSP.2017.8075934</mixed-citation></ref><ref id="hanspub.39980-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Bernstein, D. (2014) Containers and Cloud: From LXC to Docker to Kubernetes. IEEE Cloud Computing, 1, 81-84.  
&lt;br&gt;https://doi.org/10.1109/MCC.2014.51</mixed-citation></ref><ref id="hanspub.39980-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Paolino, M., Hanmayun, M.M. and Raho, D. (2014) A Performance Analysis of ARM Virtual Machines Secured Using Selinux. Cyber Security and Privacy Forum, Springer, Cham, 28-36.</mixed-citation></ref><ref id="hanspub.39980-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Kratzke, N. (2014) A Lightweight Virtualization Cluster Reference Architecture Derived from Open Source PaaS Platforms. Open Journal of Mobile Computing and Cloud Computing, 1, 17-30.  
&lt;br&gt;https://doi.org/10.4236/jcc.2014.212001</mixed-citation></ref><ref id="hanspub.39980-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Madhavapeddy, A., Mortier, R., Rotsos, C., et al. (2013) Unikernels: Library Operating Systems for the Cloud. ACM SIGARCH Computer Architecture News, 41, 461-472. &lt;br&gt;https://doi.org/10.1145/2490301.2451167</mixed-citation></ref><ref id="hanspub.39980-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Eiras, R.S.V., Couto, R.S. and Rubinstein, M.G. (2016) Perfor-mance Evaluation of a Virtualized HTTP Proxy in KVM and Docker. 2016 7th International Conference on the Network of the Future (NOF), Buzios, 16-18 November 2016, 1-5. &lt;br&gt;https://doi.org/10.1109/NOF.2016.7810144</mixed-citation></ref><ref id="hanspub.39980-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">Joy, A.M. (2015) Performance Comparison between Linux Containers and Virtual Machines. International Conference on Advances in Computer Engineering and Applications, Ghaziabad, 19-20 March 2015, 342-346.  
&lt;br&gt;https://doi.org/10.1109/ICACEA.2015.7164727</mixed-citation></ref><ref id="hanspub.39980-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">Seo, K.-T., Hwang, H.-S., Moon, I.-Y., Kwon, O.-Y. and Kim, B.-J. (2014) Performance Comparison Analysis of Linux Container and Virtual Machine for Building Cloud. Ad-vanced Science and Technology Letters, 66, 105-111.  
&lt;br&gt;https://doi.org/10.14257/astl.2014.66.25</mixed-citation></ref><ref id="hanspub.39980-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">Xavier, B. and Jersak, L. (2016) Time Provisioning Evaluation of KVM, Docker and Unikernels in a Cloud Platform. 2016 16th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing (CCGrid), Cartagena, 16-19 May 2016, 277-280. &lt;br&gt;https://doi.org/10.1109/CCGrid.2016.86</mixed-citation></ref><ref id="hanspub.39980-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">Oakes, E., Yang, L., Zhou, D., Houck, K., Harter, T., Arpaci-Dusseau, A. and Arpaci-Dusseau, R. (2018) SOCK: Rapid Task Provisioning with Serverless-Optimized Con-tainers. USENIX Annual Technical Conference, Boston, 11-13 July 2018, 57-70. &lt;br&gt;https://www.usenix.org/conference/atc18/presentation/oakes</mixed-citation></ref><ref id="hanspub.39980-ref15"><label>15</label><mixed-citation publication-type="other" xlink:type="simple">Harter, T., Salmon, B., Liu, R., Arpaci-Dusseau, A.C. and Arpaci-Dusseau, R.H. (2016) Slacker: Fast Distribution with Lazy Docker Containers. Proceedings of the 14th Usenix Conference on File and Storage Technologies, Santa Clara, 22-25 February 2016. 181-195. &lt;br&gt;https://www.usenix.org/conference/fast16/technical-sessions/presentation/harter</mixed-citation></ref><ref id="hanspub.39980-ref16"><label>16</label><mixed-citation publication-type="other" xlink:type="simple">Rizki, R., Rakhmatsyah, A. and Nugroho, M.A. (2016) Performance Analysis of Container-Based Hadoop Cluster: OpenVZ and LXC. 2016 4th In-ternational Conference on Information and Communication Technology, Bandung, 25-27 May 2016, 1-4. &lt;br&gt;https://doi.org/10.1109/ICoICT.2016.7571957</mixed-citation></ref><ref id="hanspub.39980-ref17"><label>17</label><mixed-citation publication-type="other" xlink:type="simple">Felter, W., Ferreira, A., Rajamony, R. and Rubio, J. (2015) An Updated Performance Comparison of Virtual Machines and Linux Containers. 2015 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS), Philadelphia, 29-31 March 2015, 171-172. &lt;br&gt;https://doi.org/10.1109/ISPASS.2015.7095802</mixed-citation></ref><ref id="hanspub.39980-ref18"><label>18</label><mixed-citation publication-type="other" xlink:type="simple">Xie, B., Sun, G. and Ma, G. (2017) Docker Based Overlay Network Performance Evaluation in Large Scale Streaming System. Proceedings of 2016 IEEE Advanced Information Management, Communicates, Electronic and Automation Control Conference, Xi’an, 3-5 October 2016, 366-369. &lt;br&gt;https://doi.org/10.1109/IMCEC.2016.7867235</mixed-citation></ref><ref id="hanspub.39980-ref19"><label>19</label><mixed-citation publication-type="other" xlink:type="simple">李巍, 赵永彬, 王鸥, 等. 基于Macvlan的Docker容器网络架构研究[J]. 机械设计与制造, 2017(5): 270-272.</mixed-citation></ref><ref id="hanspub.39980-ref20"><label>20</label><mixed-citation publication-type="other" xlink:type="simple">王志伟, 杨超. 基于流量控制的Docker容器网络带宽控制机制[J]. 计算机应用, 2019(12): 3628-3632.</mixed-citation></ref><ref id="hanspub.39980-ref21"><label>21</label><mixed-citation publication-type="other" xlink:type="simple">张礼庆, 郭栋, 吴绍岭, 等. 一种最大化内存共享与最小化运行时环境的超轻量级容器[J]. 计算机研究与发展, 2019, 56(7): 1545-1555.</mixed-citation></ref><ref id="hanspub.39980-ref22"><label>22</label><mixed-citation publication-type="other" xlink:type="simple">张可颖, 彭丽苹, 吕晓丹, 等. 开源云上的Kubernetes弹性调度[J]. 计算机技术与发展, 2019, 29(2): 109-114.</mixed-citation></ref><ref id="hanspub.39980-ref23"><label>23</label><mixed-citation publication-type="other" xlink:type="simple">谢晓兰, 张征征, 王建伟, 等. 基于三次指数平滑法和时间卷积网络的云资源预测模型[J]. 通信学报, 2019, 40(8): 143-150.</mixed-citation></ref><ref id="hanspub.39980-ref24"><label>24</label><mixed-citation publication-type="other" xlink:type="simple">Paraiso, F., Chal-lita, S., Al-Dhuraibi, Y., et al. (2016) Model-Driven Management of Docker Containers. 2016 IEEE 9th International Conference on cloud Computing (CLOUD), San Francisco, 27 June-2 July 2016, 718-725.  
&lt;br&gt;https://doi.org/10.1109/CLOUD.2016.0100</mixed-citation></ref><ref id="hanspub.39980-ref25"><label>25</label><mixed-citation publication-type="other" xlink:type="simple">Smith, S. (2015) On-Demand Activation of Docker Containers with System. 
&lt;br&gt;https://blog.developer.atlassian.com/docker-systemd-socket-activation</mixed-citation></ref><ref id="hanspub.39980-ref26"><label>26</label><mixed-citation publication-type="other" xlink:type="simple">https://docs.docker.com/engine/api/v1.38/#operation/ImageList</mixed-citation></ref><ref id="hanspub.39980-ref27"><label>27</label><mixed-citation publication-type="other" xlink:type="simple">https://hub.docker.com</mixed-citation></ref></ref-list></back></article>