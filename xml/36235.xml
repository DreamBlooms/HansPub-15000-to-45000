<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2020.106130</article-id><article-id pub-id-type="publisher-id">CSA-36235</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20200600000_91860974.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  一种单粒子软错误测试系统的软件设计与实现
  Software Design and Implementation of Single Particle Soft Error Test System
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>赖</surname><given-names>晓玲</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>高</surname><given-names>翔</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>贾</surname><given-names>亮</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>黄</surname><given-names>小平</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>吴</surname><given-names>昊</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>郭</surname><given-names>阳明</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff3"><addr-line>西北工业大学计算机学院，陕西 西安</addr-line></aff><aff id="aff2"><addr-line>中国空间技术研究院西安分院，陕西 西安</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>04</day><month>06</month><year>2020</year></pub-date><volume>10</volume><issue>06</issue><fpage>1259</fpage><lpage>1266</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   空间飞行器数字系统主要由FPGA、CPU等数字器件构成，由于其工作在含有大量辐射粒子的宇宙环境下，单粒子翻转等软错误对飞行器的安全性、可靠性造成了很大威胁，造成导航、测控以及通讯等功能的失效。特别是随着COTS器件越来越多地应用到数字系统中，亟需建立全面并准确检测出整个飞行器软错误的方法。论文结合Xilinx公司的XC5VFX130T SRAM型FPGA和TI公司的TMS570LS3137型号CPU器件构建的测试系统，设计了监控FPGA和上位机之间的通讯协议，开展了上位机软件设计与实现。 The digital system of space vehicle is mainly composed of FPGA, CPU and other digital devices. Because it works in the space environment with a large number of radiation particles, single particle flip and other soft errors pose a great threat to the safety and reliability of the vehicle, resulting in the failure of navigation, measurement and control, communication and other functions. Especially with the increasing application of COTS devices in digital systems, it is urgent to establish a comprehensive and accurate method to detect the whole aircraft soft errors. This paper takes XC5VFX130T SRAM FPGA of Xilinx Company and TMS570LS3137 CPU of TI Company and their digital system as objects, designs the communication protocol between the monitoring FPGA and the upper computer based on the test system, and then the host computer software is implemented. 
  
 
</p></abstract><kwd-group><kwd>FPGA，CPU，单粒子效应，单粒子软错误，测试系统, FPGA</kwd><kwd> CPU</kwd><kwd> Single Event Effect</kwd><kwd> Single Particle Soft Error</kwd><kwd> Test System</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>一种单粒子软错误测试系统的软件设计与实现<sup> </sup></title><p>赖晓玲<sup>1</sup>，高翔<sup>1</sup>，贾亮<sup>1</sup>，黄小平<sup>2</sup>，吴昊<sup>2</sup>，郭阳明<sup>2</sup></p><p><sup>1</sup>中国空间技术研究院西安分院，陕西 西安</p><p><sup>2</sup>西北工业大学计算机学院，陕西 西安</p><p>收稿日期：2020年6月3日；录用日期：2020年6月16日；发布日期：2020年6月24日</p><disp-formula id="hanspub.36235-formula12"><graphic xlink:href="//html.hanspub.org/file/19-1541804x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>空间飞行器数字系统主要由FPGA、CPU等数字器件构成，由于其工作在含有大量辐射粒子的宇宙环境下，单粒子翻转等软错误对飞行器的安全性、可靠性造成了很大威胁，造成导航、测控以及通讯等功能的失效。特别是随着COTS器件越来越多地应用到数字系统中，亟需建立全面并准确检测出整个飞行器软错误的方法。论文结合Xilinx公司的XC5VFX130T SRAM型FPGA和TI公司的TMS570LS3137型号CPU器件构建的测试系统，设计了监控FPGA和上位机之间的通讯协议，开展了上位机软件设计与实现。</p><p>关键词 :FPGA，CPU，单粒子效应，单粒子软错误，测试系统</p><disp-formula id="hanspub.36235-formula13"><graphic xlink:href="//html.hanspub.org/file/19-1541804x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2020 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY 4.0).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/19-1541804x7_hanspub.png" /> <img src="//html.hanspub.org/file/19-1541804x8_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>空间飞行器的导航、姿态控制以及空地通信等功能都是由数字系统来实现的 [<xref ref-type="bibr" rid="hanspub.36235-ref1">1</xref>]。空间环境中的辐射粒子很容易在数字系统中引起辐射效应，使得空间飞行器的安全受到严重威胁 [<xref ref-type="bibr" rid="hanspub.36235-ref2">2</xref>]。为了保证飞行器的长寿命和高可靠性，研究人员针对FPGA、CPU等器件提出了众多软错误检测方法，以便评估出这些器件的单粒子翻转敏感特性，为空间飞行器数字系统的设计选型和防护设计评价提供依据和支撑，对寻找预防和减缓空间粒子效应具有重要的价值。</p><p>论文围绕TI公司的TMS570LS3137 CPU和Xilinx公司的Virtex5 XC5VFX130T等两类新型COTS器件电离辐射摸底试验，在分析已有单粒子软错误检测方法的基础上构建了测试系统，设计了监控FPGA和上位机之间的通讯协议，开展了上位机软件的设计与实现。</p></sec><sec id="s4"><title>2. 测试系统描述</title><p>辐照环境下的软错误测试系统用以控制试验过程，并且能够采集、传输、处理、保存试验数据 [<xref ref-type="bibr" rid="hanspub.36235-ref3">3</xref>]。一般将被测FPGA等芯片放在真空中，以避免加速器中射出的高能粒子到达芯片表面过程中能量衰减过多，导致了对外界环境和被测芯片之间的连线类型和数量的要求很苛刻。此外，为防止加速器对试验人员产生辐射伤害，实际操作中试验人员一般通过计算机对测试系统进行远程操作，即被测芯片距离试验控制室较远。</p><p>为此，软错误测试系统分为监控FPGA、被测FPGA、CPU和上位机等部分。测试系统的总体结构如图1所示。图1中，上位机试验时一般处于真空室外，在辐照过程中由控制室的计算机远程控制，监控FPGA通过用户数据报协议(UDP)与PC进行数据传输，以达到测试环境要求的高速可靠的数据交互和板间最少连线的双重目的。</p><p>上位机作为测试系统控制中心与数据存储与分析平台，设置测试条件与参数；向下位机发送测试模式切换、测试过程控制等指令；静态测试模式下，回读被测FPGA的配置数据并与参照文件比较；实时统计FPGA动态测试以及CPU测试的翻转数量；保存每一次测试的数据和结果，用于后续数据分析。</p><p>监控FPGA通过网口与上位机直接相连，其主要功能有接收上位机下发的测试控制指令并执行相应操作；CPU测试模式下给被测FPGA提供时钟；将测试结果通过网口上传给上位机。</p><p>监控FPGA主要由以下模块组成：</p><p>图1. 软错误测试系统总体结构</p><p>1) 网口驱动模块，上位计算机与测试板的通讯接口。上位计算机通过网口向测试板发送各种控制命令；测试板通过网口向上位计算机传回测试状态与测试数据。采用UDP通讯协议实现。</p><p>2) 静态测试模块，采用“一次回读”的方式，即辐照一段时间后再对被测FPGA通过SelectMAP口回读，并区分出配置存储器和BRAM的配置信息。</p><p>3) 动态测试模块，为BRAM和触发器动态测试提供输入时钟，并接收测试输出。与静态测试“先辐照后统计”不同的是，在被测FPGA被辐照的同时，该模块统计翻转位数，即“边辐照边统计”。</p><p>FPGA软错误检测方法以测试电路的形式在被测FPGA中实现。FPGA测试模式下，被测FPGA的功能主要有静态测试模式下，通过Select MAP口将配置数据发给监控FPGA；动态测试模式下，通过信号线将测试电路的输出结果上传给监控FPGA。而在CPU测试模式下，被测FPGA的功能是接收来自CPU的测试数据并将其转发给监控FPGA [<xref ref-type="bibr" rid="hanspub.36235-ref4">4</xref>] [<xref ref-type="bibr" rid="hanspub.36235-ref5">5</xref>]。</p><p>CPU软错误检测方法以测试程序的形式在被测CPU中实现。CPU的功能主要有实现寄存器、SRAM、Flash等资源的测试程序；通过串口与上位机直接相连，在CPU测试过程中向上位机传输测试相关的信息。</p><p>软错误测试系统在实际辐照试验中运行时，涉及到上位机软件与监控FPGA(下位机)之间的指令发送与接收、数据收发等通讯操作。考虑到测试过程中有大量的测试数据上传，使用端口号分别为5000、5001 何5002的三个端口，设计测试系统的上位机与监控FPGA之间基于UDP的通讯协议。</p><p>1) 5000端口主要用于上位机下发测试控制指令给监控FPGA。网口下发的4字节长度的指令结构如表1所示。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Command structure of network port</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >有效标志</th><th align="center" valign="middle"  colspan="2"  >指令数据</th></tr></thead><tr><td align="center" valign="middle" >EB</td><td align="center" valign="middle" >90</td><td align="center" valign="middle" >XX</td><td align="center" valign="middle" >XX</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr></tbody></table></table-wrap><p>表1. 网口下发指令结构</p><p>“EB 90”为指令的有效标志，其后面是两个字节的指令数据。具体指令及其含义如表2所示。其中前2条指令用于在FPGA测试模式与CPU测试模式之间切换，第3~12条指令用于FPGA测试模式，其余用于CPU测试模式。</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Instruction issued by 5000 port and its meanin</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >序号</th><th align="center" valign="middle" >指令</th><th align="center" valign="middle" >含义</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >EB 90 55 55</td><td align="center" valign="middle" >切换到FPGA测试模式</td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >EB 90 55 AA</td><td align="center" valign="middle" >切换到CPU测试模式</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >EB 90 00 AA</td><td align="center" valign="middle" >确认静态测试</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" >EB 90 00 BB</td><td align="center" valign="middle" >确认BRAM测试</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" >EB 90 00 CC</td><td align="center" valign="middle" >确认触发器测试</td></tr><tr><td align="center" valign="middle" >6</td><td align="center" valign="middle" >EB 90 DD AA</td><td align="center" valign="middle" >开始静态测试</td></tr><tr><td align="center" valign="middle" >7</td><td align="center" valign="middle" >EB 90 DD BB</td><td align="center" valign="middle" >开始BRAM测试</td></tr><tr><td align="center" valign="middle" >8</td><td align="center" valign="middle" >EB 90 DD CC</td><td align="center" valign="middle" >开始触发器测试</td></tr><tr><td align="center" valign="middle" >9</td><td align="center" valign="middle" >EB 90 00 33</td><td align="center" valign="middle" >暂停静态测试</td></tr><tr><td align="center" valign="middle" >10</td><td align="center" valign="middle" >EB 90 EE BB</td><td align="center" valign="middle" >暂停BRAM测试</td></tr><tr><td align="center" valign="middle" >11</td><td align="center" valign="middle" >EB 90 EE CC</td><td align="center" valign="middle" >暂停触发器测试</td></tr><tr><td align="center" valign="middle" >12</td><td align="center" valign="middle" >EB 90 FF EE</td><td align="center" valign="middle" >结束FPGA任一测试模式</td></tr><tr><td align="center" valign="middle" >13</td><td align="center" valign="middle" >EB 90 32 32</td><td align="center" valign="middle" >开始寄存器测试(全1)</td></tr><tr><td align="center" valign="middle" >14</td><td align="center" valign="middle" >EB 90 33 33</td><td align="center" valign="middle" >开始寄存器测试(全0)</td></tr><tr><td align="center" valign="middle" >15</td><td align="center" valign="middle" >EB 90 30 30</td><td align="center" valign="middle" >开始SRAM测试(全1)</td></tr><tr><td align="center" valign="middle" >16</td><td align="center" valign="middle" >EB 90 31 31</td><td align="center" valign="middle" >开始SRAM测试(全0)</td></tr><tr><td align="center" valign="middle" >17</td><td align="center" valign="middle" >EB 90 36 36</td><td align="center" valign="middle" >开始Flash测试(全1)</td></tr><tr><td align="center" valign="middle" >18</td><td align="center" valign="middle" >EB 90 37 37</td><td align="center" valign="middle" >开始Flash测试(全0)</td></tr><tr><td align="center" valign="middle" >19</td><td align="center" valign="middle" >EB 90 38 38</td><td align="center" valign="middle" >开始定时器及全功能测试</td></tr><tr><td align="center" valign="middle" >20</td><td align="center" valign="middle" >EB 90 34 34</td><td align="center" valign="middle" >结束CPU任一测试模式</td></tr><tr><td align="center" valign="middle" >21</td><td align="center" valign="middle" >EB 90 02 02</td><td align="center" valign="middle" >复位CPU</td></tr></tbody></table></table-wrap><p>表2. 5000端口下发指令及其含义</p><p>2) 5001端口用于监控FPGA向上位机发送测试指令的响应帧或者测试数据。响应帧和测试数据的长度都是15个字节，具体结构如表3所示。其中，每一帧最后的填充字节不被上位机解析。</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> 5001 port frame format and its meanin</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >序号</th><th align="center" valign="middle" >响应帧或数据帧</th><th align="center" valign="middle" >含义</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >EB 90 55 00 XX XX XX XX XX XX XX XX XX XX XX</td><td align="center" valign="middle" >指令执行成功，XX为填充字节</td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >EB 90 55 11 XX XX XX XX XX XX XX XX XX XX XX</td><td align="center" valign="middle" >指令执行失败，XX为填充字节</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >EB 90 AA C3 XX XX XX XX XX XX XX XX XX XX X</td><td align="center" valign="middle" >监控FPGA通知上位机，即将有动态测试数据上传， XX为填充字节</td></tr><tr><td align="center" valign="middle" >4</td><td align="center" valign="middle" >EB C3 WW WW WW WW WW WW WW WW XX XX</td><td align="center" valign="middle" >FPGA动态测试数据，WW为当前SEU累计值，XX为填充字节</td></tr><tr><td align="center" valign="middle" >5</td><td align="center" valign="middle" >EB C3 DQ YY YY YY ZZ ZZ SS XX XX XX XX XX XX</td><td align="center" valign="middle" >CPU测试数据，Q为测试模式序号，YY为SEU地址，ZZ为 对应地址的内容，SS为前6个字节的校验和，XX为填充字节</td></tr></tbody></table></table-wrap><p>表3. 5001端口帧格式及其含义</p><p>3) 5002端口用于FPGA静态测试中，监控FPGA上传回读数据。由于回读的配置数据约为49 Mb，使用网口进行数据打包上传，一包数据为1028个字节(1024个字节为数据)，一次回读总计需要上传6010包。上传的数据格式如表4所示。</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> Return data structur</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >包头标志</th><th align="center" valign="middle"  colspan="3"  >有效数据</th><th align="center" valign="middle"  colspan="2"  >包序号</th></tr></thead><tr><td align="center" valign="middle" >EB</td><td align="center" valign="middle" >91</td><td align="center" valign="middle" >WW</td><td align="center" valign="middle" >…</td><td align="center" valign="middle" >WW</td><td align="center" valign="middle" >XX</td><td align="center" valign="middle" >XX</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr></tbody></table></table-wrap><p>表4. 回传数据结构</p><p>由于XC5VFX130T的回读配置数据为1,538,320字(49,226,240 bits)，每包数据为1024个字节(8192 bits)，无法整除。因此，最后一包数据只有64个字节有效数据，其余960个字节需要补为全FF的填充字节，这部分不参与回读比对。</p></sec><sec id="s5"><title>3. CPU软件设计</title><p>CPU测试模式下，寄存器测试程序是用汇编语言实现的，而SRAM和Flash的测试程序是以C语言实现的。下面介绍CPU的主体程序设计，主体程序不仅包括上述测试程序，还有对整个系统的初始化工作。图2表示的是CPU主体程序。</p><p>CPU首先上电启动，然后系统完成对串口、锁相环(Phase Locked Loop, PLL)、外部存储器接口(External Memory Interface, EMIF)等资源的初始化工作。其中，PLL和CPU的时钟配置有关，而EMIF用于CPU和监控FPGA之间交换数据。当监控FPGA收到上位机发来数据的同时，将该数据转发给CPU，CPU判断收到的是不是一条测试指令。如果不是，则忽略并继续等待接收测试指令；如果是测试指令，则主体程序流程继续。如果该指令的目的是让CPU开始测试，这里假定该指令为“开始SRAM测试(全1)”(EB 90 30 30)或者“开始SRAM测试(全0)”(EB 90 31 31)，那么下面CPU主控程序进入SRAM测试子程序。CPU先后完成对SRAM和DMA的初始化，SRAM的初始化工作就是写入初值(全0或者全1)，而DMA的初始化是为测试过程中接收大量测试数据做准备。辐照开启后，DMA周期性地、按地址由低到高的顺序扫描SRAM，如果有软错误发生，CPU将测试数据通过EMIF接口发给监控FPGA，监控FGPA随即又通过网口将其上传至上位机处理。</p><p>上述SRMA测试程序以及其他资源的测试程序本质都是一个循环，待DMA扫描到被测资源的最高地址后，又重新从最低地址继续扫描。因此CPU在一次扫描结束后，会判断上位机是否下发了测试结束指令(EB 90 34 34)。如果是，则退出测试子程序，进入CPU主体程序，继续等待接收新的测试指令；否则，继续开始当前被测资源的下一次扫描。</p><p>图2. CPU软件的流程图</p></sec><sec id="s6"><title>4. 上位机软件设计与实现</title><sec id="s6_1"><title>4.1. 上位机软件需求分析</title><p>测试系统上位机完成“测试过程控制”、“测试信息实时统计”和“测试结果保存”三大功能，各功能具体说明如下：</p><p>1) 测试过程控制</p><p>首先上位机应该可以在FPGA测试模式和CPU测试模式之间来回切换。若成功进入FPGA测试模式，上位机先选择具体的测试模式(如静态测试、BRMA测试、Flip-flop测试等)，并确认该模式。接下来可以对下位机发出“测试开始”、“测试暂停”、“测试结束”等命令。对于FPGA测试模式来说，需要特别指出的是，若要选择“静态测试”模式，在确认该测试模式前，需要指定回读文件存储目录。</p><p>若成功进入CPU测试模式，上位机同样先选择具体的测试模式(如寄存器测试、SRAM测试、Flash测试、计数器测试、全功能测试等)，然后选择并打开正确的串口以连接CPU，并指定测试结果存储目录。与FPGA测试模式不同的是，CPU测试模式下，主要有“测试开始”、“测试结束”和“CPU复位”这三种命令。其中需要特别说明的是，试验人员可以实时看到CPU通过串口打印到上位机上的测试信息，若发现CPU因为受到SEFI影响或其他原因跑飞了，可以点击“CPU复位”按钮，以恢复CPU程序的正常执行。</p><p>2) 测试信息实时统计</p><p>上位机可以实时统计每次辐照测试过程中的软错误数量并记录实验时长，而且可以累加统计当前测试模式下多次测试的软错误数量。对于FPGA的静态测试来说，上位机的界面上可以实时显示回读进度。</p><p>3) 测试结果保存</p><p>上位机可以保存与每一次测试有关的信息，包括剂量率、总注量、LET值、离子种类、硅中射程、软错误数量、实验时长、实验开始时间以及结束时间等。另外，CPU各测试模式下，上位机可以在后台自动保存CPU实时上传的软错误信息，例如寄存器测试中，若当前扫描到的寄存器发生了软错误，那么上位机会保存CPU上传的该寄存器的地址和值。</p></sec><sec id="s6_2"><title>4.2. 上位机软件架构设计</title><p>上位机软件基于Qt 5.7.0框架实现，主要使用QUdpSocket和QtSerialPort等Qt封装好的类。在FPGA静态测试和CPU测试过程中，涉及到网口大量数据上传以及频繁的文件读写操作，为了避免上位机的主界面假死而影响用户体验，以及更严重的UDP丢包问题，上位机采用多线程的方式，将所有界面操作都放进主线程(界面线程)，而UDP数据接收和文件读写被放进了另外两个子线程(工作线程)。界面线程和工作线程之间的变量传递利用了Qt的信号–槽(Signal-Slot)机制。</p><p>上位机软件主要由“参数设置”模块、“测试控制”模块、“测试结果”模块和“数据处理”模块组成。</p><p>1) “参数设置”模块的功能是在本次测试开始前，输入当前辐照设备的各种参数条件，包括剂量率、总注量、LET值、离子种类和硅中射程，方便测试数据记录及脱机数据分析。</p><p>2) “测试控制”模块是整个上位机软件的核心模块。由于FPGA和CPU的测试原理不同，该模块在两种测试模式下也有所不同。</p><p>对于FPGA测试来说，若选择的是“静态测试”，那么在确认模式前，需要先指定回读文件存储的目录。根据配置存储器测试流程，静态测试模式确认成功后，开始测试，辐照一段时间后，暂停测试的同时，对FPGA进行回读，回读结束后立即与参照配置文件进行异或比较，获得软错误数量。测试暂停后，可以选择继续下一次测试或者结束当前测试模式。</p><p>上位机软件在接收5002端口数据的工作线程中，声明了一个作用类似于缓冲区的QQueue队列，将每一包数据先与参照配置文件中对应配置帧进行比较并统计软错误，然后这一包数据入列。待回读结束时，再循环出列将数据写入到文件中，直到队列为空为止。由于队列是“先入先出”，所以最后生成的回读文件中的配置信息也是按照包序号从小到大的顺序排列的。该设计思想也在一定程度上避免了丢包的问题；若选择的是“BRAM测试”或者“Flip-flop测试”，同样需要先确认模式，然后开始测试，在测试过程中，若有软错误发生，下位机会给上位机上传当前软错误数量的累计值。和“静态测试”模式一样，暂停测试后，既可以继续开始下一次测试，也可以结束当前模式的测试。</p><p>对于CPU测试来说，只需要在下拉列表中选择想要的测试模式。辐照试验开始前，需确保PC已经通过串口与CPU正确连接，并且指定测试结果的存储目录，如果这串口未打开或者目录未指定，上位机会弹出警告以提示用户。测试一旦开始，上位机会弹出新的窗口，该窗口仅绘制了一张表格用于模拟寄存器、SRAM或Flash，行表示地址，列表示具体的某一位。</p><p>由于SRAM和Flash的地址很大，弹窗不显示所有地址，当有软错误发生时，才会将该错误的地址及其对应的内容在表格中更新，这不仅避免了因为表格初始化耗时长且不方便实时观测而导致对用户体验的影响，而且增强了软件本身的健壮性，防止软件崩溃。如果被测资源发生了软错误，CPU会上传错误所在的地址以及被测资源中该地址内容的值，上位机软件在统计软错误数量的同时，会在弹窗中对应的行和列同步显示错误。</p><p>针对测试过程中，CPU被测资源被循环扫描可能引起错误重复统计的问题。软件设计中声明一个QMap容器，该容器的键是地址，值是该地址对应的内容，该容器初始为空。当CPU扫描到某一地址时，若发现QMap容器中没有值为该地址的键，那么插入“地址–初始值”的键值对，接着将CPU上传的改地址对应的值value1与该地址在QMap容器中对应的值value2比较，若两者一样，则上位机丢弃该数据，否则在后台自动保存该数据，并在主界面更新软错误数量的同时，在弹窗中标注软错误发生的位置，最后将该地址在QMap容器中对应的值更新为value1，这样就避免了对软错误的重复统计。与FPGA测试不同的是，CPU测试中没有“暂停测试”的功能，上位机软件可以直接结束测试，可以选择继续开始下一次测试，也可以选择切换其他的测试模式，但是在切换模式之前必须保存当前模式下的测试数据，否则会弹出警告提示保存。在辐照试验中，CPU常常会因为SEFI或者其他原因而跑飞，因次在CPU测试模式下，上位机软件增加了“CPU复位”的功能。</p><p>3) “测试结果”模块中，“总SEU”表示当前测试模式下多次测试的软错误累计值；“当前SEU”代表本次测试实时统计的软错误数量；“实验时长”是从测试开始时计时，直到测试暂停或者结束时停止计时；“实验开始时间”为测试开始的时间戳，而“实验结束时间”为测试暂停或者结束的时间戳。</p><p>4) “数据处理”模块的作用是在表格中记录当前测试模式下每一次“开始–暂停”或者“开始–结束”的测试信息，包括剂量率等测试条件、“测试结果”模块中的信息以及测试过程产生的中间文件名，若测试模式切换，表格的内容清空。对于FPGA测试来说，需要先指定一个目录，然后才能保存这些测试记录；而对于CPU测试，直接保存即可。</p><p>除了上述4个主要模块，上位机软件还设计了一个状态栏，用于显示测试过程各种信息提示，起到类似日志的作用。</p></sec></sec><sec id="s7"><title>5. 小结</title><p>论文从测试需求出发，对单粒子软错误测试系统进行功能定义以及模块划分，设计了整个系统的通讯协议。在对上位机软件需求分析的基础上，提出了软件架构设计和实现。应用表明，所设计的上位机软件，可以完成向测试系统下位机下发测试指令、实时监测被测器件翻转情况以及保存辐照试验数据等主要功能，大大降低了辐照试验的操作难度，具有很好的实用性，可以满足应用需求。</p></sec><sec id="s8"><title>基金项目</title><p>国家某重点科研项目(MJ-2016-S-42, MJ-2018-S-34)，国防基础科研计划项目，国网浙江省电力有限公司科技项目(2020年)，陕西省创新能力支撑计划项目(2019PT-03)。</p></sec><sec id="s9"><title>文章引用</title><p>赖晓玲,高 翔,贾 亮,黄小平,吴 昊,郭阳明. 一种单粒子软错误测试系统的软件设计与实现Software Design and Implementation of Single Particle Soft Error Test System[J]. 计算机科学与应用, 2020, 10(06): 1259-1266. https://doi.org/10.12677/CSA.2020.106130</p></sec><sec id="s10"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.36235-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">李杨. 国外航天器电子系统的几个重要发展趋势[J]. 航天器工程, 2014, 23(6): 1-6.</mixed-citation></ref><ref id="hanspub.36235-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">邢克飞. 星载信号处理平台单粒子效应检测与加固技术研究[D]: [博士学位论文]. 长沙: 国防科学技术大学, 2007.</mixed-citation></ref><ref id="hanspub.36235-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">孙鹏. 抗单粒子翻转SRAM-based FPGA测试系统研究与设计[D]: [硕士学位论文]. 上海: 复旦大学, 2010.</mixed-citation></ref><ref id="hanspub.36235-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">谢楠. 宇航用FPGA单粒子效应及监测方法研究[D]: [硕士学位论文]. 西安: 西安电子科技大学, 2011.</mixed-citation></ref><ref id="hanspub.36235-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">宋凝芳, 朱明达, 潘雄. SRAM型FPGA单粒子效应试验研究[J]. 宇航学报, 2012, 33(6): 836-842.</mixed-citation></ref></ref-list></back></article>