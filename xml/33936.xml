<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">HJDM</journal-id><journal-title-group><journal-title>Hans Journal of Data Mining</journal-title></journal-title-group><issn pub-type="epub">2163-145X</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/HJDM.2020.101008</article-id><article-id pub-id-type="publisher-id">HJDM-33936</article-id><article-categories><subj-group subj-group-type="heading"><subject>HJDM20200100000_98050032.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  Web数据转换模式映射优化方法
  Web Data Exchange Schema Mapping Optimization Method
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>纪</surname><given-names>宇航</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>李</surname><given-names>贵</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>李</surname><given-names>征宇</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>韩</surname><given-names>子扬</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>曹</surname><given-names>科研</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff2"><addr-line>沈阳建筑大学信息与控制工程学院，辽宁 沈阳</addr-line></aff><aff id="aff1"><addr-line>null</addr-line></aff><pub-date pub-type="epub"><day>11</day><month>12</month><year>2019</year></pub-date><volume>10</volume><issue>01</issue><fpage>76</fpage><lpage>89</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
  Web数据转换是Web异构数据源集成的重要研究之一，通常分为实例层和模式层两方面进行。本文的研究主要针对模式层，由于给定的源到目标模式映射通常使数据转换结果包含大量冗余，为了生成不含冗余的数据作为数据转换核解，本文设计了一种基于同态关系的模式映射设计与优化方法。该方法首先引入模式映射之间的同态关系作为模式映射重写方法基础，通过对模式映射进行分解，定义不同规则生成的数据冗余的大小程度，确定需要重写的规则。最后将给定的模式映射重写为能够直接生成核解的核模式映射，并将其转换为可执行的SQL语句来计算核解。本文实验使用来自中国土地市场网的数据验证本文方法的有效性。
   Web data exchange is one of the important researches on the integration of Web heterogeneous data sources. It is usually divided into two aspects: instance layer and schema layer. The research in this paper is mainly focused on the mode layer. Because a given source-to-target mode mapping usually makes the data exchange results contain a lot of redundancy, in order to generate data without redundancy as a data exchange kernel solution, this paper designs a homomorphic rela-tionship Schema mapping design and optimization methods. This method first introduces the ho-momorphic relationship between the schema mappings as the basis of the schema mapping re-writing method. By decomposing the schema mappings, defining the degree of data redundancy generated by different rules, and determining the rules that need to be rewritten. Finally, the given schema mapping is rewritten into a kernel schema mapping that can directly generate a kernel so-lution, and it is converted into an executable SQL statement to calculate the kernel solution. This paper uses data from China Land Market Network to test the performance of the proposed method.
 
</p></abstract><kwd-group><kwd>Web大数据，数据转换，模式映射，核解，同态关系, Web Big Data</kwd><kwd> Data Exchange</kwd><kwd> Schema Mapping</kwd><kwd> Core Solution</kwd><kwd> Homomorphism</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>Web数据转换模式映射优化方法<sup> </sup></title><p>纪宇航，李贵，李征宇，韩子扬，曹科研</p><p>沈阳建筑大学信息与控制工程学院，辽宁 沈阳</p><p>收稿日期：2019年12月25日；录用日期：2020年1月7日；发布日期：2020年1月14日</p><disp-formula id="hanspub.33936-formula50"><graphic xlink:href="//html.hanspub.org/file/8-1760193x5_hanspub.png"  xlink:type="simple"/></disp-formula></sec><sec id="s2"><title>摘 要</title><p>Web数据转换是Web异构数据源集成的重要研究之一，通常分为实例层和模式层两方面进行。本文的研究主要针对模式层，由于给定的源到目标模式映射通常使数据转换结果包含大量冗余，为了生成不含冗余的数据作为数据转换核解，本文设计了一种基于同态关系的模式映射设计与优化方法。该方法首先引入模式映射之间的同态关系作为模式映射重写方法基础，通过对模式映射进行分解，定义不同规则生成的数据冗余的大小程度，确定需要重写的规则。最后将给定的模式映射重写为能够直接生成核解的核模式映射，并将其转换为可执行的SQL语句来计算核解。本文实验使用来自中国土地市场网的数据验证本文方法的有效性。</p><p>关键词 :Web大数据，数据转换，模式映射，核解，同态关系</p><disp-formula id="hanspub.33936-formula51"><graphic xlink:href="//html.hanspub.org/file/8-1760193x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2020 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/8-1760193x7_hanspub.png" /> <img src="//html.hanspub.org/file/8-1760193x8_hanspub.png" /></p></sec><sec id="s3"><title>1. 引言</title><p>最初的数据转换问题(data exchange problem) [<xref ref-type="bibr" rid="hanspub.33936-ref1">1</xref>] 是由Fagin等人提出的，他们给出了数据转换的相关定义。文献 [<xref ref-type="bibr" rid="hanspub.33936-ref2">2</xref>] 中说明了数据转换通常将源数据作为输入，由一组模式映射的集合(也叫元组生成依赖关系)对源数据进行选择，将其转换为满足给定的模式映射的目标数据集，在此基础上还给出了数据转换过程中通解、核解的概念以及基本求解方法，并将一些相关领域知识转换为约束条件融入到数据转换求解算法中(核解是保留映射语义的解决方案中最小的解决方案，简称核解)。由于在相关研究中核解已被确定为数据转换的最优解决方案，因此在数据集成过程中如何有效快速计算核解非常重要。现有的计算数据转换核解的方法，通常是通过chase方法执行原始的源到目标映射规则生成目标实例，然后应用一些实例选择方法对属于核解的目标实例进行选择。</p><p>基于上述研究，已有许多方法对计算核解进行了研究，文献 [<xref ref-type="bibr" rid="hanspub.33936-ref3">3</xref>] 从模式映射的角度出发，通过对映射规则进行优化设计，将映射规则转换为可以执行的脚本来计算核解。文献 [<xref ref-type="bibr" rid="hanspub.33936-ref4">4</xref>] 在给定元数据约束和数据示例的情况下，给出了一种从潜在映射空间中选择最佳映射的方法。但是这些方法通常不适用于数据源规模较大的大型映射场景，可能导致目标数据库中的数据存在大量冗余数据。文献 [<xref ref-type="bibr" rid="hanspub.33936-ref5">5</xref>] 通过弱化目标数据中的约束条件来计算核解，由于该方法只能在特定条件下对有限的数据进行处理，存在一定局限性。关于模式匹配的研究中，大多数研究是关于语义相似性度量方法，文献 [<xref ref-type="bibr" rid="hanspub.33936-ref6">6</xref>] 使用WordNet信息引入了一种新的语义相似性度量方法，来处理模式匹配问题。文献 [<xref ref-type="bibr" rid="hanspub.33936-ref7">7</xref>] 同样在语义相似性度量方法的基础上提出了一种在半结构化数据和链接数据之间进行模式匹配的方法。关于数据转换的研究中，文献 [<xref ref-type="bibr" rid="hanspub.33936-ref8">8</xref>] 提出了一种可伸缩实体保存数据转换(SEDEX)方法，该方法利用在模式级别和数据实例级别的信息解决使用不同方法表示模式间对应关系导致模式映射不准确的问题。为了设计准确的模式映射信息，一些方法 [<xref ref-type="bibr" rid="hanspub.33936-ref9">9</xref>] [<xref ref-type="bibr" rid="hanspub.33936-ref10">10</xref>] 以交互方式从映射设计器那里获取数据示例，用以设计源模式与目标模式之间的模式映射，并通过将范围较小的多个独立设计的方案映射关联到较大的方案映射构造复杂映射。国内关于数据转换的研究大都集中于ETL技术的研究 [<xref ref-type="bibr" rid="hanspub.33936-ref11">11</xref>] [<xref ref-type="bibr" rid="hanspub.33936-ref12">12</xref>] [<xref ref-type="bibr" rid="hanspub.33936-ref13">13</xref>]，ETL技术通常用来描述将数据从来源端经过抽取、转换、加载至目标端的过程。研究过程中的主要问题是解决数据异构性及转换效率提升问题。</p><p>传统的模式映射设计中，通常都是通过消除数据值冗余来避免更新的低效性。研究表明，许多冗余的出现都是由于映射规则不完善导致的，因此直接通过重写规则防止在目标中生成冗余数据要比执行不完善的映射规则生成冗余数据后再尝试去删除这些冗余数据更有效。考虑如表1，表2所示场景，表1中的源表A，B，C，D分别代表来自不同web源的源数据库表，表2中的目标表T1，T2是两个不同的目标数据库表。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Source database summary dat</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >源表A 房小二网</th><th align="center" valign="middle"  colspan="2"  >源表B 沈阳房天下网</th><th align="center" valign="middle"  colspan="2"  >源表C 房谱网</th><th align="center" valign="middle" >源表D 沈阳楼盘网</th></tr></thead><tr><td align="center" valign="middle" >P NAME 项目名称</td><td align="center" valign="middle" >P Adr 项目地址</td><td align="center" valign="middle" >P NAME 项目名称</td><td align="center" valign="middle" >P ID 地块编号</td><td align="center" valign="middle" >P ID 地块编号</td><td align="center" valign="middle" >P Adr 项目地址</td><td align="center" valign="middle" >P NAME 项目名称</td></tr><tr><td align="center" valign="middle" >城南春晓</td><td align="center" valign="middle" >浑南新区塔南街501号</td><td align="center" valign="middle" >金石小镇</td><td align="center" valign="middle" >HN-17014</td><td align="center" valign="middle" >HN-17014</td><td align="center" valign="middle" >浑南区全运五路与沈营大街交汇处</td><td align="center" valign="middle" >金石小镇</td></tr><tr><td align="center" valign="middle" >小石城梦想小镇</td><td align="center" valign="middle" >浑南区沈营路与全运北路交汇处西行500米</td><td align="center" valign="middle" >小石城梦想小镇</td><td align="center" valign="middle" >HN0609</td><td align="center" valign="middle" >HN0609</td><td align="center" valign="middle" >浑南区沈营路与全运北路交汇处西行500米</td><td align="center" valign="middle" >首创光和城</td></tr><tr><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td><td align="center" valign="middle" >城南春晓</td></tr></tbody></table></table-wrap><p>表1. 源数据库概要数据</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Target database summary dat</title></caption><table><tbody><thead><tr><th align="center" valign="middle"  colspan="2"  >目标表T1 (楼盘信息表)</th><th align="center" valign="middle"  colspan="2"  >目标表T2 (地址信息表)</th></tr></thead><tr><td align="center" valign="middle" >P NAME 项目名称</td><td align="center" valign="middle" >P ID地块编号</td><td align="center" valign="middle" >P Adr项目地址</td><td align="center" valign="middle" >P ID地块编号</td></tr><tr><td align="center" valign="middle" >金石小镇</td><td align="center" valign="middle" >N1</td><td align="center" valign="middle" >浑南区全运五路与沈营大街交汇处</td><td align="center" valign="middle" >HN-17014</td></tr><tr><td align="center" valign="middle" >首创光和城</td><td align="center" valign="middle" >N2</td><td align="center" valign="middle" >浑南区沈营路与全运北路交汇处西行500米</td><td align="center" valign="middle" >HN0609</td></tr><tr><td align="center" valign="middle" >城南春晓</td><td align="center" valign="middle" >N3</td><td align="center" valign="middle" >浑南区沈营路与全运北路交汇处西行500米</td><td align="center" valign="middle" >L1</td></tr><tr><td align="center" valign="middle" >城南春晓</td><td align="center" valign="middle" >L1</td><td align="center" valign="middle" >浑南新区塔南街501号</td><td align="center" valign="middle" >L2</td></tr><tr><td align="center" valign="middle" >小石城梦想小镇</td><td align="center" valign="middle" >L2</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >金石小镇</td><td align="center" valign="middle" >HN-17014</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr><tr><td align="center" valign="middle" >小石城梦想小镇</td><td align="center" valign="middle" >HN0609</td><td align="center" valign="middle" ></td><td align="center" valign="middle" ></td></tr></tbody></table></table-wrap><p>表2. 目标数据库概要数据</p><p>该映射场景初始给定的模式映射如下：</p><p>m1. ∀ P n a m e , P a d d r : B ( P n a m e , P a d d r ) → ∃ I : T 1 ( P n a m e , I ) ∧ T 2 ( I , P a d d r )</p><p>m2. ∀ P n a m e , P n u m b e r : C ( P n a m e , P n u m b e r ) → T 1 ( P n a m e , P n u m b e r )</p><p>m3. ∀ P n u m b e r , P a d d r : D ( P n u m b e r , P a d d r ) → T 2 ( P n u m b e r , P a d d r )</p><p>m4. ∀ P n a m e : A ( P n a m e ) → ∃ N : T 1 ( P n a m e , N )</p><p>上述映射场景中，每个映射规则的源模式都不相同，通过这些映射规则可以将源模式上的实例转换成目标模式上的实例。这些给定的映射规则基本满足映射场景的初始映射规则，可以将源模式上的数据转换到目标模式中。但依据给定的映射规则生成的目标实例包含冗余实例，即表2中灰色背景的部分，这些冗余会影响数据转换的准确性。</p><p>基于上述问题，本文提出如下方法：</p><p>1) 本文将给定映射规则目标模式上的查询定义为扩展，表示满足映射规则的所有查询公式的集合，它们可以作为一阶查询来捕获目标实例。将矩阵之间的同态关系概念应用到扩展中，通过扩展之间的同态关系，查找到目标实例中满足核解特征的目标实例，扩展间的同态关系称为公式同态。</p><p>考虑本文例子中的映射规则m1，它的基扩展为 ε b 1 = ∃ I : T 1 ( P n a m e , I ) ∧ T 2 ( I , P a d d r ) ，合并映射规则m2，m3可以得到第二个扩展 ε ″ = T 1 ( P n a m e , P n u m b e r ) ∧ T 2 ( P n u m b e r , P a d d r ) 。可以看出，存在由基扩展 ε b 1 到 ε ″ 的同态关系，将这种情况称为通过m2，m3生成的扩展覆盖了m1的扩展，就生成核解而言，第二个扩展比基扩展更好，因为其不含存在量词。</p><p>2) 每当为给定映射规则确定了一个比基扩展更合适的扩展时，可以根据以下策略执行映射规则来防止在目标中生成冗余元组。首先通过更合适的扩展查找目标实例，然后使用基扩展只生成那些实际向目标添加一些新内容的目标实例。通过这种方式，我们可以从扩展的角度对核解的特征进行计算，这是本文重写算法的基础。</p><p>3) 为了将上述研究转化为实际的重写方法，通过将扩展重写为源模式上的查询公式，扩展的源重写会在源数据库上声明一个条件，以生成目标中与扩展 ε 相关的目标实例。在我们的例子中，扩展的源重写如下：</p><p>s o u r c e R e w ( T 1 ( P n a m e , P n u m b e r ) ) = I B L B o o k ( t , i d )</p><p>s o u r c e R e w T 1 ( P n a m e , P n u m b e r ) ∧ T 2 ( P n u m b e r , P a d d r ) = C ( P n a m e , P n u m b e r ) , D ( P n u m b e r , P a d d r )</p><p>一旦在源上重写了扩展，可以通过在原始映射规则的前提中添加否定来重写它。每当映射规则m有比基扩展更好的扩展 ε 后，通过添加 ε 的源重写的否定来重写他的前提。</p><p>4) 通过本文的示例研究发现，并不是所有规则都会导致目标中生成冗余实例。在对原始规则进行重写时，应去除那些不含存在量词并且源到目标对应关系明确的规则，为此我们给出初始规则选择方法，只选择那些会生成冗余元组的规则进行重写。分析给定的映射规则集，为每条规则分配一个冗余度，用来确定生成目标实例冗余程度，以便识别其中的哪条规则可能在目标中生成冗余元组。</p><p>5) 最终根据本文方法可以生成以下规则，它们比普通的映射规则更具表现力，允许在前提中添加否定，可以用来表示原始场景的核心模式映射，通过在源实例上执行这些规则能够生成核解，其中r1、r4为重写后的规则，r2、r3为生成目标数据精确度较高的规则，未进行重写：</p><p>r1. ∀ x 1 , x 2 : B ( x 1 , x 2 ) ∧ &#172; ( ∃ x 4 , x 5 : C ( x 1 , x 4 ) ∧ D ( x 5 , x 2 ) ∧ x 4 = x 5 ) → T 1 ( x 1 , f x 1 ) ∧ T 2 ( f x 2 , x 2 )</p><p>r2. C ( x 3 , x 4 ) → T 1 ( x 3 , x 4 )</p><p>r3. D ( x 5 , x 6 ) → T 2 ( x 5 , x 6 )</p><p>r4. ∀ x 7 , A ( x 7 ) ∧ &#172; ( ∃ x 2 : B ( x 7 , x 2 ) ) ∧ &#172; ( ∃ x 4 : C ( x 7 , x 4 ) ) → T 1 ( x 7 , f x 7 )</p></sec><sec id="s4"><title>2. 相关概念</title><p>定义1. 一阶规则(FO规则)</p><p>给定源模式S和目标模式T，一阶规则是形式为 ∀ x &#175; : φ ( x &#175; ) → ψ ( x &#175; ) 的映射关系，其中 φ ( x &#175; ) 是S上的</p><p>一阶公式， ψ ( x &#175; ) 是形式为 R ( t 1 ⋯ t n ) 的原子的合取式， t i 可以是形式为 t i ∈ { x &#175; ( x 1 , x 2 , ⋯ , x n ) } 的变量，也可以是 x &#175; 上的Skolem范式 [<xref ref-type="bibr" rid="hanspub.33936-ref14">14</xref>]。</p><p>定义2. 一阶规则的执行</p><p>给定一阶规则 ∀ x &#175; : φ ( x &#175; ) → ψ ( x &#175; ) ，称 ψ ( x &#175; ) 为从 φ ( x &#175; ) 获得的S上的一阶顺序查询，将 x &#175; 视为自由变量。用 Q φ ( I ) 表示元组 c &#175; ∈ d o m ( I ) | x &#175; | ，这样 c &#175; 就是在S上的实例I，对于查询 Q φ 的结果。给定 c &#175; ∈ Q φ ( I ) ，然后用 ψ ( c &#175; ) 表示从 ψ 获得的原子集合，用相应的 c i ∈ c &#175; 替换每个变量 x i ∈ x &#175; ，并用相应的不确定量替换每个Skolem项 [<xref ref-type="bibr" rid="hanspub.33936-ref14">14</xref>]。</p><p>定义3. 核心模式映射</p><p>给定映射场景 M = ( S , T , Σ S T ) ，如果对于任意源实例I，目标实例 R ( I ) 是M在I上的核解，一组FO规则R被称为M的核心模式映射。</p><p>定义4. 变量</p><p>给定公式 φ l ( x &#175; , y &#175; ) 中的原子 R l ( A 1 : v 1 , ⋯ , A k : v k ) ，其中变量由 R l . A j : v i 表示。如果 v i ∈ x &#175; ，则 φ l ( x &#175; , y &#175; ) 中的变量 R l . A j : v i 是全称量词；如果 v i ∈ y &#175; ，它是存在量词。</p><p>在下文中，用 o c c ( φ l ( x &#175; , y &#175; ) ) 表示所有在 φ l ( x &#175; , y &#175; ) 中的变量； u − o c c ( φ l ( x &#175; , y &#175; ) ) ， e − o c c ( φ l ( x &#175; , y &#175; ) ) 分别表示全称变量和存在变量。同样， o c c ( v ) ， u − o c c ( v ) ， e − o c c ( v ) 将表示给定变量v的所有(通用的，存在的)变量取值集合。</p><p>定义5. 公式同态</p><p>给定两个合取范式： φ l ( x &#175; , y &#175; ) 和 φ ′ l ( x &#175; ′ , y &#175; ′ ) ，公式同态是一个从集合 o c c ( φ l ( x &#175; , y &#175; ) ) 到 o c c ( φ ′ l ( x &#175; ′ , y &#175; ′ ) ) 的映射 h f 。</p><p>i) h f 将 φ l ( x &#175; , y &#175; ) 中的全称量词映射为 φ ′ l ( x &#175; ′ , y &#175; ′ ) 中的全称量词；</p><p>ii) 对于每个原子 R l ( A 1 : v 1 , ⋯ , A k : v k ) ∈ φ l ( x &#175; , y &#175; ) ，在集合 φ ′ l ( x &#175; ′ , y &#175; ′ ) 上存在 R ( h f ( R l ( A 1 : v 1 , ⋯ , A k : v k ) ∈ φ ′ l ( x &#175; ′ , y &#175; ′ ) ) ) 与之对应；</p><p>iii) 对于存在变量 y ∈ y &#175; ，变量 R n l . A m : y ， R i l . A j : y 成对出现，在这种情况下， h f ( R n l . A m : y ) 和 h f ( R i l . A j : y ) 都是常量，或者是在 y ′ ∈ y &#175; ′ 中相同的存在变量。</p><p>如果一个公式同态 h f 把 φ l ( x &#175; , y &#175; ) 中的不同的原子映射到 φ ′ l ( x &#175; ′ , y &#175; ′ ) 的不同的原子中，则公式同态 h f 是单射的。如果 φ ′ l ( x &#175; ′ , y &#175; ′ ) 中的每个原子都是依据 h f 在 φ l ( x &#175; , y &#175; ) 中的某个原子的图像，那么 h f 是满射的。</p><p>对于关系 R ( A , B , C ) 和 T ( A , B , C ) 上的两个查询公式：</p><p>φ l = R 1 ( x 1 , x 2 , Y 1 ) ∧ T 2 ( x 3 , x 1 , Y 1 ) 和 φ ′ l = R 3 ( x ′ 4 , x ′ 5 , x ′ 6 ) ∧ T 4 ( x ′ 9 , x ′ 7 , x ′ 8 )</p><p>在以下变量之间的映射中，存在 φ l 到 φ ′ l 的公式同态 h f 。</p><p>h f ( R 1 . A : x 1 ) → R 3 . A : x ′ 4 ， h f ( R 1 . B : x 2 ) → R 3 . B : x ′ 5</p><p>h f ( R 1 . C : Y 1 ) → R 3 . C : x ′ 6 ， h f ( T 2 . A : x 3 ) → T 4 . A : x ′ 9</p><p>h f ( T 2 . B : x 1 ) → T 4 . B : x ′ 7 ， h f ( T 2 . C : Y 1 ) → T 4 . C : x ′ 8</p><p>可以看出，由于公式同态的影响，它们可以将左侧的相同变量与右侧不同变量相关联。在本文中，</p><p>将通过 A j : h R l . A j f ( v i ) 来引用变量 h f ( R l . A j : v i ) 。 h R l . A j f ( v i ) 是与 v i 中的 R l . A j 相关联的变量。考虑上面 h f 的例子， φ l 中出现两次的存在变量 x 1 被映射到 φ ′ l 中不同的通用变量的位置，实际上， h R 1 . A f ( x 1 ) = x ′ 4 ，而 h T 2 . B f ( x 1 ) = x ′ 7 。</p><p>定义6. 公式同态的分类</p><p>给定两个合取公式 φ l ( x &#175; , y &#175; ) 和 φ ′ l ( x &#175; ′ , y &#175; ′ ) ，和一个从 o c c ( φ l ( x &#175; , y &#175; ) ) 到 o c c ( φ ′ l ( x &#175; ′ , y &#175; ′ ) ) 的公式同态 h f 。</p><p>i) 如果 h f 是满射的，则公式同态 h f 是更紧凑的。可以是 | φ ′ l ( x &#175; ′ , y &#175; ′ ) | &lt; | φ l ( x &#175; , y &#175; ) | 或 | y &#175; ′ | &lt; | y &#175; | 的情况。即要么 φ ′ l ( x &#175; ′ , y &#175; ′ ) 比 φ l ( x &#175; , y &#175; ) 小，要么 φ ′ l ( x &#175; ′ , y &#175; ′ ) 包括较少的存在变量；</p><p>ii) 如果 h f 是单射的而不是满射的，则 h f 被认为是更适当的，即在 φ ′ l ( x &#175; ′ , y &#175; ′ ) 中至少有一个原子不是<inline-formula><inline-graphic xlink:href="//html.hanspub.org/file/8-1760193x126_hanspub.png" xlink:type="simple"/></inline-formula>的原子的图像。</p><p>讨论“公式同态”和“事实(公式的所有实例的集合)之间对的应同态”的关系是非常重要的。本文研究公式同态，以便检测作为公式事实之间可能的同态。然而，公式同态并不能保证实际同态在事实之间产生，公式之间的同态映射可以将通用变量的值映射为其他通用变量的值。在实例化公式时，这些变量不一定接收相同的值，公式实例之间的同态可能实现也可能不实现，这都取决于通用变量所假设的值。</p><p>考虑关于 φ l = R 1 ( x 1 , x 2 , Y 1 ) ∧ T 2 ( x 3 , x 1 , Y 1 ) 和 φ ′ l = R 3 ( x ′ 4 , x ′ 5 , x ′ 6 ) ∧ T 4 ( x ′ 9 , x ′ 7 , x ′ 8 ) 的公式同态 h f 。包含两个公式的实例： W = { R ( 1 , 2 , N 0 ) , T ( 3 , 1 , N 0 ) } 和 W ′ = { R ( 1 , 2 , 4 ) , T ( 3 , 1 , 4 ) } 。给定变量值的赋值，可以看出， w ′ 的事实集实际上比w的事实集更紧凑。如果改变赋值，通常不会这样。</p><p>现在考虑一下： W ″ = { R ( 1 , 2 , N 0 ) , T ( 3 , 1 , N 0 ) } 和 W ‴ = { R ( 1 , 4 , 6 ) , T ( 3 , 5 , 7 ) } 。 w ″ 中没有 w ‴ 的同态，造</p><p>成这种情况的原因有两个。i) 首先，公式同态将 x 2 映射为 x ′ 5 。通过这样做，公式同态对变量 x 2 ， x ′ 5 的值进行限制：为了实现公式实例之间的同态，两个变量必须接收相同的值；ii) 其次， h f 将两次出现的 N 0 映射到 x ′ 6 x ′ 8 ；这意味着为了实现同态， x ′ 6 的值应等于 x ′ 8 的值。</p><p>给定一个公式同态 h f ，可以在与 h f 有关的通用变量之间引入几组等式：</p><p>I N T E R S E C T h f 表示 φ l ( x &#175; , y &#175; ) 和 φ ′ l ( x &#175; ′ , y &#175; ′ ) 之间全称量词的一组等价集(等式集合)，这组等式必须成立，才能实现这两个公式实例之间的同态。</p><p>I N T E R S E C T h f ( x &#175; , x &#175; ′ ) = { x i = x ′ j | h f ( R . A : x i ) = R . A : x ′ j , x i ∈ x &#175; , x ′ j ∈ y &#175; }</p><p>J O I N S h f 表示 φ ′ l ( x &#175; ′ , y &#175; ′ ) 的全称量词之间的等价集，其具体的值是 φ l ( x &#175; , y &#175; ) 中相同存在量词的值的图像。</p><p>J O I N S h f ( x &#175; ) = { x ′ h = x ′ l | x ′ h = h R i . A j f ( y k ) , x ′ l = h R n . A m f ( y k ) , y k ∈ y &#175; }</p><p>直观地说，只有满足 E Q U A L h f ( x &#175; , x &#175; ′ ) 的赋值才能实现公式同态。</p><p>E Q U A L h f ( x &#175; , x &#175; ′ ) = I N T E R S E C T h f ( x &#175; , x &#175; ′ ) ∪ J O I N S h f ( x &#175; ′ )</p></sec><sec id="s5"><title>3. 模式映射重写</title><sec id="s5_1"><title>3.1. 扩展</title><p>给定一个映射场景 M = ( S , T , Σ S T ) ，由 R = ∪ i ψ i ( x &#175; i , y &#175; i ) 表示在 Σ s t 中的所有映射规则结论的集合，由 R k p o w 表示在R中的所有数量≤k的多重原子集合；每当多重集合中出现相同原子的多个副本时，本文假设它们已被正确重命名，以避免变量的冲突。给定映射场景 M = ( S , T , Σ S T ) ，本文的目标是在一组表示M的核心模式映射的一阶逻辑规则下重写给定的映射规则，从中生成一个SQL脚本，直接生成核心目标实例。为了执行重写，将依赖于核解的概念。在本节中，我们将介绍映射规则结论中基于扩展的核解概念，并在下一节中使用它来执行重写，使用扩展作为研究映射规则结论之间可能存在冗余的一种方法。</p><p>定义7. 映射规则中的扩展</p><p>给定映射场景M和映射规则集 Σ S T ，在 Σ S T 中有映射规则 t g d . m : ϕ ( x &#175; 2 ) → ∃ y &#175; 2 ( ψ l ( x &#175; 2 , y &#175; 2 ) ) ，m的扩展集合用 e x p a n s i o n s M ( m ) 表示， e x p a n s i o n s M ( m ) 是一组包含存在量词的逻辑查询公式： ε = χ l ( x &#175; 1 , y &#175; 1 ) ∧ ∃ x &#175; 2 , y &#175; 2 : ( ψ l ( x &#175; 2 , y &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) ) ，其中 χ l ( x &#175; 1 , y &#175; 1 ) 是 R k p o w 中带标记的原子(k是 ψ l ( x &#175; 2 , y &#175; 2 ) 的大小)，且存在满射 h f ， h c f : ψ ( x &#175; 2 , y &#175; 2 ) → χ ( x &#175; 1 , y &#175; 1 ) 。</p><p>在接下来的文章中，假设扩展中 x &#175; 1 ∩ x &#175; 2 = ∅ ， y &#175; 1 ∩ y &#175; 2 = ∅ ，即 x &#175; 1 , x &#175; 2 , y &#175; 1 , y 2 是不相交的。注意扩展 ε 也可以被看作是一个含有自由变量 x &#175; 1 , y &#175; 1 的查询 ε ( x &#175; 1 , y &#175; 1 ) 。接下来会证明，在通解 J ∈ U S o l M ( I ) 上进行这样的查询，结果恰好会返回目标实例集合 W 〈 I , J 〉 中的一组目标实例。</p><p>给定实例J，并给 x &#175; 1 , y &#175; 1 赋值 a 1 ，如果满足以下条件，则称 J | = a 1 ( ε ( x &#175; 1 , y &#175; 1 ) ) ：</p><p>J | = a 1 ( χ l ( x &#175; 1 , y &#175; 1 ) )</p><p>a 1 , a 2 是 E Q U A L h f ( a 1 ( x &#175; 1 ) , a 2 ( x &#175; 2 ) ) 的形式。</p><p>由于映射规则结论的扩展数量随着结论之间连接的数量而增加，并且它通常是输入映射规则的大小的指数。将 e x p a n s i o n s M ( m ) 称为 Σ S T 中映射规则的所有扩展集。</p><sec id="s5_1_1"><title>3.1.1. 扩展与核解</title><p>根据参考文献 [<xref ref-type="bibr" rid="hanspub.33936-ref15">15</xref>] 我们可以知道，在目标数据库存储的目标实例中，为了生成核解，需要选择最大的实例，具体步骤是首先选择包含属性更多的实例，再此基础上选择包含信息性更大的实例，最后将能够</p><p>满足 J 0 = ∪ S e l e c t B e s t B l o c k ( S i n g l e ( F u l l ( W 〈 I , J 〉 ) ) ) 关系的实例称之为核解。我们在本节引入核解的概念，</p><p>基于扩展给出核解的相似概念，但是这个核解并不是依赖于实例的而是基于本文所说的扩展生成的。</p></sec><sec id="s5_1_2"><title>3.1.2. 扩展的分类</title><p>在本文第2节中介绍的公式同态可以用来确定什么时候扩展能够产生一个比其他块包含更多属性或更具信息性的实例，由此引入了一个更紧凑的和更具信息性的扩展的并行定义。</p><p>定义8. 更紧凑和更具信息性的扩展</p><p>给定由具体实例组成的扩展：</p><p>ε = χ l ( x &#175; 1 , y &#175; 1 ) ∧ ∃ x &#175; 2 , y &#175; 2 : ( ψ l ( x &#175; 2 , y &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) )</p><p>ε ′ = χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) ∧ ∃ x &#175; ′ 2 , y &#175; ′ 2 : ( ψ ′ l ( x &#175; ′ 2 , y &#175; ′ 2 ) ∧ E Q U A L h c ' f ( x &#175; ′ 1 , x &#175; ′ 2 ) )</p><p>如果存在一个更紧凑的同态 h c f : χ l ( x &#175; 1 , y &#175; 1 ) → χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) ，则称 ε ′ 比 ε 更紧凑，用 ε ≺ ε ′ 表示；</p><p>如果存在更恰当的同态 h p f : χ l ( x &#175; 1 , y &#175; 1 ) → χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) ，称 ε ′ 比 ε 更具有信息性，用 ε &lt; ε ′ 表示；</p><p>当根据公式同态 h f 使得 ε ′ 比 ε 更紧凑(或更具信息性)时，可以这样写 ε ≺ h f ε ′ ( ε &lt; h f ε ′ )。</p></sec><sec id="s5_1_3"><title>3.1.3. 扩展的选择</title><p>根据上述方法，给定一个扩展 ε ，我们可以基于扩展 ε 生成一个新的查询，叫做 m o s t C o m p ( ε ) 。主要通过向 ε 添加 ε ′ 的否定， ε ′ 比 ε 更紧凑。有如下等式：</p><p>定义9. 更紧凑的扩展： m o s t C o m p (ε)</p><p>给定一个映射场景M，以及它的一组扩展 e x p a n s i o n s ( M ) ，其中的一个扩展如下：</p><p>ε = χ l ( x &#175; 1 , y &#175; 1 ) ∧ ∃ x &#175; 2 , y &#175; 2 : ( ψ l ( x &#175; 2 , y &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) )</p><p>m o s t C o m p ( ε ) 通过如下方式获得：</p><p>1) 初始化 m o s t C o m p ( ε ) = ε ；</p><p>2) 对于 e x p a n s i o n s ( M ) 中的任意 ε ′ = χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) ∧ ∃ x &#175; ′ 2 , y &#175; ′ 2 : ( ψ ′ l ( x &#175; ′ 2 , y &#175; ′ 2 ) ∧ E Q U A L h c ' f ( x &#175; ′ 1 , x &#175; ′ 2 ) ) 和任意形如 ε ≺ h f ε ′ 的公式同态 h f 。即 ε ′ 根据 h f 变得比 ε 更紧凑，向 m o s t C o m p ( ε ) 添加公式 ∧ &#172; ∃ x &#175; ′ 1 , y &#175; ′ 1 : ( ε ′ ∧ E Q U A L h c f ( x &#175; 1 , x &#175; ′ 1 ) ) 。</p><p>本文将用 m o s t C o m p ( M ) 来表示形式为 m o s t C o m p ( ε ) 的扩展所有重写的集合，其中 ε ∈ e x p a n s i o n s ( M ) 。</p><p>在第一次重写之后，与通过实例生成核解的方法所述的策略相一致，我们在其他扩展中寻找有利于在目标中生成更具信息性的目标实例的扩展，并且进一步重写 m o s t C o m p ( ε ) 。在这个过程中，产生成了一个在 m o s t C o m p ( ε ) 基础上的公式，叫做 m o s t I n f ( ε ) ，如下所示：</p><p>定义10. 更具信息性的扩展： m o s t I n f (ε)</p><p>给定一个映射场景M，以及它的一组扩展 e x p a n s i o n s ( M ) ，其中的一个扩展如下：</p><p>ε = χ l ( x &#175; 1 , y &#175; 1 ) ∧ ∃ x &#175; 2 , y &#175; 2 : ( ψ l ( x &#175; 2 , y &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) )</p><p>m o s t I n f ( ε ) 的具体操作如下：</p><p>1) 初始化 m o s t I n f ( ε ) = m o s t C o m p (ε)</p><p>2) 对于 e x p a n s i o n s ( M ) 中的任意扩展</p><p>ε ′ = χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) ∧ ∃ x &#175; ′ 2 , y &#175; ′ 2 : ( ψ ′ l ( x &#175; ′ 2 , y &#175; ′ 2 ) ∧ E Q U A L h c ' f ( x &#175; ′ 1 , x &#175; ′ 2 ) ) 和任意形如 ε &lt; h f ε ′ 的公式同态 h f ，即 ε ′ 由 h f 变得比 ε 更具信息性，向 m o s t I n f ( ε ) 添加公式</p><p>∧ &#172; ∃ x &#175; ′ 1 , y &#175; ′ 1 : ( m o s t C o m p ( ε ′ ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; ′ 1 ) ) 。</p><p>我们用 m o s t I n f ( M ) 表示 m o s t I n f ( ε ) 形式的所有重写集。</p><p>总之，为了选择最大目标实例，本文考虑映射规则tgd中的每个扩展 ε ：</p><p>a) 首先通过添加所有的扩展 ε i 否定，将 ε 重写成一个新形式： m o s t C o m p ( ε ) ， ε i 比 ε 更紧凑；本文期望用这些新的公式选择在与 ε 相关的目标实例中更紧凑的；</p><p>b) 然后通过添加 m o s t C o m p ( ε j ) 的否定，进一步将 m o s t C o m p ( ε ) 重写为一个新的公式 m o s t I n f ( ε ) ，扩展 ε j 比 ε 更具信息性。</p><p>与扩展类似，扩展的重写也可以被视为查询。给定扩展 ε ，以及相关的查询 ε ( x &#175; 1 , y &#175; 1 ) ， m o s t C o m p ( ε ) 和 m o s t I n f ( ε ) 都可以看作是带有自由变量 x &#175; 1 , y &#175; 1 的查询。本文编写这些查询如下： m o s t C o m p ( ε ) ( x &#175; 1 , y &#175; 1 ) 和 m o s t I n f ( ε ) ( x &#175; 1 , y &#175; 1 ) 。为了简化符号，本文将省略显式引用变量，仅用 m o s t C o m p ( ε ) 和 m o s t I n f ( ε ) 来代表查询。</p></sec></sec><sec id="s5_2"><title>3.2. 规则选择</title><p>在前文中，通过对初始映射规则结论进行分析，给出了扩展的概念，进而我们希望通过扩展对初始模式映射规则集进行重写以让他可以直接生成核解。但是分析发现，不是所有的规则都会在目标中生成冗余实例。若对初始规则集中的所有规则都进行重写，会导致运行时间过长，效率低等问题。由于有些规则已经满足核心模式映射条件，不需要进行重写就可以直接生成满足核解的目标实例，我们希望对规则集进行选择，只对不满足核心模式映射条件的规则进行重写。</p><sec id="s5_2_1"><title>3.2.1. 规则冗余程度</title><p>为了识别不同规则生成冗余的大小程度，必须对规则源模式与目标模式之间的属性相似度进行计算。针对本文研究数据特点，由于数据来自不同的web数据源，在计算属性相似度时选用Jaccard相似系数方法来计算源和目标模式属性相似度。</p><p>定义11. Jaccard相似系数</p><p>给定两个集合A、B，Jaccard相似系数定义为A与B交集的大小与A与B并集的大小的比值，定义如下：</p><p>J ( A , B ) = | A ∩ B | | A ∪ B | = | A ∩ B | | A | + | B | − | A ∩ B |</p><p>当集合A，B都为空时， J ( A , B ) 定义为1。</p><p>本文称给定规则源模式与目标模式之间的相似系数大于0.7时，该规则生成的目标实例冗余度较低，不需要进行重写。当相似系数低于0.7时，应进行规则分解，查看规则中全称量词的数量来进一步确定该规则是否会生成冗余度较高的目标实例，是否需要重写。</p></sec><sec id="s5_2_2"><title>3.2.2. 规则分解</title><p>给定映射场景 以及它的初始规则集，本文将根据文献 [<xref ref-type="bibr" rid="hanspub.33936-ref16">16</xref>] 中研究的策略来对冗余度较高的给定规则进行分解，具体方法如下。</p><p>分析表级之间映射关系的构成，考虑源和目标模式下包含如下对应关系：</p><p>1) 1:1映射关系</p><p>1:1映射关系是指web数据源模式与目标数据模式中的表结构是一致的，即标准数据库中的某些表在源数据库中有唯一的一个数据与之对应。对于映射关系为1:1的映射规则，若其目标模式中不含存在量词，则不要进行重写，直接作为核模式映射输出。若其目标模式中包含存在量词，这些规则生成的数据中必定包含较多的变量，说明这些规则是冗余的，直接进入待重写的规则库。</p><p>2) 1:N映射表关系</p><p>1:N映射关系是指web数据源模式与目标数据模式的表结构并非是一致的，即源数据库中原始数据的一个表映射到目标数据库中的多个表。首先将其分解为1:1类型的映射，然后根据其包含存在量词的数量来确定其冗余程度的大小，判断是否需要对其进行重写。</p><p>3) N:M映射表关系</p><p>N:M映射关系是指web数据源模式与目标数据模式的表结构并非是一致的，即源数据库中原始数据的多个表映射到目标数据库中的多个表。当规则中的映射关系为M:N时，可以首先将其转换成M个1:N的映射关系；然后再将1:N的映射处理为N个1:1之间的映射；最后对M * N个1:1的映射关系进行判断处理即可。在其中若不包含存在量词，则作为核心模式映射输出；若其中包含存在量词，则其冗余度较大，需要按照本文方法进行重写，转换成核心模式映射来计算核解。</p></sec></sec><sec id="s5_3"><title>3.3. 重写方法</title><sec id="s5_3_1"><title>3.3.1. 源重写</title><p>扩展作为目标模式上的公式，在本节中表明可以根据源模式上的关系来重写扩展，我们将其称为扩展的源重写。虽然扩展是一个用于在目标模式中选择原子的查询，但它的源重写说明了这些原子存在的“前提条件”。通过引入标签技术 [<xref ref-type="bibr" rid="hanspub.33936-ref2">2</xref>]，在源上重写扩展的策略得以实现。事实上，扩展是从映射规则结论中得到的标记原子的合取范式。对于每一个原子，都用一个前提联系起来(前提就是相应的规则的左侧)。通过连接其所有原子的前提，能够获得扩展的源重写。注意到标签系统在这一步中起着核心作用：通过查看每个扩展的原子的标签，可以立即知道它的出自哪一个映射规则，因此也就知道了它的前提。</p><p>定义12. 映射规则的前提</p><p>给定映射规则 t g d . m ∀ x &#175; : ϕ ( x &#175; ) → ∃ y &#175; ( ψ l ( x &#175; , y &#175; ) ) 和原子 R l ( x &#175; i , y &#175; i ) ∈ ψ l ( x &#175; , y &#175; ) ， R l ( x &#175; i , y &#175; i ) ∈ ψ l ( x &#175; , y &#175; ) 的前提 p r e m i s e ( R l ( x &#175; i , y &#175; i ) ) 实际上是由映射规则的左侧公式 ϕ ( x &#175; ) 构成的。</p><p>给定一个查询公式 χ l ( x &#175; 1 , y &#175; 1 ) ，其具体前提由如下公式表示：</p><p>p r e m i s e ( χ l ( x &#175; 1 , y &#175; 1 ) ) = ∧ { p r e m i s e ( R i l ( x &#175; i , y &#175; i ) ) | R i l ( x &#175; i , y &#175; i ) ∈ χ l ( x &#175; 1 , y &#175; 1 ) }</p><p>定义13. 源重写</p><p>给定映射规则 m : ϕ ( x &#175; 2 ) → ∃ y &#175; 2 ( ψ l ( x &#175; 2 , y &#175; 2 ) ) 和扩展集合 e x p a n s i o n s M ( m ) 中的扩展 ε = χ l ( x &#175; 1 , y &#175; 1 ) ∧ ∃ x &#175; 2 , y &#175; 2 : ( ψ l ( x &#175; 2 , y &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) ) ，它的源重写 S o u r c e R e w ( ε ) 是下面的公式：</p><p>S o u r c e R e w ( ε ) = p r e m i s e ( χ l ( x &#175; 1 , y &#175; 1 ) ) ∧ ∃ x &#175; 2 : ( ϕ ( x &#175; 2 ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; 2 ) )</p><p>注意到，虽然tgd的扩展 ε 可以看作是一个查询 ε ( x &#175; 1 , y &#175; 1 ) ， ε ( x &#175; 1 , y &#175; 1 ) 包括映射规则m的全称量词和存在量词，它的源重写 S o u r c e R e w ( ε ) ，也是一个查询 S o u r c e R e w ( ε ) ( x &#175; 1 ) ，但其中所有自由变量都是映射规则m的全称量词。</p></sec><sec id="s5_3_2"><title>3.3.2. 源重写的否定</title><p>给定扩展 ε ，它的源重写 S o u r c e R e w ( ε ) 说明了产生其所有实例的前提条件。本文只想选择关于信息量最大的，最具代表性的实例。因此，需要生成新的表达式，分别为与扩展相关的最紧凑和更具信息性的见证块集提供前提条件。</p><p>为了进行上述操作，给定扩展 ε ，引入公式 S o u r c e R e w ( m o s t C o m p ( ε ) ) 和 S o u r c e R e w ( m o s t I n f ( ε ) ) ，类似于 m o s t C o m p ( ε ) 和 m o s t I n f ( ε ) ，但是在源上重写了。为了生成 S o u r c e R e w ( m o s t C o m p ( ε ) ) ，每当扩展 ε ′ 比 ε 更紧凑时，在 ε 的源重写中加入 S o u r c e R e w ( ε ′ ) 的否定。</p><p>定义14. 重写源上的mostComp()</p><p>给定场景M，以及M上的一组扩展 e x p a n s i o n s ( M ) ，他们的重写是 m o s t C o m p ( ε ) ， 对于扩展集 e x p a n s i o n s ( M ) 中的每个 ε ，其公式 S o u r c e R e w ( m o s t C o m p ( ε ) ) 生成的方式如下：</p><p>i) 首先初始化</p><p>S o u r c e R e w ( m o s t C o m p ( ε ) ) = S o u r c e R e w (ε)</p><p>ii) 然后对于扩展集 e x p a n s i o n s ( M ) 中的任何扩展 ε ′ ，若 ε ′ 是比 ε 更紧凑的，称 h c f 为从 χ l ( x &#175; 1 , y &#175; 1 ) 到 χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) 的更紧凑的同态；向 S o u r c e R e w ( m o s t C o m p ( ε ) ) 添加一个公式：</p><p>∧ &#172; ∃ x &#175; ′ : ( S o u r c e R e w ( ε ′ ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; ′ 1 ) )</p><p>定义15. 重写源上的mostInf()</p><p>给定场景M，以及M上的一组扩展 e x p a n s i o n s ( M ) ，对于扩展集 e x p a n s i o n s ( M ) 中的每个 ε ，其公式 S o u r c e R e w ( m o s t I n f ( ε ) ) 生成的方式如下：</p><p>i) 初始化</p><p>S o u r c e R e w ( m o s t I n f ( ε ) ) = S o u r c e R e w ( m o s t C o m p (ε) )</p><p>ii) 然后对于扩展集 e x p a n s i o n s ( M ) 中的任何扩展 ε ′ ，若 ε ′ 是比 ε 更具信息性的，称 h c f 为从 χ l ( x &#175; 1 , y &#175; 1 ) 到 χ ′ l ( x &#175; ′ 1 , y &#175; ′ 1 ) 的更恰当的同态；向 S o u r c e R e w ( m o s t I n f ( ε ) ) 添加一个公式：</p><p>∧ &#172; ∃ x &#175; ′ 1 : ( S o u r c e R e w ( m o s t C o m p ( ε ′ ) ) ∧ E Q U A L h c f ( x &#175; 1 , x &#175; ′ 1 ) )</p></sec><sec id="s5_3_3"><title>3.3.3. 重写算法</title><p>现在准备介绍本文的最终重写算法。主要介绍一个映射场景M中扩展规则的概念，由于希望规则被规范化。因此，使用公式 S o u r c e R e w ( m o s t I n f ( ε ) ) 为每个规范化的扩展 ε 都建立一个规则，其中将只有全称量词出现作为前提条件。在 ε 不是规范化的情况下，生成一系列规范化规则，由 n o r m a l i z e ( ε ) 表示， n o r m a l i z e ( ε ) 中每个规范化分量对应一个规则。</p><p>定义16. 扩展规则</p><p>对于扩展集 e x p a n s i o n s ( M ) 中的每个扩展 ε ，都生成一组扩展规则 e x p a n s i o n R u l e ( ε ) ，其形式如下：</p><p>∀ x &#175; 1 : S o u r c e R e w ( m o s t I n f ( ε ) ) ( x &#175; 1 ) → χ i ( x &#175; 1 , y &#175; 1 )</p><p>其中 χ i ( x &#175; 1 , y &#175; 1 ) 是 n o r m a l i z e ( ε ) 的规范化分量。映射场景M的扩展规则集如下：</p><p>Σ M e = { e x p a n s i o n R u l e ( ε ) | ε ∈ e x p a n s i o n s ( M ) }</p><p>正如前面几节所讨论的，一个简单的优化是由仅为原子集为核解的扩展生成的扩展规则组成。</p><p>为了处理非标准化块，我们在规则结论中寻找适当的同态：我们将公式同态的概念扩展到Skolem公式，将Skolem项考虑为存在量词；然后进一步的进行重写，如下所示：</p><p>定义17. 最终重写finalRew()</p><p>对于每条属于 Σ M e 的规则r，规则 f i n a l R e w ( r ) 通过如下方式获得：</p><p>将在规则选择过程中冗余度较高的规则r称为分解规则。</p><p>若r不是分解规则， f i n a l R e w ( r ) = r 。</p><p>若r是形式为 r . ϕ ( x ) → ψ ( x ) 的分解规则：</p><p>i) 首先初始化 f i n a l R e w ( r ) = r ；</p><p>ii) 对于 Σ M e 中的任意规则 r ′ . ϕ ′ ( x ′ ) → ψ ′ ( x ′ ) ，根据同态 h i f 说明 ψ ′ ( x ′ ) 是比 ψ ( x ) 更具信息性的，向 f i n a l R e w ( r ) 增加一个前提公式 ∧ &#172; ∃ ( x &#175; ′ ) : ( ϕ ′ ( x ′ ) ∧ E Q U A L h i f ( x &#175; , x ′ &#175; ) ) 。</p><p>最后构成了一组新的一阶逻辑规则，具体表示如下：</p><p>Σ M c = { f i n a l R e w ( r ) | r ∈ Σ M e }</p></sec></sec></sec><sec id="s6"><title>4. 实验结果</title><sec id="s6_1"><title>4.1. 数据集</title><p>本文采用的数据集是从中国土地网、链家网等房产信息网站爬取的500多万条数据，经过垃圾清理、无意义信息删除两个预处理过程，数据信息属性如表3所示。</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> Real estate information data sheet attribute descriptio</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >序号</th><th align="center" valign="middle" >列名</th><th align="center" valign="middle" >数据类型</th><th align="center" valign="middle" >说明</th></tr></thead><tr><td align="center" valign="middle" >1</td><td align="center" valign="middle" >PId</td><td align="center" valign="middle" >Int</td><td align="center" valign="middle" >编号(主键)</td></tr><tr><td align="center" valign="middle" >2</td><td align="center" valign="middle" >Pname</td><td align="center" valign="middle" >Varchar</td><td align="center" valign="middle" >楼盘名称</td></tr><tr><td align="center" valign="middle" >3</td><td align="center" valign="middle" >Paddr</td><td align="center" valign="middle" >Varchar</td><td align="center" valign="middle" >楼盘地址</td></tr></tbody></table></table-wrap><p>表3. 房地产信息数据表属性说明</p><p>为了评估本文提出的模式映射优化方法的可行性和有效性，我们从数据集中筛选出部分高质量房产信息数据构建实验数据集，现实世界中的真实数据很难全面的展现所有问题，因此，采用上述数据集构造了人工数据集，表4显示了构建数据集的关键特征。针对个本文构建数据集模式及目标数据模式即S和T构建模式映射，选取其中12个作为基本映射集，这些模式映射可以满足源和目标模式的基本要求。</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> Property description of the Weibo data tabl</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >序号</th><th align="center" valign="middle" >Set1</th><th align="center" valign="middle" >Set2</th><th align="center" valign="middle" >Set3</th></tr></thead><tr><td align="center" valign="middle" >数据集大小(TB)</td><td align="center" valign="middle" >6.32</td><td align="center" valign="middle" >4.17</td><td align="center" valign="middle" >1.98</td></tr><tr><td align="center" valign="middle" >平均实例大小(KB)</td><td align="center" valign="middle" >132.6</td><td align="center" valign="middle" >71.0</td><td align="center" valign="middle" >202.3</td></tr><tr><td align="center" valign="middle" >数据冗余程度(%)</td><td align="center" valign="middle" >26.14</td><td align="center" valign="middle" >33.71</td><td align="center" valign="middle" >23.26</td></tr></tbody></table></table-wrap><p>表4. 实验用评测数据集</p></sec><sec id="s6_2"><title>4.2. 实验设置</title><p>本文将按照以下两种策略来衡量本文算法的有效性以及与同类工作相比的优越性。首先比较不同数据集下的信息准确率，信息准确率是指映射规则能描述完整的源模式及目标模式信息，包括文档结构信息以及语义约束信息等。映射规则中的每一个分量都不可再分，任意两个属性不能完全相同。映射规则的完整性代表着规则的完善程度，也标志着根据其生成的目标实例存在少量冗余信息。在本文节中，信息准确率是根据本文方法重写规则后生成的满足核解特征的实例数量占总目标数据库中存储实例数量的比例，如下列公式所示：</p><p>Precision = 满 足 核 解 特 征 的 实 例 数 目 标 数 据 库 中 存 储 实 例 总 数 &#215; 100 %</p><p>接下来本文将根据优化后的模式映射生成的数据中冗余缩小程度来评估本文方法的可行性，冗余缩小程度即结果生成的数据包含冗余数量占总数据的百分比与之前数据集中重复率大小的比值，如下列公式所示：</p><p>Reduction   of   repetition = 最 终 生 成 数 据 冗 余 度 初 始 冗 余 程 度 &#215; 100 %</p></sec><sec id="s6_3"><title>4.3. 实验结果</title><p>图1比较了本文方法SMO与其他两种方法TKM [<xref ref-type="bibr" rid="hanspub.33936-ref17">17</xref>]，SRMIS [<xref ref-type="bibr" rid="hanspub.33936-ref18">18</xref>] 的比较结果。如图所示，在三个数据集的测试中，本文方法都能保持较高性能，信息准确率始终高于80%，TKM方法性能表现次之，这主要是由于其固有的缺点，即它的基于语义逻辑的映射选择策略，这可能导致不同应用场景的模式映射结果存在巨大差异。SRMIS的信息准确率仅达到70%左右，在本文数据集中的表现结果最差。</p><p>图1. 信息完整性对比</p><p>图2. 冗余缩小程度</p><p>图2显示了随着数据规模的增大，本文方法与其他两种方法的冗余程度。如图所示，当数据数量为100 k时，当源实例数据量小于500 k时，三种方法都具有较好的处理性能。当源实例数据量增加到1 M时，SRMIS，TKM两种算法对冗余的缩小程度明显下降。当源实例数据量增加到5 M时，本文中提出SMO方法可以将冗余缩小程度维持在85%以上，其他两种方法在处理数据量较大的数据集时，表现不佳，但很明显本文方法在降低大型数据集冗余程度时性能更好，效率更高。</p></sec></sec><sec id="s7"><title>5. 结论</title><p>本文首先分析了传统的数据转换核解计算方法的不足之处，继而对上述现有的核解计算方法提出改进，并针对模式层数据转换问题提出了模式层数据转换映射重写方法，进而对本文方法的查询效果做了理论分析，在真实数据集中验证了本文方法的有效性，证明本文方法在很大程度上减少了冗余数据数量，降低了转换成本。本文方法需要在已有研究的基础上，进一步研究包含连接情况的映射处理的问题，分析映射关系之间的依赖性和数据的分布特性，优化转换效率，以进一步降低转换成本，提高算法的转换效率。</p></sec><sec id="s8"><title>文章引用</title><p>纪宇航,李 贵,李征宇,韩子扬,曹科研. Web数据转换模式映射优化方法Web Data Exchange Schema Mapping Optimization Method[J]. 数据挖掘, 2020, 10(01): 76-89. https://doi.org/10.12677/HJDM.2020.101008</p></sec><sec id="s9"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.33936-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">Fagin, R., Kolaitis, P.G., et al. (2003) Data Exchange: Semantics and Query Answering. In: Database Theory—ICDT 2003, Springer, Berlin, Heidelber, 207-224. 
https://doi.org/10.1007/3-540-36285-1_14</mixed-citation></ref><ref id="hanspub.33936-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Fagin, R., Kolaitis, P.G. and Popa, L. (2005) Data Exchange: Getting to the Core. ACM Transactions on Database Systems, 30, 174-210. 
https://doi.org/10.1145/1061318.1061323</mixed-citation></ref><ref id="hanspub.33936-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Pichler, R. and Savenkov, V. (2010) Towards Practical Feasibility of Core Computation in Data Exchange. Theoretical Computer Science, 411, 935-957.  
https://doi.org/10.1016/j.tcs.2009.09.035</mixed-citation></ref><ref id="hanspub.33936-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Kimmig, A., Memory, A., Miller, R.J. and Getoor, L. (2017) A Collective, Probabilistic Approach to Schema Mapping. 2017 IEEE 33rd International Conference on Data Engineering (ICDE), San Diego, CA, 19-22 April 2017, 921-932.  
https://doi.org/10.1109/ICDE.2017.140</mixed-citation></ref><ref id="hanspub.33936-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Gottlob, G. and Nash, A. (2006) Data Exchange: Computing Cores in Polynomial Time. ACM Sigmod-Sigact-Sigart Symposium on Principles of Database Systems, June 2006, 40-49.  
https://doi.org/10.1145/1142351.1142358</mixed-citation></ref><ref id="hanspub.33936-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Yousfi, A., Elyazidi, M.H. and Zellou, A. (2018) Assessing the Performance of a New Semantic Similarity Measure Designed for Schema Matching for Mediation Systems. In: International Conference on Computational Collective Intelligence, Springer, Cham, 64-74.  
https://doi.org/10.1007/978-3-319-98443-8_7</mixed-citation></ref><ref id="hanspub.33936-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Kettouch, M., Luca, C. and Hobbs, M. (2017) Schema Matching for Semi-structured and Linked Data. 2017 IEEE 11th International Conference on Semantic Computing (ICSC), San Diego, CA, 30 January-1 February 2017, 270-271.  
https://doi.org/10.1109/ICSC.2017.104</mixed-citation></ref><ref id="hanspub.33936-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Sekhavat, Y.A. and Parsons, J. (2017) SEDEX: Scalable Entity Preserving Data Exchange. 2017 IEEE 33rd International Conference on Data Engineering (ICDE), San Diego, CA, 19-22 April 2017, 65-66.  
https://doi.org/10.1109/ICDE.2017.39</mixed-citation></ref><ref id="hanspub.33936-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Alexe, B., ten Cate, B., Kolaitis, P.G. and Tan, W. (2011) EIRENE: Interactive Design and Refinement of Schema Mappings via Data Examples. Proceedings of the VLDB Endowment, 4, 1414-1417.  
https://doi.org/10.1145/2043652.2043656</mixed-citation></ref><ref id="hanspub.33936-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Alexe, B., Hernndez, M., Popa, L. and Tan, W.C. (2012) MapMerge: Correlating Independent Schema Mappings. The VLDB Journal, 21, 191-211.  
https://doi.org/10.1007/s00778-012-0264-z</mixed-citation></ref><ref id="hanspub.33936-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">解筱, 张克, 任伯群, 等. ETL技术在商业银行数据整合中的研究与应用[J]. 信息技术与信息化, 2019(7): 45-47.</mixed-citation></ref><ref id="hanspub.33936-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">丁强龙, 王津, 张学杰. 基于子模式的关系数据到图数据ETL方法研究[J]. 计算机工程与应用, 2017, 53(12): 76-84.</mixed-citation></ref><ref id="hanspub.33936-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">李磊. ETL任务集群调度方法[J]. 计算机技术与发展, 2018, 28(11): 41-44.</mixed-citation></ref><ref id="hanspub.33936-ref14"><label>14</label><mixed-citation publication-type="other" xlink:type="simple">Baker, C.A. (1995) Extended Skolem Sequences. Journal of Combinatorial Designs, 3, 363-379.  
https://doi.org/10.1002/jcd.3180030507</mixed-citation></ref><ref id="hanspub.33936-ref15"><label>15</label><mixed-citation publication-type="other" xlink:type="simple">Ravichandra, S. and Somayajulu, D.V.L.N. (2015) Core Schema Mappings: Computing Core Solution with Target Dependencies in Data Exchange.</mixed-citation></ref><ref id="hanspub.33936-ref16"><label>16</label><mixed-citation publication-type="other" xlink:type="simple">吕劲松, 王忠. 金融审计中的数据分析[J]. 审计研究, 2014(5): 28-33.</mixed-citation></ref><ref id="hanspub.33936-ref17"><label>17</label><mixed-citation publication-type="other" xlink:type="simple">Fan, H., Deng, K. and Liu, J. (2016) An Approach of XML Schema Matching Using Top-K Mapping. 2016 3rd International Conference on Information Science &amp; Control Engineering (ICISCE), Beijing, 8-10 July 2016, 174-178.  
https://doi.org/10.1109/ICISCE.2016.47</mixed-citation></ref><ref id="hanspub.33936-ref18"><label>18</label><mixed-citation publication-type="other" xlink:type="simple">Hsu, I.C., Yang, L.J., Huang, D.C., et al. (2014) Integrating Semantic Web Technologies with XML Schema Using Role-Mapping Annotations. The Electronic Library, 32, 147-169. 
https://doi.org/10.1108/EL-07-2012-0096</mixed-citation></ref></ref-list></back></article>