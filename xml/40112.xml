<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE article  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd"><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research article"><front><journal-meta><journal-id journal-id-type="publisher-id">CSA</journal-id><journal-title-group><journal-title>Computer Science and Application</journal-title></journal-title-group><issn pub-type="epub">2161-8801</issn><publisher><publisher-name>Scientific Research Publishing</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.12677/CSA.2021.111020</article-id><article-id pub-id-type="publisher-id">CSA-40112</article-id><article-categories><subj-group subj-group-type="heading"><subject>CSA20210100000_49066057.pdf</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>信息通讯</subject></subj-group></article-categories><title-group><article-title>
 
 
  跨站脚本(XSS)攻击与防护方法研究
  Research on Cross-Site Scripting Attack and Prevention Methods
 
</article-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>王</surname><given-names>亚东</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><label>1</label><addr-line>null</addr-line></aff><aff id="aff2"><label>1</label><addr-line>新疆大学信息科学与工程学院，新疆 乌鲁木齐</addr-line></aff><pub-date pub-type="epub"><day>08</day><month>01</month><year>2021</year></pub-date><volume>11</volume><issue>01</issue><fpage>195</fpage><lpage>206</lpage><permissions><copyright-statement>&#169; Copyright  2014 by authors and Scientific Research Publishing Inc. </copyright-statement><copyright-year>2014</copyright-year><license><license-p>This work is licensed under the Creative Commons Attribution International License (CC BY). http://creativecommons.org/licenses/by/4.0/</license-p></license></permissions><abstract><p>
 
 
   
   跨站脚本(XSS)攻击多次位列OWASP (开放Web应用安全项目) Top10漏洞列表，是Web客户端面临的最严重的安全危害之一，为有效防御XSS攻击，本文提出了客户端和服务端相结合的XSS攻击防护方法。在客户端，首先判断输入是否为编码后的文本，如果是编码后的文本内容则解码后进行黑名单过滤，如果是未编码的，则直接过滤；在服务端采取强制输出格式的方法对输出到页面的内容进行格式限制，以此防御未知攻击载荷的XSS攻击。此外，通过搭建本地测试环境WAMP (Windows + Apache + Mysql + PHP)，对XSS攻击过程进行模拟研究，并对本文提出的防护方法进行验证。实验的结果表明，本文提出的XSS防护方法能够有效合理地防御XSS攻击。 Cross-site scripting (XSS) attack has been listed as one of the Top10 vulnerabilities in OWASP (open Web application security project) many times, and is one of the most serious security hazards faced by Web clients. In order to effectively defend against XSS attacks, this paper proposes an XSS attack protection method combining client and server. On the client side, the input is judged to be encoded text at first. If it is encoded text, the blacklist is filtered after decoding; if it is unencoded, it is directly filtered. At the server side, the output format is forced to restrict the content output to the page, so as to prevent the XSS attack of unknown attack payloads. In addition, the local test environment WAMP (Windows + Apache + Mysql + PHP) was set up to simulate the XSS attack process, and the protection method proposed in this paper was verified. The experimental results show that the XSS protection method proposed in this paper can effectively and reasonably defend against XSS attacks. 
  
 
</p></abstract><kwd-group><kwd>跨站脚本，Web漏洞，防护方法, Cross-Site Scripting</kwd><kwd> Web Application Vulnerability</kwd><kwd> Prevention Methods</kwd></kwd-group></article-meta></front><body><sec id="s1"><title>摘要</title><p>跨站脚本(XSS)攻击多次位列OWASP (开放Web应用安全项目) Top10漏洞列表，是Web客户端面临的最严重的安全危害之一，为有效防御XSS攻击，本文提出了客户端和服务端相结合的XSS攻击防护方法。在客户端，首先判断输入是否为编码后的文本，如果是编码后的文本内容则解码后进行黑名单过滤，如果是未编码的，则直接过滤；在服务端采取强制输出格式的方法对输出到页面的内容进行格式限制，以此防御未知攻击载荷的XSS攻击。此外，通过搭建本地测试环境WAMP (Windows + Apache + Mysql + PHP)，对XSS攻击过程进行模拟研究，并对本文提出的防护方法进行验证。实验的结果表明，本文提出的XSS防护方法能够有效合理地防御XSS攻击。</p></sec><sec id="s2"><title>关键词</title><p>跨站脚本，Web漏洞，防护方法</p></sec><sec id="s3"><title>Research on Cross-Site Scripting Attack and Prevention Methods<sup> </sup></title><p>Yadong Wang</p><p>College of Information Science and Engineering, Xinjiang University, Urumqi Xinjiang</p><p><img src="//html.hanspub.org/file/20-1541995x4_hanspub.png" /></p><p>Received: Dec. 27<sup>th</sup>, 2020; accepted: Jan. 21<sup>st</sup>, 2021; published: Jan. 28<sup>th</sup>, 2021</p><p><img src="//html.hanspub.org/file/20-1541995x5_hanspub.png" /></p></sec><sec id="s4"><title>ABSTRACT</title><p>Cross-site scripting (XSS) attack has been listed as one of the Top10 vulnerabilities in OWASP (open Web application security project) many times, and is one of the most serious security hazards faced by Web clients. In order to effectively defend against XSS attacks, this paper proposes an XSS attack protection method combining client and server. On the client side, the input is judged to be encoded text at first. If it is encoded text, the blacklist is filtered after decoding; if it is unencoded, it is directly filtered. At the server side, the output format is forced to restrict the content output to the page, so as to prevent the XSS attack of unknown attack payloads. In addition, the local test environment WAMP (Windows + Apache + Mysql + PHP) was set up to simulate the XSS attack process, and the protection method proposed in this paper was verified. The experimental results show that the XSS protection method proposed in this paper can effectively and reasonably defend against XSS attacks.</p><p>Keywords:Cross-Site Scripting, Web Application Vulnerability, Prevention Methods</p><disp-formula id="hanspub.40112-formula16"><graphic xlink:href="//html.hanspub.org/file/20-1541995x6_hanspub.png"  xlink:type="simple"/></disp-formula><p>Copyright &#169; 2021 by author(s) and Hans Publishers Inc.</p><p>This work is licensed under the Creative Commons Attribution International License (CC BY 4.0).</p><p>http://creativecommons.org/licenses/by/4.0/</p><p><img src="//html.hanspub.org/file/20-1541995x7_hanspub.png" /> <img src="//html.hanspub.org/file/20-1541995x8_hanspub.png" /></p></sec><sec id="s5"><title>1. 引言</title><p>Web技术的快速发展，几乎使得人们生活领域的方方面面都应用到了Web应用程序，Web应用程序使用了大量的脚本语言，发展出了社交网络、在线购物和新闻发布浏览等复合型功能的Web程序。但随着Web程序功能复杂性的提高，也出现了很多问题，比如在很多应用程序的应用场景中，会要求用户提供个人的身份认证等隐私数据，这也给恶意攻击者提供了可乘之机，恶意攻击者会借助各种非法手段盗取用户的隐私信息，进而实施其他更严重的违法行为，给用户的利益造成伤害。</p><p>跨站脚本攻击(Cross-site scripting, XSS)是Web应用安全问题的主要威胁之一 [<xref ref-type="bibr" rid="hanspub.40112-ref1">1</xref>]。造成跨站脚本攻击的主要原因是Web应用程序未对用户输入的内容进行有效的过滤，导致恶意脚本代码被用户的浏览器所执行，导致了用户信息的泄露、钓鱼欺骗等一系列恶意事件。近年来，跨站脚本攻击事件屡见不鲜，网络安全公司WebCohort的报告显示，超过80%的应用程序存在XSS漏洞 [<xref ref-type="bibr" rid="hanspub.40112-ref2">2</xref>]，Twitter、微博和百度贴吧多次发生跨站脚本蠕虫攻击 [<xref ref-type="bibr" rid="hanspub.40112-ref3">3</xref>]。OWASP (Open Web Application Security Project)作为Web应用安全领域的权威，其每四年发布的OWASP Top10漏洞列表中，跨站脚本攻击始终位居前列。针对频发的跨站脚本攻击事件，国内外研究学者提出了多种解决方案。Shanly C等提出了一种Skip List算法，来进行XSS漏洞的检测，借助XSS攻击向量表，在识别准确率和算法的性能上行有了较大的提高 [<xref ref-type="bibr" rid="hanspub.40112-ref4">4</xref>]；Shashank Gupta提出了XSS防御框架，该框架是基于内容敏感的，目的是检测出隐藏在HTML5 Web应用程序中的XSS恶意代码，缺点是该框架必须部署在云平台，对服务器的性能要求较高，对中小企业并不友好 [<xref ref-type="bibr" rid="hanspub.40112-ref5">5</xref>]。</p><p>本文主要研究了XSS攻击的原理和存在的根本性原因，并对XSS的防护方法进行了深入研究，通过对XSS攻击相关的Web安全策略的研究和对这些策略存在缺陷的探讨阐述，进一步搭建“留言板系统”仿真实验环境，总结XSS攻击过程和原理，并在最后提出了针对XSS攻击的防护方法，将本文的方法部署在仿真环境中，通过攻击测试实验，证明了XSS防护方法的有效性。</p></sec><sec id="s6"><title>2. XSS漏洞存在的原因分析</title><sec id="s6_1"><title>2.1. 同源策略及缺陷</title><p>同源策略(SOP)亦称为同域策略，指的是互相访问的站点之间具备相同的协议、域名和端口 [<xref ref-type="bibr" rid="hanspub.40112-ref6">6</xref>]。即限定动态的内容(比如：JavaScript、ActionScript)仅可以读取或修改和自身同源的HTTP请求及Cookie，不同源的请求或者内容不被允许进行读取和修改等操作，但是不同源的网站之间可以提出请求。同源策略没有明确规范的协议，保证了浏览器的正常跨域通信功能，市面上的浏览器基本上都支持同源策略。</p><p>假定有域xj.com，这个域包含多个子域，以m.xj.com和n.xj.com为例，进一步设定该域名下的所有页面均具有JavaScript脚本，表1描述的是不同页面之间能否互相访问，即发送通信请求并读取响应来判断是否遵循同源策略。</p><table-wrap id="table1" ><label><xref ref-type="table" rid="table1">Table 1</xref></label><caption><title> Same-origin policy instanc</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >站点1</th><th align="center" valign="middle" >站点2</th><th align="center" valign="middle" >是否同源</th><th align="center" valign="middle" >原因</th></tr></thead><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >http://www.xj.com/b.html</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >协议、域名、端口均相同</td></tr><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >http://www.xj.com:81/a.html</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >http协议默认端口80，站点2端口为81</td></tr><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >http://m.xj.com/a.html</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >域与子域之间认定是不同域</td></tr><tr><td align="center" valign="middle" >http://m.xj.com/a.html</td><td align="center" valign="middle" >http://n.xj.com/a.html</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >不同子域之间被看作不同域</td></tr><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >http://www.xj.com/a/c.html</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >页面所在目录不同，但端口、协议、域名均相同</td></tr><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >https://www.xj.com/a.html</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >遵从的协议不相同</td></tr><tr><td align="center" valign="middle" >http://www.xj.com/a.html</td><td align="center" valign="middle" >http: //xj.com/a.html</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >主机名不同。前者为www.xj.com，后者为xj.com</td></tr></tbody></table></table-wrap><p>表1. 同源策略实例</p><p>HTML中所使用的&lt; script &gt;、&lt; link &gt;、&lt; iframe &gt;等标签可以跨域加载需要的资源而不被同源策略限制，此外，XMLHttpRequest通过目标域返回HTTP授权时也是可以跨域访问的，因为JavaScript不能控制HTTP的头部。从表1中可以看出，同属于一个域的子域之间也会被同源策略所限制，使得在开发Web应用时产生很多不便。为了解决这个问题，同源策略允许同一个域的不同子域的页面之间，通过对document.domain变量进行设置，有限的违反同源策略，使得子域的页面之间可以相互访问。这种有限度的违反同源策略也给Web应用带来了安全隐患。假设域中的某个页面存在XSS漏洞，那么恶意攻击者就可以向这个页面注入JavaScript代码，因为document.domain变量的存在，则意味着同时可以向该域中的任意页面注入JavaScript代码。</p></sec><sec id="s6_2"><title>2.2. Cookie安全策略</title><p>RFC2109规定：Web服务器被允许把用户信息及HTTP会话状态等数据写入客户端，并且以文件的形式存储在用户的计算机中 [<xref ref-type="bibr" rid="hanspub.40112-ref7">7</xref>]。当用户发起HTTP会话时，HTTP会话能使用HTTP头部把用户的Cookie发送到指定的Web服务器。近乎所有的Web应用均是利用Cookie来标记用户和保持会话状态。根据Cookie生存周期的不同，一般将其分为对话Cookie (亦称临时Cookie)和本地Cookie (亦称第三方Cookie)。会话Cookie，在用户浏览网页时，浏览器与服务器建立了Session，Cookie存放在浏览器的进程内存中，一旦浏览器关闭，则Cookie失效，只要浏览器不关闭，用户打开多少个别的标签页，Cookie依然是有效的；本地Cookie的值存放在客户端浏览器之中，本地Cookie在被创建时一同设置了生存周期，超过生存周期的Cookie便失效。</p><p>Cookie包含Domain、Path、Secure、Expires和HttpOnly等安全属性。</p><p>Secure属性是非必选的，该属性被设定时，只有用户发起HTTPS会话时，才会发送Cookie。该属性允许HTTP和HTTPS响应对设置进行修改，所以HTTP应答也能改变HTTPS应答所设置的Cookie的Secure属性，进一步导致HTTP请求能够获取Cookie值，容易造成CSRF攻击和XSS攻击；Expires属性能够限制Cookie的有效时间，一般情况下，未设置该属性，则浏览器关闭时，Cookie就被删除，设置了该属性，则Cookie在设定的时间之前都是有效的；HttpOnly属性的设置目的为保证用户Cookie的安全性，一旦该属性被设置，则浏览器无法通过JavaScript的document.cookie进行访问。</p><p>因为浏览器的安全策略不尽相同，当浏览器中某个域的页面想要加载其他域中的资源，有的浏览器会禁止发送第三方Cookie。通过对不同浏览器的调研得到表2。浏览器支持第三方Cookie的发送将会使得XSS攻击盗取用户身份信息变得简单，不必保证用户登录的网页还处于活动状态，只需要用户在第三方Cookie生存周期内登陆过目标网站即可。</p><table-wrap id="table2" ><label><xref ref-type="table" rid="table2">Table 2</xref></label><caption><title> Third-party Cookie support in the browse</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >浏览器名称</th><th align="center" valign="middle" >是否默认支持第三方Cookie</th><th align="center" valign="middle" >是否支持P3P</th></tr></thead><tr><td align="center" valign="middle" >IE6-IE9</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >是</td></tr><tr><td align="center" valign="middle" >火狐</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >否</td></tr><tr><td align="center" valign="middle" >Chrome</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >部分支持</td></tr><tr><td align="center" valign="middle" >Safari</td><td align="center" valign="middle" >否</td><td align="center" valign="middle" >否</td></tr><tr><td align="center" valign="middle" >Opera</td><td align="center" valign="middle" >是</td><td align="center" valign="middle" >否</td></tr></tbody></table></table-wrap><p>表2. 浏览器的第三方Cookie支持情况</p></sec></sec><sec id="s7"><title>3. XSS攻击原理与攻击模拟分析</title><sec id="s7_1"><title>3.1. XSS攻击原理</title><p>跨站脚本攻击(Cross Site Scripting)是一种经常出现在Web应用程序中的计算机安全漏洞，是由于Web应用程序对用户的输入信息过滤不足而产生的 [<xref ref-type="bibr" rid="hanspub.40112-ref8">8</xref>]。攻击者利用网站漏洞把恶意的脚本代码(一般包括JavaScript和HTML代码)注入网页，当其他用户浏览被注入脚本代码的网页时，便会自动执行嵌入的恶意代码，可能导致用户的身份信息盗用、钓鱼欺骗和XSS蠕虫病毒等。</p><p>因为这种漏洞最早展示的时候是跨域执行的，故称为跨站脚本攻击，跨域指的是绕过同源策略 [<xref ref-type="bibr" rid="hanspub.40112-ref9">9</xref>]。又因为其与层叠样式表(Cascading Style Sheets, CSS)的缩写冲突，为了防止混淆，故将其简写为“XSS”。通常情况下，既可以将跨站脚本理解成一种Web安全漏洞，也可以看作是一种攻击手段。</p><p>XSS漏洞存在许多种不同的表现形式，普遍将其分为三类：反射型、存储型和DOM型，划分的依据是XSS漏洞的触发方式 [<xref ref-type="bibr" rid="hanspub.40112-ref10">10</xref>]。但因为DOM类型的本质依然是反射型XSS，故也有学者将XSS分为反射型和存储型两类。本文默认跨站脚本攻击分为三类。</p></sec><sec id="s7_2"><title>3.2. XSS漏洞的分类</title><sec id="s7_2_1"><title>3.2.1. 反射型XSS</title><p>也称为非持久型XSS，是最常见也是使用最广的一种跨站脚本攻击 [<xref ref-type="bibr" rid="hanspub.40112-ref11">11</xref>]。攻击者通过电子邮件等特定手法，诱使潜在受害者去访问包含恶意代码的URL，一旦受害者点击了这些专门设计的链接时，恶意脚本代码便会直接在受害者的主机浏览器上执行，如果Web应用程序对用户的输入过滤不全，就会很容易触发反射型XSS。因为反射型XSS只有当用户单击时才能触发，而且只执行一次，所以也被称为非持久性XSS，图1为反射型XSS攻击流程示意图。</p><p>图1为反射型XSS攻击流程示意图，可以看出反射型XSS攻击流程如下：</p><p>1) 用户在Web应用程序中登录网站，该程序保存用户的Cookie信息；</p><p>2) 攻击者将经过设计的含有恶意脚本代码的URL发送给目标用户，诱使用户点击URL；</p><p>3) 用户访问该URL后，URL中包含的恶意脚本代码便被发送到服务器；</p><p>图1. 反射型XSS攻击过程</p><p>4) 服务器解析用户请求，并将恶意脚本嵌入含有漏洞的HTML页面中反馈给用户；</p><p>5) 用户的Web应用程序接收到反馈后，执行页面中包含的脚本代码；</p><p>6) 恶意脚本在用户浏览器中执行后，用户的Cookie信息等被发送到攻击者的服务器；</p><p>7) 攻击者获取用户信息，完成劫持会话等操作。</p></sec><sec id="s7_2_2"><title>3.2.2. 存储型XSS</title><p>也称为持久型XSS。因为存储型XSS须要Web应用程序向服务器发大于两次的HTTP请求，故也称作二阶跨站脚本攻击 [<xref ref-type="bibr" rid="hanspub.40112-ref12">12</xref>]。其中攻击者把恶意脚本代码上传并存储到服务器上是第一次HTTP请求；目标用户链接到包含恶意代码的网页并触发HTTP请求是第二次HTTP请求。允许用户存储数据的Web应用程序都可能会出现存储型XSS，一般情况下，出现这种漏洞的原因都是网页或者Web应用程序未对用户的输入信息进行过滤，导致脚本代码被直接存储到数据库。</p><p>图2为存储型XSS攻击流程示意图。与反射型XSS流程图相比可以看出，存储型XSS攻击的第一步是将恶意脚本的代码存储到Web服务器中，等待目标浏览存储恶意代码的页面即可；而反射型XSS则要求将构造好的包含恶意脚本代码的URL直接发送给目标，并诱使目标点击访问该URL。由于存储型XSS的这些特点，因此存储型XSS更容易造成大规模的安全事件，还有可能对Web服务器的安全性产生不利影响。</p><p>图2. 存储型XSS攻击过程</p><p>图2为存储型XSS攻击流程示意图，可以看出存储型XSS攻击流程如下：</p><p>1) 攻击者将经过包含恶意脚本代码提交至服务器，服务器存储恶意代码；</p><p>2) 用户在Web应用程序中登录网站，该程序保存用户的Cookie信息；</p><p>3) 用户访问包含恶意代码的网页；</p><p>4) 服务器解析用户请求，并包含恶意脚本代码的页面中反馈给用户；</p><p>5) 用户的Web应用程序接收到反馈后，执行页面中包含的脚本代码；</p><p>6) 恶意脚本在用户浏览器中执行后，用户的Cookie信息等被发送到攻击者的服务器；</p><p>7) 攻击者获取用户信息，完成劫持会话等操作。</p></sec><sec id="s7_2_3"><title>3.2.3. DOM型XSS</title><p>反射型XSS和存储型XSS均需要将构造的URL发送到服务器，URL中包含的恶意脚本代码由服务器端执行并嵌入到反馈给受害者的页面中，DOM型XSS不需要将URL发送给服务器处理，而是在客户端的Web应用程序中执行 [<xref ref-type="bibr" rid="hanspub.40112-ref13">13</xref>]。DOM型XSS实现的原理是脚本代码能够借用document.URL变量访问URL，可以将脚本嵌入到脚本程序中，进一步使用该脚本调用document.URL变量，获取其中的数据信息，通过数据信息动态更新页面。由于页面显示的内容是通过这些数据完成更新，所以有可能造成DOM型XSS攻击的发生。</p><p>反射型XSS和存储型XSS攻击造成的结果可以在服务器返回的页面中查看到跨站脚本的攻击载荷，但是在DOM型XSS的攻击中，HTML源码与遭到攻击后返回的页面源码完全一致，无法在返回的页面中查找到跨站脚本攻击的攻击载荷，只能通过动态运行或者查看网页的DOM树时才能观测到。图3是DOM型XSS攻击流程的示意图。</p><p>图3. DOM型XSS攻击过程</p><p>从图3中可以看出，DOM型XSS与反射型XSS的攻击过程基本相似，均为攻击者诱使用户访问恶意URL才能发动攻击。然而，存在差异的点为DOM型XSS攻击中，恶意脚本代码并没有经过服务器中转，服务器仅仅是对正常页面的响应，当浏览器处理服务器返回的响应时，恶意脚本代码才被嵌入页面并执行。</p></sec></sec><sec id="s7_3"><title>3.3. XSS攻击模拟分析</title><p>在仔细研究XSS攻击原理的基础上，通过搭建仿真测试环境“留言板系统”为例，对存储型XSS攻击进行模拟测试和研究。留言板系统的开发语言为PHP，使用Apache服务器，数据库为MySQL5.5。该系统可以实现查看留言、留言和后台的留言管理功能，留言需要审核后才能被查看。系统界面如图4所示。</p><p>图4. 留言板系统界面</p><p>在“编写留言”界面输入“&lt; script &gt;alert(存在存储型xss)&lt; /script &gt;”，点击提交留言后，留言内容被提交到数据库。管理员登录后台，对留言内容进行审查，此时便出现了弹窗，如图5所示。</p><p>图5. XSS弹窗攻击</p><p>出现弹窗的原因是，管理员登录后台进行留言管理时，数据库存放的留言内容(如图6)被直接发送到管理员，而页面并未对输出到页面端的内容进行过滤。</p><p>图6. 数据库留言内容</p><p>接下来用管理员身份对留言进行审核，审核通过后，再次查看留言板主页面，即“查看留言”界面，此时，页面弹窗提示，如图7所示。</p><p>图7. 留言板前端弹窗</p><p>对主页的源码进行分析发现(如图8)，“查看留言”页面并未对数据库返回的内容进行过滤，使得数据库存储的语句被前端的JavaScript引擎直接运行alert命令，导致弹窗现象的发生，说明了该留言板系统在“查看留言”“编写留言”“留言管理”三个页面中均存在存储型XSS漏洞。</p><p>图8. 前端弹窗代码</p></sec></sec><sec id="s8"><title>4. XSS攻击的防护方法</title><p>XSS漏洞攻击的防御一般有两种方式：输入过滤或输出转义(输出编码)。</p><p>输入过滤是指对Web用户提交到服务器的数据进行验证，判断其合规性，比如查验输入的内容是否仅含有合法的字符、输入的数字是否在有效范围内以及特殊格式是否符合格式要求等，对于不满足条件的输入内容服务器或者浏览器进行忽略操作，要求用户重新输入符合要求的内容，此外还会过滤&lt; script &gt;、&lt; iframe &gt;等关键字以及“onchange”等JavaScript事件标签等。</p><p>输出转义是指对会话请求的报文中输入信息的特殊符号执行转义编码操作，导致XSS payload丧失原有的攻击能力，此时再将请求报文的信息写入响应报文，反馈给客户端的Web应用程序，Web应用程序接收报文后解析响应不会触发已经失效的XSS payload，常见编码符号如“&lt; ”和“&amp;”的实体编号分别为“&amp;#60”和“&amp;#38”。</p><sec id="s8_1"><title>4.1. XSS攻击防护框架</title><p>本文提出一种跨站脚本攻击防护方法，框架如图9所示。包含“输入管理”和“输出管理”两个核心模块。</p><p>输入管理模块：这个模块实现两个功能，一是判定用户输入的内容是否是编码过的；二是根据过滤的规则对输入内容进行过滤。如果用户输入的内容为编码后的，则解码后进行过滤，如果输入内容未编码，则直接过滤。</p><p>输出管理模块：根据网页不同版块的内容强制输出内容的格式，防止脚本代码等非信任信息的输出。</p><p>图9. XSS攻击防护框架</p></sec><sec id="s8_2"><title>4.2. 输入管理</title><sec id="s8_2_1"><title>4.2.1. 输入解码</title><p>用户正常的输入内容不会引起XSS攻击，但是攻击者会利用用户的输入框输入攻击内容进行攻击，由于Web支持多种编码方式(如：URL编码、Hex编码等)，攻击者可以通过编码等方式来绕过服务端或者管理员的审核，导致XSS攻击载荷的成功注入，因此需要对用具的输入进行判断，如果输入的内容经过编码，则需要对编码后的信息进行解码，以此进行下一步的过滤操作。</p><p>本文将出现频率较高的URL编码、Hex编码、HTML编码和Unicode编码方式纳入解码的范围，不同的编码会导致字符有不同的结果，以“&lt; iframe &gt;”为例，四种不同编码方式编码的结果如表3所示。</p><table-wrap id="table3" ><label><xref ref-type="table" rid="table3">Table 3</xref></label><caption><title> &lt; iframe &gt; encoding method and resul</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >编码对象</th><th align="center" valign="middle" >编码方式</th><th align="center" valign="middle" >编码结果</th></tr></thead><tr><td align="center" valign="middle" >&lt; iframe &gt;</td><td align="center" valign="middle" >URL编码</td><td align="center" valign="middle" >%3ciframe%3e</td></tr><tr><td align="center" valign="middle" >&lt; iframe &gt;</td><td align="center" valign="middle" >Hex编码</td><td align="center" valign="middle" >%3C%69%66%72%61%6D%65%3E</td></tr><tr><td align="center" valign="middle" >&lt; iframe &gt;</td><td align="center" valign="middle" >HTML编码</td><td align="center" valign="middle" >&amp;lt;iframe&amp;gt;</td></tr><tr><td align="center" valign="middle" >&lt; iframe &gt;</td><td align="center" valign="middle" >Unicode编码</td><td align="center" valign="middle" >\u0026\u006c\u0074\u003b\u0069\u0066\u0072\u0061\u006d\u0065\u0026\u0067\u0074\u003b</td></tr></tbody></table></table-wrap><p>表3. &lt; iframe &gt;编码方式与结果</p><p>从编码的结果可以看出特征字符的不同，通过匹配特征字符区分编码的方式，然后分别进行解码，以Unicode解码为例，核心代码如图10所示。</p><p>图10. Unicode解码</p></sec><sec id="s8_2_2"><title>4.2.2 . 输入过滤</title><p>Web应用程序认为输入的内容是完全正常无害的，所以对用户输入的内容不进行过滤便读取执行，这就是造成XSS攻击泛滥的原因之一。在XSS供给端的防护方案中，输入过滤模块是防御XSS攻击的主要模块，该模块主要对用户输入的内容进行审核，判断输入的内容是否含有XSS攻击。</p><p>输入过滤模块首先将输入流中格式进行统一，例如将所有大写字符变为小写等；其次对输入流中的特殊字符进行处理，包括过滤非打印字符，进行回车、换行和连续空格字符的替换等；最后根据黑名单筛选输入流。黑名单所涵盖的对象如表4所示，非法字符的过滤和黑名单(部分)的设置代码如图11所示。</p><table-wrap id="table4" ><label><xref ref-type="table" rid="table4">Table 4</xref></label><caption><title> Blacklist object setting</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >对象</th><th align="center" valign="middle" >内容</th></tr></thead><tr><td align="center" valign="middle" >HTML标签内容</td><td align="center" valign="middle" >script、object、style、iframe等</td></tr><tr><td align="center" valign="middle" >JavaScript事件处理函数</td><td align="center" valign="middle" >ondrop、onhelp、onerror、onmouseup等</td></tr><tr><td align="center" valign="middle" >其他</td><td align="center" valign="middle" >JavaScript、VBScript、applet、xml等</td></tr></tbody></table></table-wrap><p>表4. 黑名单对象设置</p><p>图11. 黑名单过滤</p></sec><sec id="s8_2_3"><title>4.2.3 . 输出管理</title><p>输入过滤模块仅能针对已知的XSS攻击命令来防止XSS攻击，对未知的XSS攻击防范较差，所以本文对服务端返回客户端的信息也进行了处理，来防范未知的XSS攻击形式。</p><p>常规的输出端管理采取的是输出编码的方式，即对特定字符进行转义后输出，例如将“&amp;”、“&lt; ”、“ &gt;”转义为“&amp;amp;”、“&amp;lt;”、“&amp;gt;”后输出，避免了脚本标签的执行。由于网页输出内容的相对固定，比如本文的存储型XSS攻击模拟实验的留言板管理系统，输出到网页端的内容完全为文本格式，因此本文通过在输出端强制内容输出的格式，避免输出内容被当做HTML解析，来防止XSS攻击的发生。以留言板管理系统为例，可以在“content-type”中指定读取文件的类型为“text”或者使用“&lt; xmp &gt;”来规定内容显示形式来规避XSS攻击。</p></sec></sec><sec id="s8_3"><title>4.3. XSS防护方法实验评估</title><p>实验评估使用本文开发的留言板系统进行，测试数据集为XSS Cheat Sheet中的300个攻击载荷样本和正常输入的300个样本，对比对象为Chrome上比较流行的第三方XSS脚本过滤扩展程序Html Purify和AntiXssUF，测试结果如表5所示，图12为强制输出格式实验测试效果。</p><table-wrap id="table5" ><label><xref ref-type="table" rid="table5">Table 5</xref></label><caption><title> Comparison of the effect of three detection filter</title></caption><table><tbody><thead><tr><th align="center" valign="middle" >测试插件</th><th align="center" valign="middle" >准确率</th><th align="center" valign="middle" >误报率</th><th align="center" valign="middle" >漏洞率</th></tr></thead><tr><td align="center" valign="middle" >Html Purify</td><td align="center" valign="middle" >90.3%</td><td align="center" valign="middle" >5.3%</td><td align="center" valign="middle" >8.3%</td></tr><tr><td align="center" valign="middle" >AntiXssUF</td><td align="center" valign="middle" >88.9%</td><td align="center" valign="middle" >5.1%</td><td align="center" valign="middle" >7.1%</td></tr><tr><td align="center" valign="middle" >XSS Protect (本文方法)</td><td align="center" valign="middle" >92.6%</td><td align="center" valign="middle" >4.9%</td><td align="center" valign="middle" >5.5%</td></tr></tbody></table></table-wrap><p>表5. 3种检测过滤器的效果对比</p><p>图12. 服务端防护效果验证</p><p>由三款过滤器的实验对比结果可以看出，本文提出的XSS防护方案中的前端过滤模块可以较好的过滤已知的攻击载荷，并且在识别准确率、误报率和漏报率的表现均优于Html Purify插件及AntiXssUF插件；并且在输出管理模块中，原本造成弹窗的“&lt; script &gt;alert (“存在存储型XSS”)&lt; /script &gt;”的攻击载荷并未引起弹窗(图12所示)，而是被完整的以文本的形式输出。综上可以证明本文提出的XSS防护方案的有效性。</p></sec></sec><sec id="s9"><title>5. 结束语</title><p>本文通过解析与XSS漏洞相关的Web安全策略概念和缺陷，进一步对产生XSS攻击的原理和过程进行了研究，通过搭建本地仿真测试环境“留言板系统”，对影响最大的存储型XSS攻击进行了实例分析，并且提出了针对XSS漏洞攻击的防护方法，辅以攻击脚本的测试实验，证明了本文方法的有效性。由于在客户端过滤模块依然采取的是人工设置黑名单的方法，因此具备一定的滞后性，今后应该结合深度学习提出自动化更新黑名单的方法。</p></sec><sec id="s10"><title>文章引用</title><p>王亚东. 跨站脚本(XSS)攻击与防护方法研究Research on Cross-Site Scripting Attack and Prevention Methods[J]. 计算机科学与应用, 2021, 11(01): 195-206. https://doi.org/10.12677/CSA.2021.111020</p></sec><sec id="s11"><title>参考文献</title></sec></body><back><ref-list><title>References</title><ref id="hanspub.40112-ref1"><label>1</label><mixed-citation publication-type="other" xlink:type="simple">2019CWE/SANS Top 25 Most Dangerous Software Errors  
&lt;br&gt;https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html</mixed-citation></ref><ref id="hanspub.40112-ref2"><label>2</label><mixed-citation publication-type="other" xlink:type="simple">Shanmugam, J. and Ponnavaikko, M. (2007) Xss Application Worms: New Internet Infestation and Optimized Protective Measures. Eighth ACIS International Con-ference on Software Engineering, Artificial Intelligence, Networking, and Parallel/Distributed Computing (SNPD 2007), 3, 1164-1169. &lt;br&gt;https://doi.org/10.1109/SNPD.2007.514</mixed-citation></ref><ref id="hanspub.40112-ref3"><label>3</label><mixed-citation publication-type="other" xlink:type="simple">Wit, E. and McClure, J. (2004) Statistics for Microar-rays: Design, Analysis, and Inference. 5th Edition, John Wiley &amp; Sons Ltd., Chichester, 5-18.</mixed-citation></ref><ref id="hanspub.40112-ref4"><label>4</label><mixed-citation publication-type="other" xlink:type="simple">Chun, S., Jing, C., Changzhen, H., et al. (2016) A XSS Attack Detection Method based on Skip List. International Journal of Security and its Applications, 10, 95-106. &lt;br&gt;https://doi.org/10.14257/ijsia.2016.10.5.09</mixed-citation></ref><ref id="hanspub.40112-ref5"><label>5</label><mixed-citation publication-type="other" xlink:type="simple">Gupta, S. and Gupta, B.B. (2016) CSSXC: Context-Sensitive Sanitization Framework for Web Applications against XSS Vulnerabilities in Cloud Envi-ronments. Procedia Computer Science, 85, 198-205.  
&lt;br&gt;https://doi.org/10.1016/j.procs.2016.05.211</mixed-citation></ref><ref id="hanspub.40112-ref6"><label>6</label><mixed-citation publication-type="other" xlink:type="simple">Schwenk, J., Niemietz, M. and Mainka, C. (2017) Same-Origin Policy: Evaluation in Modern Browsers. 26th {USENIX} Security Symposium {USENIX} Security, 17, 713-727.</mixed-citation></ref><ref id="hanspub.40112-ref7"><label>7</label><mixed-citation publication-type="other" xlink:type="simple">Barth, A. (2011) Rfc 6265-http State Management Mechanism. Internet Engineering Task Force (IETF), April 2011, 2070-1721. &lt;br&gt;https://doi.org/10.17487/rfc6265</mixed-citation></ref><ref id="hanspub.40112-ref8"><label>8</label><mixed-citation publication-type="other" xlink:type="simple">Di Lucca, G.A., Fasolino, A.R., Mastoianni, M. and Tramontana, P. (2004) Identifying Cross Site Scripting Vulnerabilities in Web Applications. Proceedings. Sixth IEEE In-ternational Workshop on Web Site Evolution, Chicago, IL, 71-80. &lt;br&gt;https://doi.org/10.1109/WSE.2004.10013</mixed-citation></ref><ref id="hanspub.40112-ref9"><label>9</label><mixed-citation publication-type="other" xlink:type="simple">Fogie, S., Grossman, J., Hansen, R., et al. (2007) XSS Attacks: Cross Site Scripting Exploits and Defense. Syngress Publishing, Burlington. &lt;br&gt;https://doi.org/10.1016/B978-159749154-9/50005-6</mixed-citation></ref><ref id="hanspub.40112-ref10"><label>10</label><mixed-citation publication-type="other" xlink:type="simple">Wassermann, G. and Su, Z. (2008) Static Detection of Cross-Site Scripting Vulnerabilities. 30th International Conference on Software Engineering (ICSE 2008), Leipzig, 10-18 May 2008, 171-180.</mixed-citation></ref><ref id="hanspub.40112-ref11"><label>11</label><mixed-citation publication-type="other" xlink:type="simple">王岩, 程绍银, 蒋凡. 自动化检测Android应用反射型跨站脚本漏洞的方法[J]. 计算机系统应用, 2015, 24(7): 195-199.</mixed-citation></ref><ref id="hanspub.40112-ref12"><label>12</label><mixed-citation publication-type="other" xlink:type="simple">窦永富, 崔为红. 应用程序安全设计探析[J]. 计算机系统应用, 2006, 15(9): 83-86.</mixed-citation></ref><ref id="hanspub.40112-ref13"><label>13</label><mixed-citation publication-type="other" xlink:type="simple">Lekies, S., Stock, B. and Johns, M. (2013) 25 Million Flows Later—Large-Scale Detection of DOM-Based XSS. Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp; Communications Security, Berlin, 4-8 November 2013, 1193-1204. &lt;br&gt;https://doi.org/10.1145/2508859.2516703</mixed-citation></ref></ref-list></back></article>